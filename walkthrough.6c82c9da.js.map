{"mappings":"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","sources":["<anon>","node_modules/chart.js/dist/chart.umd.js","node_modules/chart.js/src/helpers/helpers.core.ts","node_modules/chart.js/src/helpers/helpers.math.ts","node_modules/chart.js/src/helpers/helpers.collection.ts","node_modules/chart.js/src/helpers/helpers.extras.ts","node_modules/chart.js/src/core/core.animator.js","node_modules/chart.js/node_modules/.pnpm/@kurkle+color@0.3.2/node_modules/@kurkle/color/dist/color.esm.js","node_modules/chart.js/src/helpers/helpers.color.ts","node_modules/chart.js/src/core/core.animations.defaults.js","node_modules/chart.js/src/helpers/helpers.intl.ts","node_modules/chart.js/src/core/core.ticks.js","node_modules/chart.js/src/core/core.defaults.js","node_modules/chart.js/src/core/core.layouts.defaults.js","node_modules/chart.js/src/core/core.scale.defaults.js","node_modules/chart.js/src/helpers/helpers.dom.ts","node_modules/chart.js/src/helpers/helpers.canvas.ts","node_modules/chart.js/src/helpers/helpers.config.ts","node_modules/chart.js/src/helpers/helpers.curve.ts","node_modules/chart.js/src/helpers/helpers.easing.ts","node_modules/chart.js/src/helpers/helpers.interpolation.ts","node_modules/chart.js/src/helpers/helpers.options.ts","node_modules/chart.js/src/helpers/helpers.rtl.ts","node_modules/chart.js/src/helpers/helpers.segment.js","node_modules/chart.js/src/core/core.interaction.js","node_modules/chart.js/src/core/core.layouts.js","node_modules/chart.js/src/platform/platform.base.js","node_modules/chart.js/src/platform/platform.basic.js","node_modules/chart.js/src/platform/platform.dom.js","node_modules/chart.js/src/platform/index.js","node_modules/chart.js/src/core/core.animation.js","node_modules/chart.js/src/core/core.animations.js","node_modules/chart.js/src/core/core.datasetController.js","node_modules/chart.js/src/core/core.element.ts","node_modules/chart.js/src/core/core.scale.autoskip.js","node_modules/chart.js/src/core/core.scale.js","node_modules/chart.js/src/core/core.typedRegistry.js","node_modules/chart.js/src/core/core.registry.js","node_modules/chart.js/src/core/core.plugins.js","node_modules/chart.js/src/core/core.config.js","node_modules/chart.js/src/core/core.controller.js","node_modules/chart.js/src/core/core.adapters.ts","node_modules/chart.js/src/controllers/controller.bar.js","node_modules/chart.js/src/controllers/controller.doughnut.js","node_modules/chart.js/src/controllers/controller.polarArea.js","node_modules/chart.js/src/controllers/controller.bubble.js","node_modules/chart.js/src/controllers/controller.line.js","node_modules/chart.js/src/controllers/controller.pie.js","node_modules/chart.js/src/controllers/controller.radar.js","node_modules/chart.js/src/controllers/controller.scatter.js","node_modules/chart.js/src/elements/element.arc.ts","node_modules/chart.js/src/elements/element.line.js","node_modules/chart.js/src/elements/element.point.ts","node_modules/chart.js/src/elements/element.bar.js","node_modules/chart.js/src/scales/scale.category.js","node_modules/chart.js/src/scales/scale.linearbase.js","node_modules/chart.js/src/scales/scale.linear.js","node_modules/chart.js/src/scales/scale.logarithmic.js","node_modules/chart.js/src/scales/scale.radialLinear.js","node_modules/chart.js/src/scales/scale.time.js","node_modules/chart.js/src/scales/scale.timeseries.js","node_modules/chart.js/src/plugins/plugin.colors.ts","node_modules/chart.js/src/plugins/plugin.decimation.js","node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","node_modules/chart.js/src/plugins/plugin.filler/index.js","node_modules/chart.js/src/plugins/plugin.legend.js","node_modules/chart.js/src/plugins/plugin.title.js","node_modules/chart.js/src/plugins/plugin.subtitle.js","node_modules/chart.js/src/plugins/plugin.tooltip.js","node_modules/chart.js/src/index.umd.ts"],"sourcesContent":["/*!\n * Chart.js v4.4.8\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ !function(t, e) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Chart = e();\n}(this, function() {\n    \"use strict\";\n    var t = Object.freeze({\n        __proto__: null,\n        get Colors () {\n            return Go;\n        },\n        get Decimation () {\n            return Qo;\n        },\n        get Filler () {\n            return ma;\n        },\n        get Legend () {\n            return ya;\n        },\n        get SubTitle () {\n            return ka;\n        },\n        get Title () {\n            return Ma;\n        },\n        get Tooltip () {\n            return Ba;\n        }\n    });\n    function e() {}\n    const i = (()=>{\n        let t = 0;\n        return ()=>t++;\n    })();\n    function s(t) {\n        return null == t;\n    }\n    function n(t) {\n        if (Array.isArray && Array.isArray(t)) return !0;\n        const e = Object.prototype.toString.call(t);\n        return \"[object\" === e.slice(0, 7) && \"Array]\" === e.slice(-6);\n    }\n    function o(t) {\n        return null !== t && \"[object Object]\" === Object.prototype.toString.call(t);\n    }\n    function a(t) {\n        return (\"number\" == typeof t || t instanceof Number) && isFinite(+t);\n    }\n    function r(t, e) {\n        return a(t) ? t : e;\n    }\n    function l(t, e) {\n        return void 0 === t ? e : t;\n    }\n    const h = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 : +t / e, c = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 * e : +t;\n    function d(t, e, i) {\n        if (t && \"function\" == typeof t.call) return t.apply(i, e);\n    }\n    function u(t, e, i, s) {\n        let a, r, l;\n        if (n(t)) {\n            if (r = t.length, s) for(a = r - 1; a >= 0; a--)e.call(i, t[a], a);\n            else for(a = 0; a < r; a++)e.call(i, t[a], a);\n        } else if (o(t)) for(l = Object.keys(t), r = l.length, a = 0; a < r; a++)e.call(i, t[l[a]], l[a]);\n    }\n    function f(t, e) {\n        let i, s, n, o;\n        if (!t || !e || t.length !== e.length) return !1;\n        for(i = 0, s = t.length; i < s; ++i)if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n        return !0;\n    }\n    function g(t) {\n        if (n(t)) return t.map(g);\n        if (o(t)) {\n            const e = Object.create(null), i = Object.keys(t), s = i.length;\n            let n = 0;\n            for(; n < s; ++n)e[i[n]] = g(t[i[n]]);\n            return e;\n        }\n        return t;\n    }\n    function p(t) {\n        return -1 === [\n            \"__proto__\",\n            \"prototype\",\n            \"constructor\"\n        ].indexOf(t);\n    }\n    function m(t, e, i, s) {\n        if (!p(t)) return;\n        const n = e[t], a = i[t];\n        o(n) && o(a) ? x(n, a, s) : e[t] = g(a);\n    }\n    function x(t, e, i) {\n        const s = n(e) ? e : [\n            e\n        ], a = s.length;\n        if (!o(t)) return t;\n        const r = (i = i || {}).merger || m;\n        let l;\n        for(let e = 0; e < a; ++e){\n            if (l = s[e], !o(l)) continue;\n            const n = Object.keys(l);\n            for(let e = 0, s = n.length; e < s; ++e)r(n[e], t, l, i);\n        }\n        return t;\n    }\n    function b(t, e) {\n        return x(t, e, {\n            merger: _\n        });\n    }\n    function _(t, e, i) {\n        if (!p(t)) return;\n        const s = e[t], n = i[t];\n        o(s) && o(n) ? b(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n));\n    }\n    const y = {\n        \"\": (t)=>t,\n        x: (t)=>t.x,\n        y: (t)=>t.y\n    };\n    function v(t) {\n        const e = t.split(\".\"), i = [];\n        let s = \"\";\n        for (const t of e)s += t, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (i.push(s), s = \"\");\n        return i;\n    }\n    function M(t, e) {\n        const i = y[e] || (y[e] = function(t) {\n            const e = v(t);\n            return (t)=>{\n                for (const i of e){\n                    if (\"\" === i) break;\n                    t = t && t[i];\n                }\n                return t;\n            };\n        }(e));\n        return i(t);\n    }\n    function w(t) {\n        return t.charAt(0).toUpperCase() + t.slice(1);\n    }\n    const k = (t)=>void 0 !== t, S = (t)=>\"function\" == typeof t, P = (t, e)=>{\n        if (t.size !== e.size) return !1;\n        for (const i of t)if (!e.has(i)) return !1;\n        return !0;\n    };\n    function D(t) {\n        return \"mouseup\" === t.type || \"click\" === t.type || \"contextmenu\" === t.type;\n    }\n    const C = Math.PI, O = 2 * C, A = O + C, T = Number.POSITIVE_INFINITY, L = C / 180, E = C / 2, R = C / 4, I = 2 * C / 3, z = Math.log10, F = Math.sign;\n    function V(t, e, i) {\n        return Math.abs(t - e) < i;\n    }\n    function B(t) {\n        const e = Math.round(t);\n        t = V(t, e, t / 1e3) ? e : t;\n        const i = Math.pow(10, Math.floor(z(t))), s = t / i;\n        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;\n    }\n    function W(t) {\n        const e = [], i = Math.sqrt(t);\n        let s;\n        for(s = 1; s < i; s++)t % s == 0 && (e.push(s), e.push(t / s));\n        return i === (0 | i) && e.push(i), e.sort((t, e)=>t - e).pop(), e;\n    }\n    function N(t) {\n        return !function(t) {\n            return \"symbol\" == typeof t || \"object\" == typeof t && null !== t && !(Symbol.toPrimitive in t || \"toString\" in t || \"valueOf\" in t);\n        }(t) && !isNaN(parseFloat(t)) && isFinite(t);\n    }\n    function H(t, e) {\n        const i = Math.round(t);\n        return i - e <= t && i + e >= t;\n    }\n    function j(t, e, i) {\n        let s, n, o;\n        for(s = 0, n = t.length; s < n; s++)o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));\n    }\n    function $(t) {\n        return t * (C / 180);\n    }\n    function Y(t) {\n        return t * (180 / C);\n    }\n    function U(t) {\n        if (!a(t)) return;\n        let e = 1, i = 0;\n        for(; Math.round(t * e) / e !== t;)e *= 10, i++;\n        return i;\n    }\n    function X(t, e) {\n        const i = e.x - t.x, s = e.y - t.y, n = Math.sqrt(i * i + s * s);\n        let o = Math.atan2(s, i);\n        return o < -0.5 * C && (o += O), {\n            angle: o,\n            distance: n\n        };\n    }\n    function q(t, e) {\n        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }\n    function K(t, e) {\n        return (t - e + A) % O - C;\n    }\n    function G(t) {\n        return (t % O + O) % O;\n    }\n    function Z(t, e, i, s) {\n        const n = G(t), o = G(e), a = G(i), r = G(o - n), l = G(a - n), h = G(n - o), c = G(n - a);\n        return n === o || n === a || s && o === a || r > l && h < c;\n    }\n    function J(t, e, i) {\n        return Math.max(e, Math.min(i, t));\n    }\n    function Q(t) {\n        return J(t, -32768, 32767);\n    }\n    function tt(t, e, i, s = 1e-6) {\n        return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s;\n    }\n    function et(t, e, i) {\n        i = i || ((i)=>t[i] < e);\n        let s, n = t.length - 1, o = 0;\n        for(; n - o > 1;)s = o + n >> 1, i(s) ? o = s : n = s;\n        return {\n            lo: o,\n            hi: n\n        };\n    }\n    const it = (t, e, i, s)=>et(t, i, s ? (s)=>{\n            const n = t[s][e];\n            return n < i || n === i && t[s + 1][e] === i;\n        } : (s)=>t[s][e] < i), st = (t, e, i)=>et(t, i, (s)=>t[s][e] >= i);\n    function nt(t, e, i) {\n        let s = 0, n = t.length;\n        for(; s < n && t[s] < e;)s++;\n        for(; n > s && t[n - 1] > i;)n--;\n        return s > 0 || n < t.length ? t.slice(s, n) : t;\n    }\n    const ot = [\n        \"push\",\n        \"pop\",\n        \"shift\",\n        \"splice\",\n        \"unshift\"\n    ];\n    function at(t, e) {\n        t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, \"_chartjs\", {\n            configurable: !0,\n            enumerable: !1,\n            value: {\n                listeners: [\n                    e\n                ]\n            }\n        }), ot.forEach((e)=>{\n            const i = \"_onData\" + w(e), s = t[e];\n            Object.defineProperty(t, e, {\n                configurable: !0,\n                enumerable: !1,\n                value (...e) {\n                    const n = s.apply(this, e);\n                    return t._chartjs.listeners.forEach((t)=>{\n                        \"function\" == typeof t[i] && t[i](...e);\n                    }), n;\n                }\n            });\n        }));\n    }\n    function rt(t, e) {\n        const i = t._chartjs;\n        if (!i) return;\n        const s = i.listeners, n = s.indexOf(e);\n        -1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e)=>{\n            delete t[e];\n        }), delete t._chartjs);\n    }\n    function lt(t) {\n        const e = new Set(t);\n        return e.size === t.length ? t : Array.from(e);\n    }\n    const ht = \"undefined\" == typeof window ? function(t) {\n        return t();\n    } : window.requestAnimationFrame;\n    function ct(t, e) {\n        let i = [], s = !1;\n        return function(...n) {\n            i = n, s || (s = !0, ht.call(window, ()=>{\n                s = !1, t.apply(e, i);\n            }));\n        };\n    }\n    function dt(t, e) {\n        let i;\n        return function(...s) {\n            return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e;\n        };\n    }\n    const ut = (t)=>\"start\" === t ? \"left\" : \"end\" === t ? \"right\" : \"center\", ft = (t, e, i)=>\"start\" === t ? e : \"end\" === t ? i : (e + i) / 2, gt = (t, e, i, s)=>t === (s ? \"left\" : \"right\") ? i : \"center\" === t ? (e + i) / 2 : e;\n    function pt(t, e, i) {\n        const n = e.length;\n        let o = 0, a = n;\n        if (t._sorted) {\n            const { iScale: r, vScale: l, _parsed: h } = t, c = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null, d = r.axis, { min: u, max: f, minDefined: g, maxDefined: p } = r.getUserBounds();\n            if (g) {\n                if (o = Math.min(it(h, d, u).lo, i ? n : it(e, d, r.getPixelForValue(u)).lo), c) {\n                    const t = h.slice(0, o + 1).reverse().findIndex((t)=>!s(t[l.axis]));\n                    o -= Math.max(0, t);\n                }\n                o = J(o, 0, n - 1);\n            }\n            if (p) {\n                let t = Math.max(it(h, r.axis, f, !0).hi + 1, i ? 0 : it(e, d, r.getPixelForValue(f), !0).hi + 1);\n                if (c) {\n                    const e = h.slice(t - 1).findIndex((t)=>!s(t[l.axis]));\n                    t += Math.max(0, e);\n                }\n                a = J(t, o, n) - o;\n            } else a = n - o;\n        }\n        return {\n            start: o,\n            count: a\n        };\n    }\n    function mt(t) {\n        const { xScale: e, yScale: i, _scaleRanges: s } = t, n = {\n            xmin: e.min,\n            xmax: e.max,\n            ymin: i.min,\n            ymax: i.max\n        };\n        if (!s) return t._scaleRanges = n, !0;\n        const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\n        return Object.assign(s, n), o;\n    }\n    class xt {\n        constructor(){\n            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0;\n        }\n        _notify(t, e, i, s) {\n            const n = e.listeners[s], o = e.duration;\n            n.forEach((s)=>s({\n                    chart: t,\n                    initial: e.initial,\n                    numSteps: o,\n                    currentStep: Math.min(i - e.start, o)\n                }));\n        }\n        _refresh() {\n            this._request || (this._running = !0, this._request = ht.call(window, ()=>{\n                this._update(), this._request = null, this._running && this._refresh();\n            }));\n        }\n        _update(t = Date.now()) {\n            let e = 0;\n            this._charts.forEach((i, s)=>{\n                if (!i.running || !i.items.length) return;\n                const n = i.items;\n                let o, a = n.length - 1, r = !1;\n                for(; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\n                r && (s.draw(), this._notify(s, i, t, \"progress\")), n.length || (i.running = !1, this._notify(s, i, t, \"complete\"), i.initial = !1), e += n.length;\n            }), this._lastDate = t, 0 === e && (this._running = !1);\n        }\n        _getAnims(t) {\n            const e = this._charts;\n            let i = e.get(t);\n            return i || (i = {\n                running: !1,\n                initial: !0,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            }, e.set(t, i)), i;\n        }\n        listen(t, e, i) {\n            this._getAnims(t).listeners[e].push(i);\n        }\n        add(t, e) {\n            e && e.length && this._getAnims(t).items.push(...e);\n        }\n        has(t) {\n            return this._getAnims(t).items.length > 0;\n        }\n        start(t) {\n            const e = this._charts.get(t);\n            e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e)=>Math.max(t, e._duration), 0), this._refresh());\n        }\n        running(t) {\n            if (!this._running) return !1;\n            const e = this._charts.get(t);\n            return !!(e && e.running && e.items.length);\n        }\n        stop(t) {\n            const e = this._charts.get(t);\n            if (!e || !e.items.length) return;\n            const i = e.items;\n            let s = i.length - 1;\n            for(; s >= 0; --s)i[s].cancel();\n            e.items = [], this._notify(t, e, Date.now(), \"complete\");\n        }\n        remove(t) {\n            return this._charts.delete(t);\n        }\n    }\n    var bt = new xt;\n    /*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */ function _t(t) {\n        return t + .5 | 0;\n    }\n    const yt = (t, e, i)=>Math.max(Math.min(t, i), e);\n    function vt(t) {\n        return yt(_t(2.55 * t), 0, 255);\n    }\n    function Mt(t) {\n        return yt(_t(255 * t), 0, 255);\n    }\n    function wt(t) {\n        return yt(_t(t / 2.55) / 100, 0, 1);\n    }\n    function kt(t) {\n        return yt(_t(100 * t), 0, 100);\n    }\n    const St = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, Pt = [\n        ...\"0123456789ABCDEF\"\n    ], Dt = (t)=>Pt[15 & t], Ct = (t)=>Pt[(240 & t) >> 4] + Pt[15 & t], Ot = (t)=>(240 & t) >> 4 == (15 & t);\n    function At(t) {\n        var e = ((t)=>Ot(t.r) && Ot(t.g) && Ot(t.b) && Ot(t.a))(t) ? Dt : Ct;\n        return t ? \"#\" + e(t.r) + e(t.g) + e(t.b) + ((t, e)=>t < 255 ? e(t) : \"\")(t.a, e) : void 0;\n    }\n    const Tt = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function Lt(t, e, i) {\n        const s = e * Math.min(i, 1 - i), n = (e, n = (e + t / 30) % 12)=>i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\n        return [\n            n(0),\n            n(8),\n            n(4)\n        ];\n    }\n    function Et(t, e, i) {\n        const s = (s, n = (s + t / 60) % 6)=>i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\n        return [\n            s(5),\n            s(3),\n            s(1)\n        ];\n    }\n    function Rt(t, e, i) {\n        const s = Lt(t, 1, .5);\n        let n;\n        for(e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++)s[n] *= 1 - e - i, s[n] += e;\n        return s;\n    }\n    function It(t) {\n        const e = t.r / 255, i = t.g / 255, s = t.b / 255, n = Math.max(e, i, s), o = Math.min(e, i, s), a = (n + o) / 2;\n        let r, l, h;\n        return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function(t, e, i, s, n) {\n            return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4;\n        }(e, i, s, h, n), r = 60 * r + .5), [\n            0 | r,\n            l || 0,\n            a\n        ];\n    }\n    function zt(t, e, i, s) {\n        return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt);\n    }\n    function Ft(t, e, i) {\n        return zt(Lt, t, e, i);\n    }\n    function Vt(t) {\n        return (t % 360 + 360) % 360;\n    }\n    function Bt(t) {\n        const e = Tt.exec(t);\n        let i, s = 255;\n        if (!e) return;\n        e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5]));\n        const n = Vt(+e[2]), o = +e[3] / 100, a = +e[4] / 100;\n        return i = \"hwb\" === e[1] ? function(t, e, i) {\n            return zt(Rt, t, e, i);\n        }(n, o, a) : \"hsv\" === e[1] ? function(t, e, i) {\n            return zt(Et, t, e, i);\n        }(n, o, a) : Ft(n, o, a), {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: s\n        };\n    }\n    const Wt = {\n        x: \"dark\",\n        Z: \"light\",\n        Y: \"re\",\n        X: \"blu\",\n        W: \"gr\",\n        V: \"medium\",\n        U: \"slate\",\n        A: \"ee\",\n        T: \"ol\",\n        S: \"or\",\n        B: \"ra\",\n        C: \"lateg\",\n        D: \"ights\",\n        R: \"in\",\n        Q: \"turquois\",\n        E: \"hi\",\n        P: \"ro\",\n        O: \"al\",\n        N: \"le\",\n        M: \"de\",\n        L: \"yello\",\n        F: \"en\",\n        K: \"ch\",\n        G: \"arks\",\n        H: \"ea\",\n        I: \"ightg\",\n        J: \"wh\"\n    }, Nt = {\n        OiceXe: \"f0f8ff\",\n        antiquewEte: \"faebd7\",\n        aqua: \"ffff\",\n        aquamarRe: \"7fffd4\",\n        azuY: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"0\",\n        blanKedOmond: \"ffebcd\",\n        Xe: \"ff\",\n        XeviTet: \"8a2be2\",\n        bPwn: \"a52a2a\",\n        burlywood: \"deb887\",\n        caMtXe: \"5f9ea0\",\n        KartYuse: \"7fff00\",\n        KocTate: \"d2691e\",\n        cSO: \"ff7f50\",\n        cSnflowerXe: \"6495ed\",\n        cSnsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"ffff\",\n        xXe: \"8b\",\n        xcyan: \"8b8b\",\n        xgTMnPd: \"b8860b\",\n        xWay: \"a9a9a9\",\n        xgYF: \"6400\",\n        xgYy: \"a9a9a9\",\n        xkhaki: \"bdb76b\",\n        xmagFta: \"8b008b\",\n        xTivegYF: \"556b2f\",\n        xSange: \"ff8c00\",\n        xScEd: \"9932cc\",\n        xYd: \"8b0000\",\n        xsOmon: \"e9967a\",\n        xsHgYF: \"8fbc8f\",\n        xUXe: \"483d8b\",\n        xUWay: \"2f4f4f\",\n        xUgYy: \"2f4f4f\",\n        xQe: \"ced1\",\n        xviTet: \"9400d3\",\n        dAppRk: \"ff1493\",\n        dApskyXe: \"bfff\",\n        dimWay: \"696969\",\n        dimgYy: \"696969\",\n        dodgerXe: \"1e90ff\",\n        fiYbrick: \"b22222\",\n        flSOwEte: \"fffaf0\",\n        foYstWAn: \"228b22\",\n        fuKsia: \"ff00ff\",\n        gaRsbSo: \"dcdcdc\",\n        ghostwEte: \"f8f8ff\",\n        gTd: \"ffd700\",\n        gTMnPd: \"daa520\",\n        Way: \"808080\",\n        gYF: \"8000\",\n        gYFLw: \"adff2f\",\n        gYy: \"808080\",\n        honeyMw: \"f0fff0\",\n        hotpRk: \"ff69b4\",\n        RdianYd: \"cd5c5c\",\n        Rdigo: \"4b0082\",\n        ivSy: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavFMr: \"e6e6fa\",\n        lavFMrXsh: \"fff0f5\",\n        lawngYF: \"7cfc00\",\n        NmoncEffon: \"fffacd\",\n        ZXe: \"add8e6\",\n        ZcSO: \"f08080\",\n        Zcyan: \"e0ffff\",\n        ZgTMnPdLw: \"fafad2\",\n        ZWay: \"d3d3d3\",\n        ZgYF: \"90ee90\",\n        ZgYy: \"d3d3d3\",\n        ZpRk: \"ffb6c1\",\n        ZsOmon: \"ffa07a\",\n        ZsHgYF: \"20b2aa\",\n        ZskyXe: \"87cefa\",\n        ZUWay: \"778899\",\n        ZUgYy: \"778899\",\n        ZstAlXe: \"b0c4de\",\n        ZLw: \"ffffe0\",\n        lime: \"ff00\",\n        limegYF: \"32cd32\",\n        lRF: \"faf0e6\",\n        magFta: \"ff00ff\",\n        maPon: \"800000\",\n        VaquamarRe: \"66cdaa\",\n        VXe: \"cd\",\n        VScEd: \"ba55d3\",\n        VpurpN: \"9370db\",\n        VsHgYF: \"3cb371\",\n        VUXe: \"7b68ee\",\n        VsprRggYF: \"fa9a\",\n        VQe: \"48d1cc\",\n        VviTetYd: \"c71585\",\n        midnightXe: \"191970\",\n        mRtcYam: \"f5fffa\",\n        mistyPse: \"ffe4e1\",\n        moccasR: \"ffe4b5\",\n        navajowEte: \"ffdead\",\n        navy: \"80\",\n        Tdlace: \"fdf5e6\",\n        Tive: \"808000\",\n        TivedBb: \"6b8e23\",\n        Sange: \"ffa500\",\n        SangeYd: \"ff4500\",\n        ScEd: \"da70d6\",\n        pOegTMnPd: \"eee8aa\",\n        pOegYF: \"98fb98\",\n        pOeQe: \"afeeee\",\n        pOeviTetYd: \"db7093\",\n        papayawEp: \"ffefd5\",\n        pHKpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pRk: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powMrXe: \"b0e0e6\",\n        purpN: \"800080\",\n        YbeccapurpN: \"663399\",\n        Yd: \"ff0000\",\n        Psybrown: \"bc8f8f\",\n        PyOXe: \"4169e1\",\n        saddNbPwn: \"8b4513\",\n        sOmon: \"fa8072\",\n        sandybPwn: \"f4a460\",\n        sHgYF: \"2e8b57\",\n        sHshell: \"fff5ee\",\n        siFna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyXe: \"87ceeb\",\n        UXe: \"6a5acd\",\n        UWay: \"708090\",\n        UgYy: \"708090\",\n        snow: \"fffafa\",\n        sprRggYF: \"ff7f\",\n        stAlXe: \"4682b4\",\n        tan: \"d2b48c\",\n        teO: \"8080\",\n        tEstN: \"d8bfd8\",\n        tomato: \"ff6347\",\n        Qe: \"40e0d0\",\n        viTet: \"ee82ee\",\n        JHt: \"f5deb3\",\n        wEte: \"ffffff\",\n        wEtesmoke: \"f5f5f5\",\n        Lw: \"ffff00\",\n        LwgYF: \"9acd32\"\n    };\n    let Ht;\n    function jt(t) {\n        Ht || (Ht = function() {\n            const t = {}, e = Object.keys(Nt), i = Object.keys(Wt);\n            let s, n, o, a, r;\n            for(s = 0; s < e.length; s++){\n                for(a = r = e[s], n = 0; n < i.length; n++)o = i[n], r = r.replace(o, Wt[o]);\n                o = parseInt(Nt[a], 16), t[r] = [\n                    o >> 16 & 255,\n                    o >> 8 & 255,\n                    255 & o\n                ];\n            }\n            return t;\n        }(), Ht.transparent = [\n            0,\n            0,\n            0,\n            0\n        ]);\n        const e = Ht[t.toLowerCase()];\n        return e && {\n            r: e[0],\n            g: e[1],\n            b: e[2],\n            a: 4 === e.length ? e[3] : 255\n        };\n    }\n    const $t = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    const Yt = (t)=>t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, Ut = (t)=>t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    function Xt(t, e, i) {\n        if (t) {\n            let s = It(t);\n            s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2];\n        }\n    }\n    function qt(t, e) {\n        return t ? Object.assign(e || {}, t) : t;\n    }\n    function Kt(t) {\n        var e = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 255\n        };\n        return Array.isArray(t) ? t.length >= 3 && (e = {\n            r: t[0],\n            g: t[1],\n            b: t[2],\n            a: 255\n        }, t.length > 3 && (e.a = Mt(t[3]))) : (e = qt(t, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        })).a = Mt(e.a), e;\n    }\n    function Gt(t) {\n        return \"r\" === t.charAt(0) ? function(t) {\n            const e = $t.exec(t);\n            let i, s, n, o = 255;\n            if (e) {\n                if (e[7] !== i) {\n                    const t = +e[7];\n                    o = e[8] ? vt(t) : yt(255 * t, 0, 255);\n                }\n                return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 & (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 & (e[6] ? vt(n) : yt(n, 0, 255)), {\n                    r: i,\n                    g: s,\n                    b: n,\n                    a: o\n                };\n            }\n        }(t) : Bt(t);\n    }\n    class Zt {\n        constructor(t){\n            if (t instanceof Zt) return t;\n            const e = typeof t;\n            let i;\n            var s, n, o;\n            \"object\" === e ? i = Kt(t) : \"string\" === e && (o = (s = t).length, \"#\" === s[0] && (4 === o || 5 === o ? n = {\n                r: 255 & 17 * St[s[1]],\n                g: 255 & 17 * St[s[2]],\n                b: 255 & 17 * St[s[3]],\n                a: 5 === o ? 17 * St[s[4]] : 255\n            } : 7 !== o && 9 !== o || (n = {\n                r: St[s[1]] << 4 | St[s[2]],\n                g: St[s[3]] << 4 | St[s[4]],\n                b: St[s[5]] << 4 | St[s[6]],\n                a: 9 === o ? St[s[7]] << 4 | St[s[8]] : 255\n            })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i;\n        }\n        get valid() {\n            return this._valid;\n        }\n        get rgb() {\n            var t = qt(this._rgb);\n            return t && (t.a = wt(t.a)), t;\n        }\n        set rgb(t) {\n            this._rgb = Kt(t);\n        }\n        rgbString() {\n            var t;\n            return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;\n        }\n        hexString() {\n            return this._valid ? At(this._rgb) : void 0;\n        }\n        hslString() {\n            return this._valid ? function(t) {\n                if (!t) return;\n                const e = It(t), i = e[0], s = kt(e[1]), n = kt(e[2]);\n                return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`;\n            }(this._rgb) : void 0;\n        }\n        mix(t, e) {\n            if (t) {\n                const i = this.rgb, s = t.rgb;\n                let n;\n                const o = e === n ? .5 : e, a = 2 * o - 1, r = i.a - s.a, l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;\n                n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;\n            }\n            return this;\n        }\n        interpolate(t, e) {\n            return t && (this._rgb = function(t, e, i) {\n                const s = Ut(wt(t.r)), n = Ut(wt(t.g)), o = Ut(wt(t.b));\n                return {\n                    r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),\n                    g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),\n                    b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),\n                    a: t.a + i * (e.a - t.a)\n                };\n            }(this._rgb, t._rgb, e)), this;\n        }\n        clone() {\n            return new Zt(this.rgb);\n        }\n        alpha(t) {\n            return this._rgb.a = Mt(t), this;\n        }\n        clearer(t) {\n            return this._rgb.a *= 1 - t, this;\n        }\n        greyscale() {\n            const t = this._rgb, e = _t(.3 * t.r + .59 * t.g + .11 * t.b);\n            return t.r = t.g = t.b = e, this;\n        }\n        opaquer(t) {\n            return this._rgb.a *= 1 + t, this;\n        }\n        negate() {\n            const t = this._rgb;\n            return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n        }\n        lighten(t) {\n            return Xt(this._rgb, 2, t), this;\n        }\n        darken(t) {\n            return Xt(this._rgb, 2, -t), this;\n        }\n        saturate(t) {\n            return Xt(this._rgb, 1, t), this;\n        }\n        desaturate(t) {\n            return Xt(this._rgb, 1, -t), this;\n        }\n        rotate(t) {\n            return function(t, e) {\n                var i = It(t);\n                i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2];\n            }(this._rgb, t), this;\n        }\n    }\n    function Jt(t) {\n        if (t && \"object\" == typeof t) {\n            const e = t.toString();\n            return \"[object CanvasPattern]\" === e || \"[object CanvasGradient]\" === e;\n        }\n        return !1;\n    }\n    function Qt(t) {\n        return Jt(t) ? t : new Zt(t);\n    }\n    function te(t) {\n        return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString();\n    }\n    const ee = [\n        \"x\",\n        \"y\",\n        \"borderWidth\",\n        \"radius\",\n        \"tension\"\n    ], ie = [\n        \"color\",\n        \"borderColor\",\n        \"backgroundColor\"\n    ];\n    const se = new Map;\n    function ne(t, e, i) {\n        return (function(t, e) {\n            e = e || {};\n            const i = t + JSON.stringify(e);\n            let s = se.get(i);\n            return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s;\n        })(e, i).format(t);\n    }\n    const oe = {\n        values: (t)=>n(t) ? t : \"\" + t,\n        numeric (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = this.chart.options.locale;\n            let n, o = t;\n            if (i.length > 1) {\n                const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\n                (e < 1e-4 || e > 1e15) && (n = \"scientific\"), o = function(t, e) {\n                    let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\n                    Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));\n                    return i;\n                }(t, i);\n            }\n            const a = z(Math.abs(o)), r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {\n                notation: n,\n                minimumFractionDigits: r,\n                maximumFractionDigits: r\n            };\n            return Object.assign(l, this.options.ticks.format), ne(t, s, l);\n        },\n        logarithmic (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = i[e].significand || t / Math.pow(10, Math.floor(z(t)));\n            return [\n                1,\n                2,\n                3,\n                5,\n                10,\n                15\n            ].includes(s) || e > .8 * i.length ? oe.numeric.call(this, t, e, i) : \"\";\n        }\n    };\n    var ae = {\n        formatters: oe\n    };\n    const re = Object.create(null), le = Object.create(null);\n    function he(t, e) {\n        if (!e) return t;\n        const i = e.split(\".\");\n        for(let e = 0, s = i.length; e < s; ++e){\n            const s = i[e];\n            t = t[s] || (t[s] = Object.create(null));\n        }\n        return t;\n    }\n    function ce(t, e, i) {\n        return \"string\" == typeof e ? x(he(t, e), i) : x(he(t, \"\"), e);\n    }\n    class de {\n        constructor(t, e){\n            this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (t)=>t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n                \"mousemove\",\n                \"mouseout\",\n                \"click\",\n                \"touchstart\",\n                \"touchmove\"\n            ], this.font = {\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                size: 12,\n                style: \"normal\",\n                lineHeight: 1.2,\n                weight: null\n            }, this.hover = {}, this.hoverBackgroundColor = (t, e)=>te(e.backgroundColor), this.hoverBorderColor = (t, e)=>te(e.borderColor), this.hoverColor = (t, e)=>te(e.color), this.indexAxis = \"x\", this.interaction = {\n                mode: \"nearest\",\n                intersect: !0,\n                includeInvisible: !1\n            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n        }\n        set(t, e) {\n            return ce(this, t, e);\n        }\n        get(t) {\n            return he(this, t);\n        }\n        describe(t, e) {\n            return ce(le, t, e);\n        }\n        override(t, e) {\n            return ce(re, t, e);\n        }\n        route(t, e, i, s) {\n            const n = he(this, t), a = he(this, i), r = \"_\" + e;\n            Object.defineProperties(n, {\n                [r]: {\n                    value: n[e],\n                    writable: !0\n                },\n                [e]: {\n                    enumerable: !0,\n                    get () {\n                        const t = this[r], e = a[s];\n                        return o(t) ? Object.assign({}, e, t) : l(t, e);\n                    },\n                    set (t) {\n                        this[r] = t;\n                    }\n                }\n            });\n        }\n        apply(t) {\n            t.forEach((t)=>t(this));\n        }\n    }\n    var ue = new de({\n        _scriptable: (t)=>!t.startsWith(\"on\"),\n        _indexable: (t)=>\"events\" !== t,\n        hover: {\n            _fallback: \"interaction\"\n        },\n        interaction: {\n            _scriptable: !1,\n            _indexable: !1\n        }\n    }, [\n        function(t) {\n            t.set(\"animation\", {\n                delay: void 0,\n                duration: 1e3,\n                easing: \"easeOutQuart\",\n                fn: void 0,\n                from: void 0,\n                loop: void 0,\n                to: void 0,\n                type: void 0\n            }), t.describe(\"animation\", {\n                _fallback: !1,\n                _indexable: !1,\n                _scriptable: (t)=>\"onProgress\" !== t && \"onComplete\" !== t && \"fn\" !== t\n            }), t.set(\"animations\", {\n                colors: {\n                    type: \"color\",\n                    properties: ie\n                },\n                numbers: {\n                    type: \"number\",\n                    properties: ee\n                }\n            }), t.describe(\"animations\", {\n                _fallback: \"animation\"\n            }), t.set(\"transitions\", {\n                active: {\n                    animation: {\n                        duration: 400\n                    }\n                },\n                resize: {\n                    animation: {\n                        duration: 0\n                    }\n                },\n                show: {\n                    animations: {\n                        colors: {\n                            from: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            duration: 0\n                        }\n                    }\n                },\n                hide: {\n                    animations: {\n                        colors: {\n                            to: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            easing: \"linear\",\n                            fn: (t)=>0 | t\n                        }\n                    }\n                }\n            });\n        },\n        function(t) {\n            t.set(\"layout\", {\n                autoPadding: !0,\n                padding: {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                }\n            });\n        },\n        function(t) {\n            t.set(\"scale\", {\n                display: !0,\n                offset: !1,\n                reverse: !1,\n                beginAtZero: !1,\n                bounds: \"ticks\",\n                clip: !0,\n                grace: 0,\n                grid: {\n                    display: !0,\n                    lineWidth: 1,\n                    drawOnChartArea: !0,\n                    drawTicks: !0,\n                    tickLength: 8,\n                    tickWidth: (t, e)=>e.lineWidth,\n                    tickColor: (t, e)=>e.color,\n                    offset: !1\n                },\n                border: {\n                    display: !0,\n                    dash: [],\n                    dashOffset: 0,\n                    width: 1\n                },\n                title: {\n                    display: !1,\n                    text: \"\",\n                    padding: {\n                        top: 4,\n                        bottom: 4\n                    }\n                },\n                ticks: {\n                    minRotation: 0,\n                    maxRotation: 50,\n                    mirror: !1,\n                    textStrokeWidth: 0,\n                    textStrokeColor: \"\",\n                    padding: 3,\n                    display: !0,\n                    autoSkip: !0,\n                    autoSkipPadding: 3,\n                    labelOffset: 0,\n                    callback: ae.formatters.values,\n                    minor: {},\n                    major: {},\n                    align: \"center\",\n                    crossAlign: \"near\",\n                    showLabelBackdrop: !1,\n                    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n                    backdropPadding: 2\n                }\n            }), t.route(\"scale.ticks\", \"color\", \"\", \"color\"), t.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), t.route(\"scale.border\", \"color\", \"\", \"borderColor\"), t.route(\"scale.title\", \"color\", \"\", \"color\"), t.describe(\"scale\", {\n                _fallback: !1,\n                _scriptable: (t)=>!t.startsWith(\"before\") && !t.startsWith(\"after\") && \"callback\" !== t && \"parser\" !== t,\n                _indexable: (t)=>\"borderDash\" !== t && \"tickBorderDash\" !== t && \"dash\" !== t\n            }), t.describe(\"scales\", {\n                _fallback: \"scale\"\n            }), t.describe(\"scale.ticks\", {\n                _scriptable: (t)=>\"backdropPadding\" !== t && \"callback\" !== t,\n                _indexable: (t)=>\"backdropPadding\" !== t\n            });\n        }\n    ]);\n    function fe() {\n        return \"undefined\" != typeof window && \"undefined\" != typeof document;\n    }\n    function ge(t) {\n        let e = t.parentNode;\n        return e && \"[object ShadowRoot]\" === e.toString() && (e = e.host), e;\n    }\n    function pe(t, e, i) {\n        let s;\n        return \"string\" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(\"%\") && (s = s / 100 * e.parentNode[i])) : s = t, s;\n    }\n    const me = (t)=>t.ownerDocument.defaultView.getComputedStyle(t, null);\n    function xe(t, e) {\n        return me(t).getPropertyValue(e);\n    }\n    const be = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    function _e(t, e, i) {\n        const s = {};\n        i = i ? \"-\" + i : \"\";\n        for(let n = 0; n < 4; n++){\n            const o = be[n];\n            s[o] = parseFloat(t[e + \"-\" + o + i]) || 0;\n        }\n        return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n    }\n    const ye = (t, e, i)=>(t > 0 || e > 0) && (!i || !i.shadowRoot);\n    function ve(t, e) {\n        if (\"native\" in t) return t;\n        const { canvas: i, currentDevicePixelRatio: s } = e, n = me(i), o = \"border-box\" === n.boxSizing, a = _e(n, \"padding\"), r = _e(n, \"border\", \"width\"), { x: l, y: h, box: c } = function(t, e) {\n            const i = t.touches, s = i && i.length ? i[0] : t, { offsetX: n, offsetY: o } = s;\n            let a, r, l = !1;\n            if (ye(n, o, t.target)) a = n, r = o;\n            else {\n                const t = e.getBoundingClientRect();\n                a = s.clientX - t.left, r = s.clientY - t.top, l = !0;\n            }\n            return {\n                x: a,\n                y: r,\n                box: l\n            };\n        }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);\n        let { width: f, height: g } = e;\n        return o && (f -= a.width + r.width, g -= a.height + r.height), {\n            x: Math.round((l - d) / f * i.width / s),\n            y: Math.round((h - u) / g * i.height / s)\n        };\n    }\n    const Me = (t)=>Math.round(10 * t) / 10;\n    function we(t, e, i, s) {\n        const n = me(t), o = _e(n, \"margin\"), a = pe(n.maxWidth, t, \"clientWidth\") || T, r = pe(n.maxHeight, t, \"clientHeight\") || T, l = function(t, e, i) {\n            let s, n;\n            if (void 0 === e || void 0 === i) {\n                const o = t && ge(t);\n                if (o) {\n                    const t = o.getBoundingClientRect(), a = me(o), r = _e(a, \"border\", \"width\"), l = _e(a, \"padding\");\n                    e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, \"clientWidth\"), n = pe(a.maxHeight, o, \"clientHeight\");\n                } else e = t.clientWidth, i = t.clientHeight;\n            }\n            return {\n                width: e,\n                height: i,\n                maxWidth: s || T,\n                maxHeight: n || T\n            };\n        }(t, e, i);\n        let { width: h, height: c } = l;\n        if (\"content-box\" === n.boxSizing) {\n            const t = _e(n, \"border\", \"width\"), e = _e(n, \"padding\");\n            h -= e.width + t.width, c -= e.height + t.height;\n        }\n        h = Math.max(0, h - o.width), c = Math.max(0, s ? h / s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h && !c && (c = Me(h / 2));\n        return (void 0 !== e || void 0 !== i) && s && l.height && c > l.height && (c = l.height, h = Me(Math.floor(c * s))), {\n            width: h,\n            height: c\n        };\n    }\n    function ke(t, e, i) {\n        const s = e || 1, n = Math.floor(t.height * s), o = Math.floor(t.width * s);\n        t.height = Math.floor(t.height), t.width = Math.floor(t.width);\n        const a = t.canvas;\n        return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0);\n    }\n    const Se = function() {\n        let t = !1;\n        try {\n            const e = {\n                get passive () {\n                    return t = !0, !1;\n                }\n            };\n            fe() && (window.addEventListener(\"test\", null, e), window.removeEventListener(\"test\", null, e));\n        } catch (t) {}\n        return t;\n    }();\n    function Pe(t, e) {\n        const i = xe(t, e), s = i && i.match(/^(\\d+)(\\.\\d+)?px$/);\n        return s ? +s[1] : void 0;\n    }\n    function De(t) {\n        return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + \" \" : \"\") + (t.weight ? t.weight + \" \" : \"\") + t.size + \"px \" + t.family;\n    }\n    function Ce(t, e, i, s, n) {\n        let o = e[n];\n        return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s;\n    }\n    function Oe(t, e, i, s) {\n        let o = (s = s || {}).data = s.data || {}, a = s.garbageCollect = s.garbageCollect || [];\n        s.font !== e && (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;\n        let r = 0;\n        const l = i.length;\n        let h, c, d, u, f;\n        for(h = 0; h < l; h++)if (u = i[h], null == u || n(u)) {\n            if (n(u)) for(c = 0, d = u.length; c < d; c++)f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f));\n        } else r = Ce(t, o, a, r, u);\n        t.restore();\n        const g = a.length / 2;\n        if (g > i.length) {\n            for(h = 0; h < g; h++)delete o[a[h]];\n            a.splice(0, g);\n        }\n        return r;\n    }\n    function Ae(t, e, i) {\n        const s = t.currentDevicePixelRatio, n = 0 !== i ? Math.max(i / 2, .5) : 0;\n        return Math.round((e - n) * s) / s + n;\n    }\n    function Te(t, e) {\n        (e || t) && ((e = e || t.getContext(\"2d\")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());\n    }\n    function Le(t, e, i, s) {\n        Ee(t, e, i, s, null);\n    }\n    function Ee(t, e, i, s, n) {\n        let o, a, r, l, h, c, d, u;\n        const f = e.pointStyle, g = e.rotation, p = e.radius;\n        let m = (g || 0) * L;\n        if (f && \"object\" == typeof f && (o = f.toString(), \"[object HTMLImageElement]\" === o || \"[object HTMLCanvasElement]\" === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();\n        if (!(isNaN(p) || p <= 0)) {\n            switch(t.beginPath(), f){\n                default:\n                    n ? t.ellipse(i, s, n / 2, p, 0, 0, O) : t.arc(i, s, p, 0, O), t.closePath();\n                    break;\n                case \"triangle\":\n                    c = n ? n / 2 : p, t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), t.closePath();\n                    break;\n                case \"rectRounded\":\n                    h = .516 * p, l = p - h, a = Math.cos(m + R) * l, d = Math.cos(m + R) * (n ? n / 2 - h : l), r = Math.sin(m + R) * l, u = Math.sin(m + R) * (n ? n / 2 - h : l), t.arc(i - d, s - r, h, m - C, m - E), t.arc(i + u, s - a, h, m - E, m), t.arc(i + d, s + r, h, m, m + E), t.arc(i - u, s + a, h, m + E, m + C), t.closePath();\n                    break;\n                case \"rect\":\n                    if (!g) {\n                        l = Math.SQRT1_2 * p, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\n                        break;\n                    }\n                    m += R;\n                case \"rectRot\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + u, s - a), t.lineTo(i + d, s + r), t.lineTo(i - u, s + a), t.closePath();\n                    break;\n                case \"crossRot\":\n                    m += R;\n                case \"cross\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"star\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a), m += R, d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"line\":\n                    a = n ? n / 2 : Math.cos(m) * p, r = Math.sin(m) * p, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\n                    break;\n                case \"dash\":\n                    t.moveTo(i, s), t.lineTo(i + Math.cos(m) * (n ? n / 2 : p), s + Math.sin(m) * p);\n                    break;\n                case !1:\n                    t.closePath();\n            }\n            t.fill(), e.borderWidth > 0 && t.stroke();\n        }\n    }\n    function Re(t, e, i) {\n        return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;\n    }\n    function Ie(t, e) {\n        t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();\n    }\n    function ze(t) {\n        t.restore();\n    }\n    function Fe(t, e, i, s, n) {\n        if (!e) return t.lineTo(i.x, i.y);\n        if (\"middle\" === n) {\n            const s = (e.x + i.x) / 2;\n            t.lineTo(s, e.y), t.lineTo(s, i.y);\n        } else \"after\" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\n        t.lineTo(i.x, i.y);\n    }\n    function Ve(t, e, i, s) {\n        if (!e) return t.lineTo(i.x, i.y);\n        t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);\n    }\n    function Be(t, e, i, s, n) {\n        if (n.strikethrough || n.underline) {\n            const o = t.measureText(s), a = e - o.actualBoundingBoxLeft, r = e + o.actualBoundingBoxRight, l = i - o.actualBoundingBoxAscent, h = i + o.actualBoundingBoxDescent, c = n.strikethrough ? (l + h) / 2 : h;\n            t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke();\n        }\n    }\n    function We(t, e) {\n        const i = t.fillStyle;\n        t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;\n    }\n    function Ne(t, e, i, o, a, r = {}) {\n        const l = n(e) ? e : [\n            e\n        ], h = r.strokeWidth > 0 && \"\" !== r.strokeColor;\n        let c, d;\n        for(t.save(), t.font = a.string, function(t, e) {\n            e.translation && t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);\n        }(t, r), c = 0; c < l.length; ++c)d = l[c], r.backdrop && We(t, r.backdrop), h && (r.strokeColor && (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);\n        t.restore();\n    }\n    function He(t, e) {\n        const { x: i, y: s, w: n, h: o, radius: a } = e;\n        t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * C, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s);\n    }\n    function je(t, e = [\n        \"\"\n    ], i, s, n = ()=>t[0]) {\n        const o = i || t;\n        void 0 === s && (s = ti(\"_fallback\", t));\n        const a = {\n            [Symbol.toStringTag]: \"Object\",\n            _cacheable: !0,\n            _scopes: t,\n            _rootScopes: o,\n            _fallback: s,\n            _getTarget: n,\n            override: (i)=>je([\n                    i,\n                    ...t\n                ], e, o, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete e._keys, delete t[0][i], !0),\n            get: (i, s)=>qe(i, s, ()=>(function(t, e, i, s) {\n                        let n;\n                        for (const o of e)if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n;\n                    })(s, e, t, i)),\n            getOwnPropertyDescriptor: (t, e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t[0]),\n            has: (t, e)=>ei(t).includes(e),\n            ownKeys: (t)=>ei(t),\n            set (t, e, i) {\n                const s = t._storage || (t._storage = n());\n                return t[e] = s[e] = i, delete t._keys, !0;\n            }\n        });\n    }\n    function $e(t, e, i, s) {\n        const a = {\n            _cacheable: !1,\n            _proxy: t,\n            _context: e,\n            _subProxy: i,\n            _stack: new Set,\n            _descriptors: Ye(t, s),\n            setContext: (e)=>$e(t, e, i, s),\n            override: (n)=>$e(t.override(n), e, i, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete t[i], !0),\n            get: (t, e, i)=>qe(t, e, ()=>(function(t, e, i) {\n                        const { _proxy: s, _context: a, _subProxy: r, _descriptors: l } = t;\n                        let h = s[e];\n                        S(h) && l.isScriptable(e) && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: o, _subProxy: a, _stack: r } = i;\n                            if (r.has(t)) throw new Error(\"Recursion detected: \" + Array.from(r).join(\"->\") + \"->\" + t);\n                            r.add(t);\n                            let l = e(o, a || s);\n                            r.delete(t), Xe(t, l) && (l = Je(n._scopes, n, t, l));\n                            return l;\n                        }(e, h, t, i));\n                        n(h) && h.length && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: a, _subProxy: r, _descriptors: l } = i;\n                            if (void 0 !== a.index && s(t)) return e[a.index % e.length];\n                            if (o(e[0])) {\n                                const i = e, s = n._scopes.filter((t)=>t !== i);\n                                e = [];\n                                for (const o of i){\n                                    const i = Je(s, n, t, o);\n                                    e.push($e(i, a, r && r[t], l));\n                                }\n                            }\n                            return e;\n                        }(e, h, t, l.isIndexable));\n                        Xe(e, h) && (h = $e(h, a, r && r[e], l));\n                        return h;\n                    })(t, e, i)),\n            getOwnPropertyDescriptor: (e, i)=>e._descriptors.allKeys ? Reflect.has(t, i) ? {\n                    enumerable: !0,\n                    configurable: !0\n                } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t),\n            has: (e, i)=>Reflect.has(t, i),\n            ownKeys: ()=>Reflect.ownKeys(t),\n            set: (e, i, s)=>(t[i] = s, delete e[i], !0)\n        });\n    }\n    function Ye(t, e = {\n        scriptable: !0,\n        indexable: !0\n    }) {\n        const { _scriptable: i = e.scriptable, _indexable: s = e.indexable, _allKeys: n = e.allKeys } = t;\n        return {\n            allKeys: n,\n            scriptable: i,\n            indexable: s,\n            isScriptable: S(i) ? i : ()=>i,\n            isIndexable: S(s) ? s : ()=>s\n        };\n    }\n    const Ue = (t, e)=>t ? t + w(e) : e, Xe = (t, e)=>o(e) && \"adapters\" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);\n    function qe(t, e, i) {\n        if (Object.prototype.hasOwnProperty.call(t, e) || \"constructor\" === e) return t[e];\n        const s = i();\n        return t[e] = s, s;\n    }\n    function Ke(t, e, i) {\n        return S(t) ? t(e, i) : t;\n    }\n    const Ge = (t, e)=>!0 === t ? e : \"string\" == typeof t ? M(e, t) : void 0;\n    function Ze(t, e, i, s, n) {\n        for (const o of e){\n            const e = Ge(i, o);\n            if (e) {\n                t.add(e);\n                const o = Ke(e._fallback, i, n);\n                if (void 0 !== o && o !== i && o !== s) return o;\n            } else if (!1 === e && void 0 !== s && i !== s) return null;\n        }\n        return !1;\n    }\n    function Je(t, e, i, s) {\n        const a = e._rootScopes, r = Ke(e._fallback, i, s), l = [\n            ...t,\n            ...a\n        ], h = new Set;\n        h.add(s);\n        let c = Qe(h, l, i, r || i, s);\n        return null !== c && (void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) && je(Array.from(h), [\n            \"\"\n        ], a, r, ()=>(function(t, e, i) {\n                const s = t._getTarget();\n                e in s || (s[e] = {});\n                const a = s[e];\n                if (n(a) && o(i)) return i;\n                return a || {};\n            })(e, i, s));\n    }\n    function Qe(t, e, i, s, n) {\n        for(; i;)i = Ze(t, e, i, s, n);\n        return i;\n    }\n    function ti(t, e) {\n        for (const i of e){\n            if (!i) continue;\n            const e = i[t];\n            if (void 0 !== e) return e;\n        }\n    }\n    function ei(t) {\n        let e = t._keys;\n        return e || (e = t._keys = function(t) {\n            const e = new Set;\n            for (const i of t)for (const t of Object.keys(i).filter((t)=>!t.startsWith(\"_\")))e.add(t);\n            return Array.from(e);\n        }(t._scopes)), e;\n    }\n    function ii(t, e, i, s) {\n        const { iScale: n } = t, { key: o = \"r\" } = this._parsing, a = new Array(s);\n        let r, l, h, c;\n        for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n            r: n.parse(M(c, o), h)\n        };\n        return a;\n    }\n    const si = Number.EPSILON || 1e-14, ni = (t, e)=>e < t.length && !t[e].skip && t[e], oi = (t)=>\"x\" === t ? \"y\" : \"x\";\n    function ai(t, e, i, s) {\n        const n = t.skip ? e : t, o = e, a = i.skip ? e : i, r = q(o, n), l = q(a, o);\n        let h = r / (r + l), c = l / (r + l);\n        h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\n        const d = s * h, u = s * c;\n        return {\n            previous: {\n                x: o.x - d * (a.x - n.x),\n                y: o.y - d * (a.y - n.y)\n            },\n            next: {\n                x: o.x + u * (a.x - n.x),\n                y: o.y + u * (a.y - n.y)\n            }\n        };\n    }\n    function ri(t, e = \"x\") {\n        const i = oi(e), s = t.length, n = Array(s).fill(0), o = Array(s);\n        let a, r, l, h = ni(t, 0);\n        for(a = 0; a < s; ++a)if (r = l, l = h, h = ni(t, a + 1), l) {\n            if (h) {\n                const t = h[e] - l[e];\n                n[a] = 0 !== t ? (h[i] - l[i]) / t : 0;\n            }\n            o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a];\n        }\n        !function(t, e, i) {\n            const s = t.length;\n            let n, o, a, r, l, h = ni(t, 0);\n            for(let c = 0; c < s - 1; ++c)l = h, h = ni(t, c + 1), l && h && (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])));\n        }(t, n, o), function(t, e, i = \"x\") {\n            const s = oi(i), n = t.length;\n            let o, a, r, l = ni(t, 0);\n            for(let h = 0; h < n; ++h){\n                if (a = r, r = l, l = ni(t, h + 1), !r) continue;\n                const n = r[i], c = r[s];\n                a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h]);\n            }\n        }(t, o, e);\n    }\n    function li(t, e, i) {\n        return Math.max(Math.min(t, i), e);\n    }\n    function hi(t, e, i, s, n) {\n        let o, a, r, l;\n        if (e.spanGaps && (t = t.filter((t)=>!t.skip)), \"monotone\" === e.cubicInterpolationMode) ri(t, n);\n        else {\n            let i = s ? t[t.length - 1] : t[0];\n            for(o = 0, a = t.length; o < a; ++o)r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r;\n        }\n        e.capBezierPoints && function(t, e) {\n            let i, s, n, o, a, r = Re(t[0], e);\n            for(i = 0, s = t.length; i < s; ++i)a = o, o = r, r = i < s - 1 && Re(t[i + 1], e), o && (n = t[i], a && (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r && (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)));\n        }(t, i);\n    }\n    const ci = (t)=>0 === t || 1 === t, di = (t, e, i)=>-Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i), ui = (t, e, i)=>Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1, fi = {\n        linear: (t)=>t,\n        easeInQuad: (t)=>t * t,\n        easeOutQuad: (t)=>-t * (t - 2),\n        easeInOutQuad: (t)=>(t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1),\n        easeInCubic: (t)=>t * t * t,\n        easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n        easeInOutCubic: (t)=>(t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\n        easeInQuart: (t)=>t * t * t * t,\n        easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n        easeInOutQuart: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n        easeInQuint: (t)=>t * t * t * t * t,\n        easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n        easeInOutQuint: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\n        easeInSine: (t)=>1 - Math.cos(t * E),\n        easeOutSine: (t)=>Math.sin(t * E),\n        easeInOutSine: (t)=>-0.5 * (Math.cos(C * t) - 1),\n        easeInExpo: (t)=>0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\n        easeOutExpo: (t)=>1 === t ? 1 : 1 - Math.pow(2, -10 * t),\n        easeInOutExpo: (t)=>ci(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\n        easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n        easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n        easeInOutCirc: (t)=>(t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n        easeInElastic: (t)=>ci(t) ? t : di(t, .075, .3),\n        easeOutElastic: (t)=>ci(t) ? t : ui(t, .075, .3),\n        easeInOutElastic (t) {\n            const e = .1125;\n            return ci(t) ? t : t < .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45);\n        },\n        easeInBack (t) {\n            const e = 1.70158;\n            return t * t * ((e + 1) * t - e);\n        },\n        easeOutBack (t) {\n            const e = 1.70158;\n            return (t -= 1) * t * ((e + 1) * t + e) + 1;\n        },\n        easeInOutBack (t) {\n            let e = 1.70158;\n            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);\n        },\n        easeInBounce: (t)=>1 - fi.easeOutBounce(1 - t),\n        easeOutBounce (t) {\n            const e = 7.5625, i = 2.75;\n            return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375;\n        },\n        easeInOutBounce: (t)=>t < .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5\n    };\n    function gi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: t.y + i * (e.y - t.y)\n        };\n    }\n    function pi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: \"middle\" === s ? i < .5 ? t.y : e.y : \"after\" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y\n        };\n    }\n    function mi(t, e, i, s) {\n        const n = {\n            x: t.cp2x,\n            y: t.cp2y\n        }, o = {\n            x: e.cp1x,\n            y: e.cp1y\n        }, a = gi(t, n, i), r = gi(n, o, i), l = gi(o, e, i), h = gi(a, r, i), c = gi(r, l, i);\n        return gi(h, c, i);\n    }\n    const xi = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/, bi = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n    function _i(t, e) {\n        const i = (\"\" + t).match(xi);\n        if (!i || \"normal\" === i[1]) return 1.2 * e;\n        switch(t = +i[2], i[3]){\n            case \"px\":\n                return t;\n            case \"%\":\n                t /= 100;\n        }\n        return e * t;\n    }\n    const yi = (t)=>+t || 0;\n    function vi(t, e) {\n        const i = {}, s = o(e), n = s ? Object.keys(e) : e, a = o(t) ? s ? (i)=>l(t[i], t[e[i]]) : (e)=>t[e] : ()=>t;\n        for (const t of n)i[t] = yi(a(t));\n        return i;\n    }\n    function Mi(t) {\n        return vi(t, {\n            top: \"y\",\n            right: \"x\",\n            bottom: \"y\",\n            left: \"x\"\n        });\n    }\n    function wi(t) {\n        return vi(t, [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]);\n    }\n    function ki(t) {\n        const e = Mi(t);\n        return e.width = e.left + e.right, e.height = e.top + e.bottom, e;\n    }\n    function Si(t, e) {\n        t = t || {}, e = e || ue.font;\n        let i = l(t.size, e.size);\n        \"string\" == typeof i && (i = parseInt(i, 10));\n        let s = l(t.style, e.style);\n        s && !(\"\" + s).match(bi) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n        const n = {\n            family: l(t.family, e.family),\n            lineHeight: _i(l(t.lineHeight, e.lineHeight), i),\n            size: i,\n            style: s,\n            weight: l(t.weight, e.weight),\n            string: \"\"\n        };\n        return n.string = De(n), n;\n    }\n    function Pi(t, e, i, s) {\n        let o, a, r, l = !0;\n        for(o = 0, a = t.length; o < a; ++o)if (r = t[o], void 0 !== r && (void 0 !== e && \"function\" == typeof r && (r = r(e), l = !1), void 0 !== i && n(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return s && !l && (s.cacheable = !1), r;\n    }\n    function Di(t, e, i) {\n        const { min: s, max: n } = t, o = c(e, (n - s) / 2), a = (t, e)=>i && 0 === t ? 0 : t + e;\n        return {\n            min: a(s, -Math.abs(o)),\n            max: a(n, o)\n        };\n    }\n    function Ci(t, e) {\n        return Object.assign(Object.create(t), e);\n    }\n    function Oi(t, e, i) {\n        return t ? function(t, e) {\n            return {\n                x: (i)=>t + t + e - i,\n                setWidth (t) {\n                    e = t;\n                },\n                textAlign: (t)=>\"center\" === t ? t : \"right\" === t ? \"left\" : \"right\",\n                xPlus: (t, e)=>t - e,\n                leftForLtr: (t, e)=>t - e\n            };\n        }(e, i) : {\n            x: (t)=>t,\n            setWidth (t) {},\n            textAlign: (t)=>t,\n            xPlus: (t, e)=>t + e,\n            leftForLtr: (t, e)=>t\n        };\n    }\n    function Ai(t, e) {\n        let i, s;\n        \"ltr\" !== e && \"rtl\" !== e || (i = t.canvas.style, s = [\n            i.getPropertyValue(\"direction\"),\n            i.getPropertyPriority(\"direction\")\n        ], i.setProperty(\"direction\", e, \"important\"), t.prevTextDirection = s);\n    }\n    function Ti(t, e) {\n        void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty(\"direction\", e[0], e[1]));\n    }\n    function Li(t) {\n        return \"angle\" === t ? {\n            between: Z,\n            compare: K,\n            normalize: G\n        } : {\n            between: tt,\n            compare: (t, e)=>t - e,\n            normalize: (t)=>t\n        };\n    }\n    function Ei({ start: t, end: e, count: i, loop: s, style: n }) {\n        return {\n            start: t % i,\n            end: e % i,\n            loop: s && (e - t + 1) % i == 0,\n            style: n\n        };\n    }\n    function Ri(t, e, i) {\n        if (!i) return [\n            t\n        ];\n        const { property: s, start: n, end: o } = i, a = e.length, { compare: r, between: l, normalize: h } = Li(s), { start: c, end: d, loop: u, style: f } = function(t, e, i) {\n            const { property: s, start: n, end: o } = i, { between: a, normalize: r } = Li(s), l = e.length;\n            let h, c, { start: d, end: u, loop: f } = t;\n            if (f) {\n                for(d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h)d--, u--;\n                d %= l, u %= l;\n            }\n            return u < d && (u += l), {\n                start: d,\n                end: u,\n                loop: f,\n                style: t.style\n            };\n        }(t, e, i), g = [];\n        let p, m, x, b = !1, _ = null;\n        const y = ()=>b || l(n, x, p) && 0 !== r(n, x), v = ()=>!b || 0 === r(o, p) || l(o, x, p);\n        for(let t = c, i = c; t <= d; ++t)m = e[t % a], m.skip || (p = h(m[s]), p !== x && (b = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(Ei({\n            start: _,\n            end: t,\n            loop: u,\n            count: a,\n            style: f\n        })), _ = null), i = t, x = p));\n        return null !== _ && g.push(Ei({\n            start: _,\n            end: d,\n            loop: u,\n            count: a,\n            style: f\n        })), g;\n    }\n    function Ii(t, e) {\n        const i = [], s = t.segments;\n        for(let n = 0; n < s.length; n++){\n            const o = Ri(s[n], t.points, e);\n            o.length && i.push(...o);\n        }\n        return i;\n    }\n    function zi(t, e) {\n        const i = t.points, s = t.options.spanGaps, n = i.length;\n        if (!n) return [];\n        const o = !!t._loop, { start: a, end: r } = function(t, e, i, s) {\n            let n = 0, o = e - 1;\n            if (i && !s) for(; n < e && !t[n].skip;)n++;\n            for(; n < e && t[n].skip;)n++;\n            for(n %= e, i && (o += n); o > n && t[o % e].skip;)o--;\n            return o %= e, {\n                start: n,\n                end: o\n            };\n        }(i, n, o, s);\n        if (!0 === s) return Fi(t, [\n            {\n                start: a,\n                end: r,\n                loop: o\n            }\n        ], i, e);\n        return Fi(t, function(t, e, i, s) {\n            const n = t.length, o = [];\n            let a, r = e, l = t[e];\n            for(a = e + 1; a <= i; ++a){\n                const i = t[a % n];\n                i.skip || i.stop ? l.skip || (s = !1, o.push({\n                    start: e % n,\n                    end: (a - 1) % n,\n                    loop: s\n                }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i;\n            }\n            return null !== r && o.push({\n                start: e % n,\n                end: r % n,\n                loop: s\n            }), o;\n        }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e);\n    }\n    function Fi(t, e, i, s) {\n        return s && s.setContext && i ? function(t, e, i, s) {\n            const n = t._chart.getContext(), o = Vi(t.options), { _datasetIndex: a, options: { spanGaps: r } } = t, l = i.length, h = [];\n            let c = o, d = e[0].start, u = d;\n            function f(t, e, s, n) {\n                const o = r ? -1 : 1;\n                if (t !== e) {\n                    for(t += l; i[t % l].skip;)t -= o;\n                    for(; i[e % l].skip;)e += o;\n                    t % l != e % l && (h.push({\n                        start: t % l,\n                        end: e % l,\n                        loop: s,\n                        style: n\n                    }), c = n, d = e % l);\n                }\n            }\n            for (const t of e){\n                d = r ? d : t.start;\n                let e, o = i[d % l];\n                for(u = d + 1; u <= t.end; u++){\n                    const r = i[u % l];\n                    e = Vi(s.setContext(Ci(n, {\n                        type: \"segment\",\n                        p0: o,\n                        p1: r,\n                        p0DataIndex: (u - 1) % l,\n                        p1DataIndex: u % l,\n                        datasetIndex: a\n                    }))), Bi(e, c) && f(d, u - 1, t.loop, c), o = r, c = e;\n                }\n                d < u - 1 && f(d, u - 1, t.loop, c);\n            }\n            return h;\n        }(t, e, i, s) : e;\n    }\n    function Vi(t) {\n        return {\n            backgroundColor: t.backgroundColor,\n            borderCapStyle: t.borderCapStyle,\n            borderDash: t.borderDash,\n            borderDashOffset: t.borderDashOffset,\n            borderJoinStyle: t.borderJoinStyle,\n            borderWidth: t.borderWidth,\n            borderColor: t.borderColor\n        };\n    }\n    function Bi(t, e) {\n        if (!e) return !1;\n        const i = [], s = function(t, e) {\n            return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e;\n        };\n        return JSON.stringify(t, s) !== JSON.stringify(e, s);\n    }\n    var Wi = Object.freeze({\n        __proto__: null,\n        HALF_PI: E,\n        INFINITY: T,\n        PI: C,\n        PITAU: A,\n        QUARTER_PI: R,\n        RAD_PER_DEG: L,\n        TAU: O,\n        TWO_THIRDS_PI: I,\n        _addGrace: Di,\n        _alignPixel: Ae,\n        _alignStartEnd: ft,\n        _angleBetween: Z,\n        _angleDiff: K,\n        _arrayUnique: lt,\n        _attachContext: $e,\n        _bezierCurveTo: Ve,\n        _bezierInterpolation: mi,\n        _boundSegment: Ri,\n        _boundSegments: Ii,\n        _capitalize: w,\n        _computeSegments: zi,\n        _createResolver: je,\n        _decimalPlaces: U,\n        _deprecated: function(t, e, i, s) {\n            void 0 !== e && console.warn(t + ': \"' + i + '\" is deprecated. Please use \"' + s + '\" instead');\n        },\n        _descriptors: Ye,\n        _elementsEqual: f,\n        _factorize: W,\n        _filterBetween: nt,\n        _getParentNode: ge,\n        _getStartAndCountOfVisiblePoints: pt,\n        _int16Range: Q,\n        _isBetween: tt,\n        _isClickEvent: D,\n        _isDomSupported: fe,\n        _isPointInArea: Re,\n        _limitValue: J,\n        _longestText: Oe,\n        _lookup: et,\n        _lookupByKey: it,\n        _measureText: Ce,\n        _merger: m,\n        _mergerIf: _,\n        _normalizeAngle: G,\n        _parseObjectDataRadialScale: ii,\n        _pointInLine: gi,\n        _readValueToProps: vi,\n        _rlookupByKey: st,\n        _scaleRangesChanged: mt,\n        _setMinAndMaxByKey: j,\n        _splitKey: v,\n        _steppedInterpolation: pi,\n        _steppedLineTo: Fe,\n        _textX: gt,\n        _toLeftRightCenter: ut,\n        _updateBezierControlPoints: hi,\n        addRoundedRectPath: He,\n        almostEquals: V,\n        almostWhole: H,\n        callback: d,\n        clearCanvas: Te,\n        clipArea: Ie,\n        clone: g,\n        color: Qt,\n        createContext: Ci,\n        debounce: dt,\n        defined: k,\n        distanceBetweenPoints: q,\n        drawPoint: Le,\n        drawPointLegend: Ee,\n        each: u,\n        easingEffects: fi,\n        finiteOrDefault: r,\n        fontString: function(t, e, i) {\n            return e + \" \" + t + \"px \" + i;\n        },\n        formatNumber: ne,\n        getAngleFromPoint: X,\n        getHoverColor: te,\n        getMaximumSize: we,\n        getRelativePosition: ve,\n        getRtlAdapter: Oi,\n        getStyle: xe,\n        isArray: n,\n        isFinite: a,\n        isFunction: S,\n        isNullOrUndef: s,\n        isNumber: N,\n        isObject: o,\n        isPatternOrGradient: Jt,\n        listenArrayEvents: at,\n        log10: z,\n        merge: x,\n        mergeIf: b,\n        niceNum: B,\n        noop: e,\n        overrideTextDirection: Ai,\n        readUsedSize: Pe,\n        renderText: Ne,\n        requestAnimFrame: ht,\n        resolve: Pi,\n        resolveObjectKey: M,\n        restoreTextDirection: Ti,\n        retinaScale: ke,\n        setsEqual: P,\n        sign: F,\n        splineCurve: ai,\n        splineCurveMonotone: ri,\n        supportsEventListenerOptions: Se,\n        throttled: ct,\n        toDegrees: Y,\n        toDimension: c,\n        toFont: Si,\n        toFontString: De,\n        toLineHeight: _i,\n        toPadding: ki,\n        toPercentage: h,\n        toRadians: $,\n        toTRBL: Mi,\n        toTRBLCorners: wi,\n        uid: i,\n        unclipArea: ze,\n        unlistenArrayEvents: rt,\n        valueOrDefault: l\n    });\n    function Ni(t, e, i, n) {\n        const { controller: o, data: a, _sorted: r } = t, l = o._cachedMeta.iScale, h = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null;\n        if (l && e === l.axis && \"r\" !== e && r && a.length) {\n            const r = l._reversePixels ? st : it;\n            if (!n) {\n                const n = r(a, e, i);\n                if (h) {\n                    const { vScale: e } = o._cachedMeta, { _parsed: i } = t, a = i.slice(0, n.lo + 1).reverse().findIndex((t)=>!s(t[e.axis]));\n                    n.lo -= Math.max(0, a);\n                    const r = i.slice(n.hi).findIndex((t)=>!s(t[e.axis]));\n                    n.hi += Math.max(0, r);\n                }\n                return n;\n            }\n            if (o._sharedOptions) {\n                const t = a[0], s = \"function\" == typeof t.getRange && t.getRange(e);\n                if (s) {\n                    const t = r(a, e, i - s), n = r(a, e, i + s);\n                    return {\n                        lo: t.lo,\n                        hi: n.hi\n                    };\n                }\n            }\n        }\n        return {\n            lo: 0,\n            hi: a.length - 1\n        };\n    }\n    function Hi(t, e, i, s, n) {\n        const o = t.getSortedVisibleDatasetMetas(), a = i[e];\n        for(let t = 0, i = o.length; t < i; ++t){\n            const { index: i, data: r } = o[t], { lo: l, hi: h } = Ni(o[t], e, a, n);\n            for(let t = l; t <= h; ++t){\n                const e = r[t];\n                e.skip || s(e, i, t);\n            }\n        }\n    }\n    function ji(t, e, i, s, n) {\n        const o = [];\n        if (!n && !t.isPointInArea(e)) return o;\n        return Hi(t, i, e, function(i, a, r) {\n            (n || Re(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({\n                element: i,\n                datasetIndex: a,\n                index: r\n            });\n        }, !0), o;\n    }\n    function $i(t, e, i, s, n, o) {\n        let a = [];\n        const r = function(t) {\n            const e = -1 !== t.indexOf(\"x\"), i = -1 !== t.indexOf(\"y\");\n            return function(t, s) {\n                const n = e ? Math.abs(t.x - s.x) : 0, o = i ? Math.abs(t.y - s.y) : 0;\n                return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n            };\n        }(i);\n        let l = Number.POSITIVE_INFINITY;\n        return Hi(t, i, e, function(i, h, c) {\n            const d = i.inRange(e.x, e.y, n);\n            if (s && !d) return;\n            const u = i.getCenterPoint(n);\n            if (!(!!o || t.isPointInArea(u)) && !d) return;\n            const f = r(e, u);\n            f < l ? (a = [\n                {\n                    element: i,\n                    datasetIndex: h,\n                    index: c\n                }\n            ], l = f) : f === l && a.push({\n                element: i,\n                datasetIndex: h,\n                index: c\n            });\n        }), a;\n    }\n    function Yi(t, e, i, s, n, o) {\n        return o || t.isPointInArea(e) ? \"r\" !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {\n            let n = [];\n            return Hi(t, i, e, function(t, i, o) {\n                const { startAngle: a, endAngle: r } = t.getProps([\n                    \"startAngle\",\n                    \"endAngle\"\n                ], s), { angle: l } = X(t, {\n                    x: e.x,\n                    y: e.y\n                });\n                Z(l, a, r) && n.push({\n                    element: t,\n                    datasetIndex: i,\n                    index: o\n                });\n            }), n;\n        }(t, e, i, n) : [];\n    }\n    function Ui(t, e, i, s, n) {\n        const o = [], a = \"x\" === i ? \"inXRange\" : \"inYRange\";\n        let r = !1;\n        return Hi(t, i, e, (t, s, l)=>{\n            t[a] && t[a](e[i], n) && (o.push({\n                element: t,\n                datasetIndex: s,\n                index: l\n            }), r = r || t.inRange(e.x, e.y, n));\n        }), s && !r ? [] : o;\n    }\n    var Xi = {\n        evaluateInteractionItems: Hi,\n        modes: {\n            index (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"x\", a = i.includeInvisible || !1, r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a), l = [];\n                return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t)=>{\n                    const e = r[0].index, i = t.data[e];\n                    i && !i.skip && l.push({\n                        element: i,\n                        datasetIndex: t.index,\n                        index: e\n                    });\n                }), l) : [];\n            },\n            dataset (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);\n                if (r.length > 0) {\n                    const e = r[0].datasetIndex, i = t.getDatasetMeta(e).data;\n                    r = [];\n                    for(let t = 0; t < i.length; ++t)r.push({\n                        element: i[t],\n                        datasetIndex: e,\n                        index: t\n                    });\n                }\n                return r;\n            },\n            point: (t, e, i, s)=>ji(t, ve(e, t), i.axis || \"xy\", s, i.includeInvisible || !1),\n            nearest (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                return Yi(t, n, o, i.intersect, s, a);\n            },\n            x: (t, e, i, s)=>Ui(t, ve(e, t), \"x\", i.intersect, s),\n            y: (t, e, i, s)=>Ui(t, ve(e, t), \"y\", i.intersect, s)\n        }\n    };\n    const qi = [\n        \"left\",\n        \"top\",\n        \"right\",\n        \"bottom\"\n    ];\n    function Ki(t, e) {\n        return t.filter((t)=>t.pos === e);\n    }\n    function Gi(t, e) {\n        return t.filter((t)=>-1 === qi.indexOf(t.pos) && t.box.axis === e);\n    }\n    function Zi(t, e) {\n        return t.sort((t, i)=>{\n            const s = e ? i : t, n = e ? t : i;\n            return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;\n        });\n    }\n    function Ji(t, e) {\n        const i = function(t) {\n            const e = {};\n            for (const i of t){\n                const { stack: t, pos: s, stackWeight: n } = i;\n                if (!t || !qi.includes(s)) continue;\n                const o = e[t] || (e[t] = {\n                    count: 0,\n                    placed: 0,\n                    weight: 0,\n                    size: 0\n                });\n                o.count++, o.weight += n;\n            }\n            return e;\n        }(t), { vBoxMaxWidth: s, hBoxMaxHeight: n } = e;\n        let o, a, r;\n        for(o = 0, a = t.length; o < a; ++o){\n            r = t[o];\n            const { fullSize: a } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;\n            r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight);\n        }\n        return i;\n    }\n    function Qi(t, e, i, s) {\n        return Math.max(t[i], e[i]) + Math.max(t[s], e[s]);\n    }\n    function ts(t, e) {\n        t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);\n    }\n    function es(t, e, i, s) {\n        const { pos: n, box: a } = i, r = t.maxPadding;\n        if (!o(n)) {\n            i.size && (t[n] -= i.size);\n            const e = s[i.stack] || {\n                size: 0,\n                count: 1\n            };\n            e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[n] += i.size;\n        }\n        a.getPadding && ts(r, a.getPadding());\n        const l = Math.max(0, e.outerWidth - Qi(r, t, \"left\", \"right\")), h = Math.max(0, e.outerHeight - Qi(r, t, \"top\", \"bottom\")), c = l !== t.w, d = h !== t.h;\n        return t.w = l, t.h = h, i.horizontal ? {\n            same: c,\n            other: d\n        } : {\n            same: d,\n            other: c\n        };\n    }\n    function is(t, e) {\n        const i = e.maxPadding;\n        function s(t) {\n            const s = {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            };\n            return t.forEach((t)=>{\n                s[t] = Math.max(e[t], i[t]);\n            }), s;\n        }\n        return s(t ? [\n            \"left\",\n            \"right\"\n        ] : [\n            \"top\",\n            \"bottom\"\n        ]);\n    }\n    function ss(t, e, i, s) {\n        const n = [];\n        let o, a, r, l, h, c;\n        for(o = 0, a = t.length, h = 0; o < a; ++o){\n            r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));\n            const { same: a, other: d } = es(e, i, r, s);\n            h |= a && n.length, c = c || d, l.fullSize || n.push(r);\n        }\n        return h && ss(n, e, i, s) || c;\n    }\n    function ns(t, e, i, s, n) {\n        t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n;\n    }\n    function os(t, e, i, s) {\n        const n = i.padding;\n        let { x: o, y: a } = e;\n        for (const r of t){\n            const t = r.box, l = s[r.stack] || {\n                count: 1,\n                placed: 0,\n                weight: 1\n            }, h = r.stackWeight / l.weight || 1;\n            if (r.horizontal) {\n                const s = e.w * h, o = l.size || t.height;\n                k(l.start) && (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom;\n            } else {\n                const s = e.h * h, a = l.size || t.width;\n                k(l.start) && (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right;\n            }\n        }\n        e.x = o, e.y = a;\n    }\n    var as = {\n        addBox (t, e) {\n            t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || \"top\", e.weight = e.weight || 0, e._layers = e._layers || function() {\n                return [\n                    {\n                        z: 0,\n                        draw (t) {\n                            e.draw(t);\n                        }\n                    }\n                ];\n            }, t.boxes.push(e);\n        },\n        removeBox (t, e) {\n            const i = t.boxes ? t.boxes.indexOf(e) : -1;\n            -1 !== i && t.boxes.splice(i, 1);\n        },\n        configure (t, e, i) {\n            e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;\n        },\n        update (t, e, i, s) {\n            if (!t) return;\n            const n = ki(t.options.layout.padding), o = Math.max(e - n.width, 0), a = Math.max(i - n.height, 0), r = function(t) {\n                const e = function(t) {\n                    const e = [];\n                    let i, s, n, o, a, r;\n                    for(i = 0, s = (t || []).length; i < s; ++i)n = t[i], ({ position: o, options: { stack: a, stackWeight: r = 1 } } = n), e.push({\n                        index: i,\n                        box: n,\n                        pos: o,\n                        horizontal: n.isHorizontal(),\n                        weight: n.weight,\n                        stack: a && o + a,\n                        stackWeight: r\n                    });\n                    return e;\n                }(t), i = Zi(e.filter((t)=>t.box.fullSize), !0), s = Zi(Ki(e, \"left\"), !0), n = Zi(Ki(e, \"right\")), o = Zi(Ki(e, \"top\"), !0), a = Zi(Ki(e, \"bottom\")), r = Gi(e, \"x\"), l = Gi(e, \"y\");\n                return {\n                    fullSize: i,\n                    leftAndTop: s.concat(o),\n                    rightAndBottom: n.concat(l).concat(a).concat(r),\n                    chartArea: Ki(e, \"chartArea\"),\n                    vertical: s.concat(n).concat(l),\n                    horizontal: o.concat(a).concat(r)\n                };\n            }(t.boxes), l = r.vertical, h = r.horizontal;\n            u(t.boxes, (t)=>{\n                \"function\" == typeof t.beforeLayout && t.beforeLayout();\n            });\n            const c = l.reduce((t, e)=>e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1, d = Object.freeze({\n                outerWidth: e,\n                outerHeight: i,\n                padding: n,\n                availableWidth: o,\n                availableHeight: a,\n                vBoxMaxWidth: o / 2 / c,\n                hBoxMaxHeight: a / 2\n            }), f = Object.assign({}, n);\n            ts(f, ki(s));\n            const g = Object.assign({\n                maxPadding: f,\n                w: o,\n                h: a,\n                x: n.left,\n                y: n.top\n            }, n), p = Ji(l.concat(h), d);\n            ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) && ss(l, g, d, p), function(t) {\n                const e = t.maxPadding;\n                function i(i) {\n                    const s = Math.max(e[i] - t[i], 0);\n                    return t[i] += s, s;\n                }\n                t.y += i(\"top\"), t.x += i(\"left\"), i(\"right\"), i(\"bottom\");\n            }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {\n                left: g.left,\n                top: g.top,\n                right: g.left + g.w,\n                bottom: g.top + g.h,\n                height: g.h,\n                width: g.w\n            }, u(r.chartArea, (e)=>{\n                const i = e.box;\n                Object.assign(i, t.chartArea), i.update(g.w, g.h, {\n                    left: 0,\n                    top: 0,\n                    right: 0,\n                    bottom: 0\n                });\n            });\n        }\n    };\n    class rs {\n        acquireContext(t, e) {}\n        releaseContext(t) {\n            return !1;\n        }\n        addEventListener(t, e, i) {}\n        removeEventListener(t, e, i) {}\n        getDevicePixelRatio() {\n            return 1;\n        }\n        getMaximumSize(t, e, i, s) {\n            return e = Math.max(0, e || t.width), i = i || t.height, {\n                width: e,\n                height: Math.max(0, s ? Math.floor(e / s) : i)\n            };\n        }\n        isAttached(t) {\n            return !0;\n        }\n        updateConfig(t) {}\n    }\n    class ls extends rs {\n        acquireContext(t) {\n            return t && t.getContext && t.getContext(\"2d\") || null;\n        }\n        updateConfig(t) {\n            t.options.animation = !1;\n        }\n    }\n    const hs = \"$chartjs\", cs = {\n        touchstart: \"mousedown\",\n        touchmove: \"mousemove\",\n        touchend: \"mouseup\",\n        pointerenter: \"mouseenter\",\n        pointerdown: \"mousedown\",\n        pointermove: \"mousemove\",\n        pointerup: \"mouseup\",\n        pointerleave: \"mouseout\",\n        pointerout: \"mouseout\"\n    }, ds = (t)=>null === t || \"\" === t;\n    const us = !!Se && {\n        passive: !0\n    };\n    function fs(t, e, i) {\n        t && t.canvas && t.canvas.removeEventListener(e, i, us);\n    }\n    function gs(t, e) {\n        for (const i of t)if (i === e || i.contains(e)) return !0;\n    }\n    function ps(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.addedNodes, s), e = e && !gs(i.removedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    function ms(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.removedNodes, s), e = e && !gs(i.addedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    const xs = new Map;\n    let bs = 0;\n    function _s() {\n        const t = window.devicePixelRatio;\n        t !== bs && (bs = t, xs.forEach((e, i)=>{\n            i.currentDevicePixelRatio !== t && e();\n        }));\n    }\n    function ys(t, e, i) {\n        const s = t.canvas, n = s && ge(s);\n        if (!n) return;\n        const o = ct((t, e)=>{\n            const s = n.clientWidth;\n            i(t, e), s < n.clientWidth && i();\n        }, window), a = new ResizeObserver((t)=>{\n            const e = t[0], i = e.contentRect.width, s = e.contentRect.height;\n            0 === i && 0 === s || o(i, s);\n        });\n        return a.observe(n), function(t, e) {\n            xs.size || window.addEventListener(\"resize\", _s), xs.set(t, e);\n        }(t, o), a;\n    }\n    function vs(t, e, i) {\n        i && i.disconnect(), \"resize\" === e && function(t) {\n            xs.delete(t), xs.size || window.removeEventListener(\"resize\", _s);\n        }(t);\n    }\n    function Ms(t, e, i) {\n        const s = t.canvas, n = ct((e)=>{\n            null !== t.ctx && i(function(t, e) {\n                const i = cs[t.type] || t.type, { x: s, y: n } = ve(t, e);\n                return {\n                    type: i,\n                    chart: e,\n                    native: t,\n                    x: void 0 !== s ? s : null,\n                    y: void 0 !== n ? n : null\n                };\n            }(e, t));\n        }, t);\n        return function(t, e, i) {\n            t && t.addEventListener(e, i, us);\n        }(s, e, n), n;\n    }\n    class ws extends rs {\n        acquireContext(t, e) {\n            const i = t && t.getContext && t.getContext(\"2d\");\n            return i && i.canvas === t ? (function(t, e) {\n                const i = t.style, s = t.getAttribute(\"height\"), n = t.getAttribute(\"width\");\n                if (t[hs] = {\n                    initial: {\n                        height: s,\n                        width: n,\n                        style: {\n                            display: i.display,\n                            height: i.height,\n                            width: i.width\n                        }\n                    }\n                }, i.display = i.display || \"block\", i.boxSizing = i.boxSizing || \"border-box\", ds(n)) {\n                    const e = Pe(t, \"width\");\n                    void 0 !== e && (t.width = e);\n                }\n                if (ds(s)) {\n                    if (\"\" === t.style.height) t.height = t.width / (e || 2);\n                    else {\n                        const e = Pe(t, \"height\");\n                        void 0 !== e && (t.height = e);\n                    }\n                }\n            }(t, e), i) : null;\n        }\n        releaseContext(t) {\n            const e = t.canvas;\n            if (!e[hs]) return !1;\n            const i = e[hs].initial;\n            [\n                \"height\",\n                \"width\"\n            ].forEach((t)=>{\n                const n = i[t];\n                s(n) ? e.removeAttribute(t) : e.setAttribute(t, n);\n            });\n            const n = i.style || {};\n            return Object.keys(n).forEach((t)=>{\n                e.style[t] = n[t];\n            }), e.width = e.width, delete e[hs], !0;\n        }\n        addEventListener(t, e, i) {\n            this.removeEventListener(t, e);\n            const s = t.$proxies || (t.$proxies = {}), n = {\n                attach: ps,\n                detach: ms,\n                resize: ys\n            }[e] || Ms;\n            s[e] = n(t, e, i);\n        }\n        removeEventListener(t, e) {\n            const i = t.$proxies || (t.$proxies = {}), s = i[e];\n            if (!s) return;\n            (({\n                attach: vs,\n                detach: vs,\n                resize: vs\n            })[e] || fs)(t, e, s), i[e] = void 0;\n        }\n        getDevicePixelRatio() {\n            return window.devicePixelRatio;\n        }\n        getMaximumSize(t, e, i, s) {\n            return we(t, e, i, s);\n        }\n        isAttached(t) {\n            const e = t && ge(t);\n            return !(!e || !e.isConnected);\n        }\n    }\n    function ks(t) {\n        return !fe() || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? ls : ws;\n    }\n    var Ss = Object.freeze({\n        __proto__: null,\n        BasePlatform: rs,\n        BasicPlatform: ls,\n        DomPlatform: ws,\n        _detectPlatform: ks\n    });\n    const Ps = \"transparent\", Ds = {\n        boolean: (t, e, i)=>i > .5 ? e : t,\n        color (t, e, i) {\n            const s = Qt(t || Ps), n = s.valid && Qt(e || Ps);\n            return n && n.valid ? n.mix(s, i).hexString() : e;\n        },\n        number: (t, e, i)=>t + (e - t) * i\n    };\n    class Cs {\n        constructor(t, e, i, s){\n            const n = e[i];\n            s = Pi([\n                t.to,\n                s,\n                n,\n                t.from\n            ]);\n            const o = Pi([\n                t.from,\n                n,\n                s\n            ]);\n            this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;\n        }\n        active() {\n            return this._active;\n        }\n        update(t, e, i) {\n            if (this._active) {\n                this._notify(!1);\n                const s = this._target[this._prop], n = i - this._start, o = this._duration - n;\n                this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([\n                    t.to,\n                    e,\n                    s,\n                    t.from\n                ]), this._from = Pi([\n                    t.from,\n                    s,\n                    e\n                ]);\n            }\n        }\n        cancel() {\n            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n        }\n        tick(t) {\n            const e = t - this._start, i = this._duration, s = this._prop, n = this._from, o = this._loop, a = this._to;\n            let r;\n            if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);\n            e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r));\n        }\n        wait() {\n            const t = this._promises || (this._promises = []);\n            return new Promise((e, i)=>{\n                t.push({\n                    res: e,\n                    rej: i\n                });\n            });\n        }\n        _notify(t) {\n            const e = t ? \"res\" : \"rej\", i = this._promises || [];\n            for(let t = 0; t < i.length; t++)i[t][e]();\n        }\n    }\n    class Os {\n        constructor(t, e){\n            this._chart = t, this._properties = new Map, this.configure(e);\n        }\n        configure(t) {\n            if (!o(t)) return;\n            const e = Object.keys(ue.animation), i = this._properties;\n            Object.getOwnPropertyNames(t).forEach((s)=>{\n                const a = t[s];\n                if (!o(a)) return;\n                const r = {};\n                for (const t of e)r[t] = a[t];\n                (n(a.properties) && a.properties || [\n                    s\n                ]).forEach((t)=>{\n                    t !== s && i.has(t) || i.set(t, r);\n                });\n            });\n        }\n        _animateOptions(t, e) {\n            const i = e.options, s = function(t, e) {\n                if (!e) return;\n                let i = t.options;\n                if (!i) return void (t.options = e);\n                i.$shared && (t.options = i = Object.assign({}, i, {\n                    $shared: !1,\n                    $animations: {}\n                }));\n                return i;\n            }(t, i);\n            if (!s) return [];\n            const n = this._createAnimations(s, i);\n            return i.$shared && (function(t, e) {\n                const i = [], s = Object.keys(e);\n                for(let e = 0; e < s.length; e++){\n                    const n = t[s[e]];\n                    n && n.active() && i.push(n.wait());\n                }\n                return Promise.all(i);\n            })(t.options.$animations, i).then(()=>{\n                t.options = i;\n            }, ()=>{}), n;\n        }\n        _createAnimations(t, e) {\n            const i = this._properties, s = [], n = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now();\n            let r;\n            for(r = o.length - 1; r >= 0; --r){\n                const l = o[r];\n                if (\"$\" === l.charAt(0)) continue;\n                if (\"options\" === l) {\n                    s.push(...this._animateOptions(t, e));\n                    continue;\n                }\n                const h = e[l];\n                let c = n[l];\n                const d = i.get(l);\n                if (c) {\n                    if (d && c.active()) {\n                        c.update(d, h, a);\n                        continue;\n                    }\n                    c.cancel();\n                }\n                d && d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h;\n            }\n            return s;\n        }\n        update(t, e) {\n            if (0 === this._properties.size) return void Object.assign(t, e);\n            const i = this._createAnimations(t, e);\n            return i.length ? (bt.add(this._chart, i), !0) : void 0;\n        }\n    }\n    function As(t, e) {\n        const i = t && t.options || {}, s = i.reverse, n = void 0 === i.min ? e : 0, o = void 0 === i.max ? e : 0;\n        return {\n            start: s ? o : n,\n            end: s ? n : o\n        };\n    }\n    function Ts(t, e) {\n        const i = [], s = t._getSortedDatasetMetas(e);\n        let n, o;\n        for(n = 0, o = s.length; n < o; ++n)i.push(s[n].index);\n        return i;\n    }\n    function Ls(t, e, i, s = {}) {\n        const n = t.keys, o = \"single\" === s.mode;\n        let r, l, h, c;\n        if (null === e) return;\n        let d = !1;\n        for(r = 0, l = n.length; r < l; ++r){\n            if (h = +n[r], h === i) {\n                if (d = !0, s.all) continue;\n                break;\n            }\n            c = t.values[h], a(c) && (o || 0 === e || F(e) === F(c)) && (e += c);\n        }\n        return d || s.all ? e : 0;\n    }\n    function Es(t, e) {\n        const i = t && t.options.stacked;\n        return i || void 0 === i && void 0 !== e.stack;\n    }\n    function Rs(t, e, i) {\n        const s = t[e] || (t[e] = {});\n        return s[i] || (s[i] = {});\n    }\n    function Is(t, e, i, s) {\n        for (const n of e.getMatchingVisibleMetas(s).reverse()){\n            const e = t[n.index];\n            if (i && e > 0 || !i && e < 0) return n.index;\n        }\n        return null;\n    }\n    function zs(t, e) {\n        const { chart: i, _cachedMeta: s } = t, n = i._stacks || (i._stacks = {}), { iScale: o, vScale: a, index: r } = s, l = o.axis, h = a.axis, c = function(t, e, i) {\n            return `${t.id}.${e.id}.${i.stack || i.type}`;\n        }(o, a, s), d = e.length;\n        let u;\n        for(let t = 0; t < d; ++t){\n            const i = e[t], { [l]: o, [h]: d } = i;\n            u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);\n            (u._visualValues || (u._visualValues = {}))[r] = d;\n        }\n    }\n    function Fs(t, e) {\n        const i = t.scales;\n        return Object.keys(i).filter((t)=>i[t].axis === e).shift();\n    }\n    function Vs(t, e) {\n        const i = t.controller.index, s = t.vScale && t.vScale.axis;\n        if (s) {\n            e = e || t._parsed;\n            for (const t of e){\n                const e = t._stacks;\n                if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\n                delete e[s][i], void 0 !== e[s]._visualValues && void 0 !== e[s]._visualValues[i] && delete e[s]._visualValues[i];\n            }\n        }\n    }\n    const Bs = (t)=>\"reset\" === t || \"none\" === t, Ws = (t, e)=>e ? t : Object.assign({}, t);\n    class Ns {\n        static defaults = {};\n        static datasetElementType = null;\n        static dataElementType = null;\n        constructor(t, e){\n            this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();\n        }\n        initialize() {\n            const t = this._cachedMeta;\n            this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n        updateIndex(t) {\n            this.index !== t && Vs(this._cachedMeta), this.index = t;\n        }\n        linkScales() {\n            const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (t, e, i, s)=>\"x\" === t ? e : \"r\" === t ? s : i, n = e.xAxisID = l(i.xAxisID, Fs(t, \"x\")), o = e.yAxisID = l(i.yAxisID, Fs(t, \"y\")), a = e.rAxisID = l(i.rAxisID, Fs(t, \"r\")), r = e.indexAxis, h = e.iAxisID = s(r, n, o, a), c = e.vAxisID = s(r, o, n, a);\n            e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);\n        }\n        getDataset() {\n            return this.chart.data.datasets[this.index];\n        }\n        getMeta() {\n            return this.chart.getDatasetMeta(this.index);\n        }\n        getScaleForId(t) {\n            return this.chart.scales[t];\n        }\n        _getOtherScale(t) {\n            const e = this._cachedMeta;\n            return t === e.iScale ? e.vScale : e.iScale;\n        }\n        reset() {\n            this._update(\"reset\");\n        }\n        _destroy() {\n            const t = this._cachedMeta;\n            this._data && rt(this._data, this), t._stacked && Vs(t);\n        }\n        _dataCheck() {\n            const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;\n            if (o(e)) {\n                const t = this._cachedMeta;\n                this._data = function(t, e) {\n                    const { iScale: i, vScale: s } = e, n = \"x\" === i.axis ? \"x\" : \"y\", o = \"x\" === s.axis ? \"x\" : \"y\", a = Object.keys(t), r = new Array(a.length);\n                    let l, h, c;\n                    for(l = 0, h = a.length; l < h; ++l)c = a[l], r[l] = {\n                        [n]: c,\n                        [o]: t[c]\n                    };\n                    return r;\n                }(e, t);\n            } else if (i !== e) {\n                if (i) {\n                    rt(i, this);\n                    const t = this._cachedMeta;\n                    Vs(t), t._parsed = [];\n                }\n                e && Object.isExtensible(e) && at(e, this), this._syncList = [], this._data = e;\n            }\n        }\n        addElements() {\n            const t = this._cachedMeta;\n            this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType);\n        }\n        buildOrUpdateElements(t) {\n            const e = this._cachedMeta, i = this.getDataset();\n            let s = !1;\n            this._dataCheck();\n            const n = e._stacked;\n            e._stacked = Es(e.vScale, e), e.stack !== i.stack && (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && (zs(this, e._parsed), e._stacked = Es(e.vScale, e));\n        }\n        configure() {\n            const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0);\n            this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n        }\n        parse(t, e) {\n            const { _cachedMeta: i, _data: s } = this, { iScale: a, _stacked: r } = i, l = a.axis;\n            let h, c, d, u = 0 === t && e === s.length || i._sorted, f = t > 0 && i._parsed[t - 1];\n            if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;\n            else {\n                d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);\n                const a = ()=>null === c[l] || f && c[l] < f[l];\n                for(h = 0; h < e; ++h)i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);\n                i._sorted = u;\n            }\n            r && zs(this, d);\n        }\n        parsePrimitiveData(t, e, i, s) {\n            const { iScale: n, vScale: o } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);\n            let d, u, f;\n            for(d = 0, u = s; d < u; ++d)f = d + i, c[d] = {\n                [a]: h || n.parse(l[f], f),\n                [r]: o.parse(e[f], f)\n            };\n            return c;\n        }\n        parseArrayData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, a = new Array(s);\n            let r, l, h, c;\n            for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n                x: n.parse(c[0], h),\n                y: o.parse(c[1], h)\n            };\n            return a;\n        }\n        parseObjectData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = new Array(s);\n            let h, c, d, u;\n            for(h = 0, c = s; h < c; ++h)d = h + i, u = e[d], l[h] = {\n                x: n.parse(M(u, a), d),\n                y: o.parse(M(u, r), d)\n            };\n            return l;\n        }\n        getParsed(t) {\n            return this._cachedMeta._parsed[t];\n        }\n        getDataElement(t) {\n            return this._cachedMeta.data[t];\n        }\n        applyStack(t, e, i) {\n            const s = this.chart, n = this._cachedMeta, o = e[t.axis];\n            return Ls({\n                keys: Ts(s, !0),\n                values: e._stacks[t.axis]._visualValues\n            }, o, n.index, {\n                mode: i\n            });\n        }\n        updateRangeFromParsed(t, e, i, s) {\n            const n = i[e.axis];\n            let o = null === n ? NaN : n;\n            const a = s && i._stacks[e.axis];\n            s && a && (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);\n        }\n        getMinMax(t, e) {\n            const i = this._cachedMeta, s = i._parsed, n = i._sorted && t === i.iScale, o = s.length, r = this._getOtherScale(t), l = ((t, e, i)=>t && !e.hidden && e._stacked && {\n                    keys: Ts(i, !0),\n                    values: null\n                })(e, i, this.chart), h = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            }, { min: c, max: d } = function(t) {\n                const { min: e, max: i, minDefined: s, maxDefined: n } = t.getUserBounds();\n                return {\n                    min: s ? e : Number.NEGATIVE_INFINITY,\n                    max: n ? i : Number.POSITIVE_INFINITY\n                };\n            }(r);\n            let u, f;\n            function g() {\n                f = s[u];\n                const e = f[r.axis];\n                return !a(f[t.axis]) || c > e || d < e;\n            }\n            for(u = 0; u < o && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\n            if (n) {\n                for(u = o - 1; u >= 0; --u)if (!g()) {\n                    this.updateRangeFromParsed(h, t, f, l);\n                    break;\n                }\n            }\n            return h;\n        }\n        getAllParsedValues(t) {\n            const e = this._cachedMeta._parsed, i = [];\n            let s, n, o;\n            for(s = 0, n = e.length; s < n; ++s)o = e[s][t.axis], a(o) && i.push(o);\n            return i;\n        }\n        getMaxOverflow() {\n            return !1;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = e.iScale, s = e.vScale, n = this.getParsed(t);\n            return {\n                label: i ? \"\" + i.getLabelForValue(n[i.axis]) : \"\",\n                value: s ? \"\" + s.getLabelForValue(n[s.axis]) : \"\"\n            };\n        }\n        _update(t) {\n            const e = this._cachedMeta;\n            this.update(t || \"default\"), e._clip = function(t) {\n                let e, i, s, n;\n                return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {\n                    top: e,\n                    right: i,\n                    bottom: s,\n                    left: n,\n                    disabled: !1 === t\n                };\n            }(l(this.options.clip, function(t, e, i) {\n                if (!1 === i) return !1;\n                const s = As(t, i), n = As(e, i);\n                return {\n                    top: n.end,\n                    right: s.end,\n                    bottom: n.start,\n                    left: s.start\n                };\n            }(e.xScale, e.yScale, this.getMaxOverflow())));\n        }\n        update(t) {}\n        draw() {\n            const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], n = e.chartArea, o = [], a = this._drawStart || 0, r = this._drawCount || s.length - a, l = this.options.drawActiveElementsOnTop;\n            let h;\n            for(i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h){\n                const e = s[h];\n                e.hidden || (e.active && l ? o.push(e) : e.draw(t, n));\n            }\n            for(h = 0; h < o.length; ++h)o[h].draw(t, n);\n        }\n        getStyle(t, e) {\n            const i = e ? \"active\" : \"default\";\n            return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);\n        }\n        getContext(t, e, i) {\n            const s = this.getDataset();\n            let n;\n            if (t >= 0 && t < this._cachedMeta.data.length) {\n                const e = this._cachedMeta.data[t];\n                n = e.$context || (e.$context = function(t, e, i) {\n                    return Ci(t, {\n                        active: !1,\n                        dataIndex: e,\n                        parsed: void 0,\n                        raw: void 0,\n                        element: i,\n                        index: e,\n                        mode: \"default\",\n                        type: \"data\"\n                    });\n                }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;\n            } else n = this.$context || (this.$context = function(t, e) {\n                return Ci(t, {\n                    active: !1,\n                    dataset: void 0,\n                    datasetIndex: e,\n                    index: e,\n                    mode: \"default\",\n                    type: \"dataset\"\n                });\n            }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\n            return n.active = !!e, n.mode = i, n;\n        }\n        resolveDatasetElementOptions(t) {\n            return this._resolveElementOptions(this.datasetElementType.id, t);\n        }\n        resolveDataElementOptions(t, e) {\n            return this._resolveElementOptions(this.dataElementType.id, e, t);\n        }\n        _resolveElementOptions(t, e = \"default\", i) {\n            const s = \"active\" === e, n = this._cachedDataOpts, o = t + \"-\" + e, a = n[o], r = this.enableOptionSharing && k(i);\n            if (a) return Ws(a, r);\n            const l = this.chart.config, h = l.datasetElementScopeKeys(this._type, t), c = s ? [\n                `${t}Hover`,\n                \"hover\",\n                t,\n                \"\"\n            ] : [\n                t,\n                \"\"\n            ], d = l.getOptionScopes(this.getDataset(), h), u = Object.keys(ue.elements[t]), f = l.resolveNamedOptions(d, u, ()=>this.getContext(i, s, e), c);\n            return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f;\n        }\n        _resolveAnimations(t, e, i) {\n            const s = this.chart, n = this._cachedDataOpts, o = `animation-${e}`, a = n[o];\n            if (a) return a;\n            let r;\n            if (!1 !== s.options.animation) {\n                const s = this.chart.config, n = s.datasetAnimationScopeKeys(this._type, e), o = s.getOptionScopes(this.getDataset(), n);\n                r = s.createResolver(o, this.getContext(t, i, e));\n            }\n            const l = new Os(s, r && r.animations);\n            return r && r._cacheable && (n[o] = Object.freeze(l)), l;\n        }\n        getSharedOptions(t) {\n            if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n        }\n        includeOptions(t, e) {\n            return !e || Bs(t) || this.chart._animationsDisabled;\n        }\n        _getSharedOptions(t, e) {\n            const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, n = this.getSharedOptions(i), o = this.includeOptions(e, n) || n !== s;\n            return this.updateSharedOptions(n, e, i), {\n                sharedOptions: n,\n                includeOptions: o\n            };\n        }\n        updateElement(t, e, i, s) {\n            Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);\n        }\n        updateSharedOptions(t, e, i) {\n            t && !Bs(e) && this._resolveAnimations(void 0, e).update(t, i);\n        }\n        _setStyle(t, e, i, s) {\n            t.active = s;\n            const n = this.getStyle(e, s);\n            this._resolveAnimations(e, i, s).update(t, {\n                options: !s && this.getSharedOptions(n) || n\n            });\n        }\n        removeHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !1);\n        }\n        setHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !0);\n        }\n        _removeDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !1);\n        }\n        _setDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !0);\n        }\n        _resyncElements(t) {\n            const e = this._data, i = this._cachedMeta.data;\n            for (const [t, e, i] of this._syncList)this[t](e, i);\n            this._syncList = [];\n            const s = i.length, n = e.length, o = Math.min(n, s);\n            o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);\n        }\n        _insertElements(t, e, i = !0) {\n            const s = this._cachedMeta, n = s.data, o = t + e;\n            let a;\n            const r = (t)=>{\n                for(t.length += e, a = t.length - 1; a >= o; a--)t[a] = t[a - e];\n            };\n            for(r(n), a = t; a < o; ++a)n[a] = new this.dataElementType;\n            this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, \"reset\");\n        }\n        updateElements(t, e, i, s) {}\n        _removeElements(t, e) {\n            const i = this._cachedMeta;\n            if (this._parsing) {\n                const s = i._parsed.splice(t, e);\n                i._stacked && Vs(i, s);\n            }\n            i.data.splice(t, e);\n        }\n        _sync(t) {\n            if (this._parsing) this._syncList.push(t);\n            else {\n                const [e, i, s] = t;\n                this[e](i, s);\n            }\n            this.chart._dataChanges.push([\n                this.index,\n                ...t\n            ]);\n        }\n        _onDataPush() {\n            const t = arguments.length;\n            this._sync([\n                \"_insertElements\",\n                this.getDataset().data.length - t,\n                t\n            ]);\n        }\n        _onDataPop() {\n            this._sync([\n                \"_removeElements\",\n                this._cachedMeta.data.length - 1,\n                1\n            ]);\n        }\n        _onDataShift() {\n            this._sync([\n                \"_removeElements\",\n                0,\n                1\n            ]);\n        }\n        _onDataSplice(t, e) {\n            e && this._sync([\n                \"_removeElements\",\n                t,\n                e\n            ]);\n            const i = arguments.length - 2;\n            i && this._sync([\n                \"_insertElements\",\n                t,\n                i\n            ]);\n        }\n        _onDataUnshift() {\n            this._sync([\n                \"_insertElements\",\n                0,\n                arguments.length\n            ]);\n        }\n    }\n    class Hs {\n        static defaults = {};\n        static defaultRoutes = void 0;\n        x;\n        y;\n        active = !1;\n        options;\n        $animations;\n        tooltipPosition(t) {\n            const { x: e, y: i } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: i\n            };\n        }\n        hasValue() {\n            return N(this.x) && N(this.y);\n        }\n        getProps(t, e) {\n            const i = this.$animations;\n            if (!e || !i) return this;\n            const s = {};\n            return t.forEach((t)=>{\n                s[t] = i[t] && i[t].active() ? i[t]._to : this[t];\n            }), s;\n        }\n    }\n    function js(t, e) {\n        const i = t.options.ticks, n = function(t) {\n            const e = t.options.offset, i = t._tickSize(), s = t._length / i + (e ? 0 : 1), n = t._maxLength / i;\n            return Math.floor(Math.min(s, n));\n        }(t), o = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? function(t) {\n            const e = [];\n            let i, s;\n            for(i = 0, s = t.length; i < s; i++)t[i].major && e.push(i);\n            return e;\n        }(e) : [], r = a.length, l = a[0], h = a[r - 1], c = [];\n        if (r > o) return function(t, e, i, s) {\n            let n, o = 0, a = i[0];\n            for(s = Math.ceil(s), n = 0; n < t.length; n++)n === a && (e.push(t[n]), o++, a = i[o * s]);\n        }(e, c, a, r / o), c;\n        const d = function(t, e, i) {\n            const s = function(t) {\n                const e = t.length;\n                let i, s;\n                if (e < 2) return !1;\n                for(s = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== s) return !1;\n                return s;\n            }(t), n = e.length / i;\n            if (!s) return Math.max(n, 1);\n            const o = W(s);\n            for(let t = 0, e = o.length - 1; t < e; t++){\n                const e = o[t];\n                if (e > n) return e;\n            }\n            return Math.max(n, 1);\n        }(a, e, o);\n        if (r > 0) {\n            let t, i;\n            const n = r > 1 ? Math.round((h - l) / (r - 1)) : null;\n            for($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t < i; t++)$s(e, c, d, a[t], a[t + 1]);\n            return $s(e, c, d, h, s(n) ? e.length : h + n), c;\n        }\n        return $s(e, c, d), c;\n    }\n    function $s(t, e, i, s, n) {\n        const o = l(s, 0), a = Math.min(l(n, t.length), t.length);\n        let r, h, c, d = 0;\n        for(i = Math.ceil(i), n && (r = n - s, i = r / Math.floor(r / i)), c = o; c < 0;)d++, c = Math.round(o + d * i);\n        for(h = Math.max(o, 0); h < a; h++)h === c && (e.push(t[h]), d++, c = Math.round(o + d * i));\n    }\n    const Ys = (t, e, i)=>\"top\" === e || \"left\" === e ? t[e] + i : t[e] - i, Us = (t, e)=>Math.min(e || t, t);\n    function Xs(t, e) {\n        const i = [], s = t.length / e, n = t.length;\n        let o = 0;\n        for(; o < n; o += s)i.push(t[Math.floor(o)]);\n        return i;\n    }\n    function qs(t, e, i) {\n        const s = t.ticks.length, n = Math.min(e, s - 1), o = t._startPixel, a = t._endPixel, r = 1e-6;\n        let l, h = t.getPixelForTick(n);\n        if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h;\n    }\n    function Ks(t) {\n        return t.drawTicks ? t.tickLength : 0;\n    }\n    function Gs(t, e) {\n        if (!t.display) return 0;\n        const i = Si(t.font, e), s = ki(t.padding);\n        return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height;\n    }\n    function Zs(t, e, i) {\n        let s = ut(t);\n        return (i && \"right\" !== e || !i && \"right\" === e) && (s = ((t)=>\"left\" === t ? \"right\" : \"right\" === t ? \"left\" : t)(s)), s;\n    }\n    class Js extends Hs {\n        constructor(t){\n            super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n        }\n        init(t) {\n            this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n        }\n        parse(t, e) {\n            return t;\n        }\n        getUserBounds() {\n            let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;\n            return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {\n                min: r(t, i),\n                max: r(e, s),\n                minDefined: a(t),\n                maxDefined: a(e)\n            };\n        }\n        getMinMax(t) {\n            let e, { min: i, max: s, minDefined: n, maxDefined: o } = this.getUserBounds();\n            if (n && o) return {\n                min: i,\n                max: s\n            };\n            const a = this.getMatchingVisibleMetas();\n            for(let r = 0, l = a.length; r < l; ++r)e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\n            return i = o && i > s ? s : i, s = n && i > s ? i : s, {\n                min: r(i, r(s, i)),\n                max: r(s, r(i, s))\n            };\n        }\n        getPadding() {\n            return {\n                left: this.paddingLeft || 0,\n                top: this.paddingTop || 0,\n                right: this.paddingRight || 0,\n                bottom: this.paddingBottom || 0\n            };\n        }\n        getTicks() {\n            return this.ticks;\n        }\n        getLabels() {\n            const t = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n        }\n        getLabelItems(t = this.chart.chartArea) {\n            return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n        }\n        beforeLayout() {\n            this._cache = {}, this._dataLimitsCached = !1;\n        }\n        beforeUpdate() {\n            d(this.options.beforeUpdate, [\n                this\n            ]);\n        }\n        update(t, e, i) {\n            const { beginAtZero: s, grace: n, ticks: o } = this.options, a = o.sampleSize;\n            this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n            const r = a < this.ticks.length;\n            this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || \"auto\" === o.source) && (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n        }\n        configure() {\n            let t, e, i = this.options.reverse;\n            this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels;\n        }\n        afterUpdate() {\n            d(this.options.afterUpdate, [\n                this\n            ]);\n        }\n        beforeSetDimensions() {\n            d(this.options.beforeSetDimensions, [\n                this\n            ]);\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n        }\n        afterSetDimensions() {\n            d(this.options.afterSetDimensions, [\n                this\n            ]);\n        }\n        _callHooks(t) {\n            this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [\n                this\n            ]);\n        }\n        beforeDataLimits() {\n            this._callHooks(\"beforeDataLimits\");\n        }\n        determineDataLimits() {}\n        afterDataLimits() {\n            this._callHooks(\"afterDataLimits\");\n        }\n        beforeBuildTicks() {\n            this._callHooks(\"beforeBuildTicks\");\n        }\n        buildTicks() {\n            return [];\n        }\n        afterBuildTicks() {\n            this._callHooks(\"afterBuildTicks\");\n        }\n        beforeTickToLabelConversion() {\n            d(this.options.beforeTickToLabelConversion, [\n                this\n            ]);\n        }\n        generateTickLabels(t) {\n            const e = this.options.ticks;\n            let i, s, n;\n            for(i = 0, s = t.length; i < s; i++)n = t[i], n.label = d(e.callback, [\n                n.value,\n                i,\n                t\n            ], this);\n        }\n        afterTickToLabelConversion() {\n            d(this.options.afterTickToLabelConversion, [\n                this\n            ]);\n        }\n        beforeCalculateLabelRotation() {\n            d(this.options.beforeCalculateLabelRotation, [\n                this\n            ]);\n        }\n        calculateLabelRotation() {\n            const t = this.options, e = t.ticks, i = Us(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, n = e.maxRotation;\n            let o, a, r, l = s;\n            if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s);\n            const h = this._getLabelSizes(), c = h.widest.width, d = h.highest.height, u = J(this.chart.width - c, 0, this.maxWidth);\n            o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) / o, -1, 1)), Math.asin(J(a / r, -1, 1)) - Math.asin(J(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l;\n        }\n        afterCalculateLabelRotation() {\n            d(this.options.afterCalculateLabelRotation, [\n                this\n            ]);\n        }\n        afterAutoSkip() {}\n        beforeFit() {\n            d(this.options.beforeFit, [\n                this\n            ]);\n        }\n        fit() {\n            const t = {\n                width: 0,\n                height: 0\n            }, { chart: e, options: { ticks: i, title: s, grid: n } } = this, o = this._isVisible(), a = this.isHorizontal();\n            if (o) {\n                const o = Gs(s, e.options.font);\n                if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display && this.ticks.length) {\n                    const { first: e, last: s, widest: n, highest: o } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);\n                    if (a) {\n                        const e = i.mirror ? 0 : c * n.width + h * o.height;\n                        t.height = Math.min(this.maxHeight, t.height + e + r);\n                    } else {\n                        const e = i.mirror ? 0 : h * n.width + c * o.height;\n                        t.width = Math.min(this.maxWidth, t.width + e + r);\n                    }\n                    this._calculatePadding(e, s, c, h);\n                }\n            }\n            this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n        }\n        _calculatePadding(t, e, i, s) {\n            const { ticks: { align: n, padding: o }, position: a } = this.options, r = 0 !== this.labelRotation, l = \"top\" !== a && \"x\" === this.axis;\n            if (this.isHorizontal()) {\n                const a = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);\n                let c = 0, d = 0;\n                r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : \"start\" === n ? d = e.width : \"end\" === n ? c = t.width : \"inner\" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0);\n            } else {\n                let i = e.height / 2, s = t.height / 2;\n                \"start\" === n ? (i = 0, s = t.height) : \"end\" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o;\n            }\n        }\n        _handleMargins() {\n            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n        }\n        afterFit() {\n            d(this.options.afterFit, [\n                this\n            ]);\n        }\n        isHorizontal() {\n            const { axis: t, position: e } = this.options;\n            return \"top\" === e || \"bottom\" === e || \"x\" === t;\n        }\n        isFullSize() {\n            return this.options.fullSize;\n        }\n        _convertTicksToLabels(t) {\n            let e, i;\n            for(this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)s(t[e].label) && (t.splice(e, 1), i--, e--);\n            this.afterTickToLabelConversion();\n        }\n        _getLabelSizes() {\n            let t = this._labelSizes;\n            if (!t) {\n                const e = this.options.ticks.sampleSize;\n                let i = this.ticks;\n                e < i.length && (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);\n            }\n            return t;\n        }\n        _computeLabelSizes(t, e, i) {\n            const { ctx: o, _longestTextCache: a } = this, r = [], l = [], h = Math.floor(e / Us(e, i));\n            let c, d, f, g, p, m, x, b, _, y, v, M = 0, w = 0;\n            for(c = 0; c < e; c += h){\n                if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, x = a[m] = a[m] || {\n                    data: {},\n                    gc: []\n                }, b = p.lineHeight, _ = y = 0, s(g) || n(g)) {\n                    if (n(g)) for(d = 0, f = g.length; d < f; ++d)v = g[d], s(v) || n(v) || (_ = Ce(o, x.data, x.gc, _, v), y += b);\n                } else _ = Ce(o, x.data, x.gc, _, g), y = b;\n                r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w);\n            }\n            !function(t, e) {\n                u(t, (t)=>{\n                    const i = t.gc, s = i.length / 2;\n                    let n;\n                    if (s > e) {\n                        for(n = 0; n < s; ++n)delete t.data[i[n]];\n                        i.splice(0, s);\n                    }\n                });\n            }(a, e);\n            const k = r.indexOf(M), S = l.indexOf(w), P = (t)=>({\n                    width: r[t] || 0,\n                    height: l[t] || 0\n                });\n            return {\n                first: P(0),\n                last: P(e - 1),\n                widest: P(k),\n                highest: P(S),\n                widths: r,\n                heights: l\n            };\n        }\n        getLabelForValue(t) {\n            return t;\n        }\n        getPixelForValue(t, e) {\n            return NaN;\n        }\n        getValueForPixel(t) {}\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getPixelForDecimal(t) {\n            this._reversePixels && (t = 1 - t);\n            const e = this._startPixel + t * this._length;\n            return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e);\n        }\n        getDecimalForPixel(t) {\n            const e = (t - this._startPixel) / this._length;\n            return this._reversePixels ? 1 - e : e;\n        }\n        getBasePixel() {\n            return this.getPixelForValue(this.getBaseValue());\n        }\n        getBaseValue() {\n            const { min: t, max: e } = this;\n            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n        }\n        getContext(t) {\n            const e = this.ticks || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return i.$context || (i.$context = function(t, e, i) {\n                    return Ci(t, {\n                        tick: i,\n                        index: e,\n                        type: \"tick\"\n                    });\n                }(this.getContext(), t, i));\n            }\n            return this.$context || (this.$context = Ci(this.chart.getContext(), {\n                scale: this,\n                type: \"scale\"\n            }));\n        }\n        _tickSize() {\n            const t = this.options.ticks, e = $(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), n = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = n ? n.widest.width + o : 0, r = n ? n.highest.height + o : 0;\n            return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s;\n        }\n        _isVisible() {\n            const t = this.options.display;\n            return \"auto\" !== t ? !!t : this.getMatchingVisibleMetas().length > 0;\n        }\n        _computeGridLineItems(t) {\n            const e = this.axis, i = this.chart, s = this.options, { grid: n, position: a, border: r } = s, h = n.offset, c = this.isHorizontal(), d = this.ticks.length + (h ? 1 : 0), u = Ks(n), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, m = p / 2, x = function(t) {\n                return Ae(i, t, p);\n            };\n            let b, _, y, v, M, w, k, S, P, D, C, O;\n            if (\"top\" === a) b = x(this.bottom), w = this.bottom - u, S = b - m, D = x(t.top) + m, O = t.bottom;\n            else if (\"bottom\" === a) b = x(this.top), D = t.top, O = x(t.bottom) - m, w = b + m, S = this.top + u;\n            else if (\"left\" === a) b = x(this.right), M = this.right - u, k = b - m, P = x(t.left) + m, C = t.right;\n            else if (\"right\" === a) b = x(this.left), P = t.left, C = x(t.right) - m, M = b + m, k = this.left + u;\n            else if (\"x\" === e) {\n                if (\"center\" === a) b = x((t.top + t.bottom) / 2 + .5);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    b = x(this.chart.scales[t].getPixelForValue(e));\n                }\n                D = t.top, O = t.bottom, w = b + m, S = w + u;\n            } else if (\"y\" === e) {\n                if (\"center\" === a) b = x((t.left + t.right) / 2);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    b = x(this.chart.scales[t].getPixelForValue(e));\n                }\n                M = b - m, k = M - u, P = t.left, C = t.right;\n            }\n            const A = l(s.ticks.maxTicksLimit, d), T = Math.max(1, Math.ceil(d / A));\n            for(_ = 0; _ < d; _ += T){\n                const t = this.getContext(_), e = n.setContext(t), s = r.setContext(t), o = e.lineWidth, a = e.color, l = s.dash || [], d = s.dashOffset, u = e.tickWidth, g = e.tickColor, p = e.tickBorderDash || [], m = e.tickBorderDashOffset;\n                y = qs(this, _, h), void 0 !== y && (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({\n                    tx1: M,\n                    ty1: w,\n                    tx2: k,\n                    ty2: S,\n                    x1: P,\n                    y1: D,\n                    x2: C,\n                    y2: O,\n                    width: o,\n                    color: a,\n                    borderDash: l,\n                    borderDashOffset: d,\n                    tickWidth: u,\n                    tickColor: g,\n                    tickBorderDash: p,\n                    tickBorderDashOffset: m\n                }));\n            }\n            return this._ticksLength = d, this._borderValue = b, f;\n        }\n        _computeLabelItems(t) {\n            const e = this.axis, i = this.options, { position: s, ticks: a } = i, r = this.isHorizontal(), l = this.ticks, { align: h, crossAlign: c, padding: d, mirror: u } = a, f = Ks(i.grid), g = f + d, p = u ? -d : g, m = -$(this.labelRotation), x = [];\n            let b, _, y, v, M, w, k, S, P, D, C, O, A = \"middle\";\n            if (\"top\" === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();\n            else if (\"bottom\" === s) w = this.top + p, k = this._getXAxisLabelAlignment();\n            else if (\"left\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"right\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"x\" === e) {\n                if (\"center\" === s) w = (t.top + t.bottom) / 2 + g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    w = this.chart.scales[t].getPixelForValue(e) + g;\n                }\n                k = this._getXAxisLabelAlignment();\n            } else if (\"y\" === e) {\n                if (\"center\" === s) M = (t.left + t.right) / 2 - g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    M = this.chart.scales[t].getPixelForValue(e);\n                }\n                k = this._getYAxisLabelAlignment(f).textAlign;\n            }\n            \"y\" === e && (\"start\" === h ? A = \"top\" : \"end\" === h && (A = \"bottom\"));\n            const T = this._getLabelSizes();\n            for(b = 0, _ = l.length; b < _; ++b){\n                y = l[b], v = y.label;\n                const t = a.setContext(this.getContext(b));\n                S = this.getPixelForTick(b) + a.labelOffset, P = this._resolveTickFontOptions(b), D = P.lineHeight, C = n(v) ? v.length : 1;\n                const e = C / 2, i = t.color, o = t.textStrokeColor, h = t.textStrokeWidth;\n                let d, f = k;\n                if (r ? (M = S, \"inner\" === k && (f = b === _ - 1 ? this.options.reverse ? \"left\" : \"right\" : 0 === b ? this.options.reverse ? \"right\" : \"left\" : \"center\"), O = \"top\" === s ? \"near\" === c || 0 !== m ? -C * D + D / 2 : \"center\" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : \"near\" === c || 0 !== m ? D / 2 : \"center\" === c ? T.highest.height / 2 - e * D : T.highest.height - C * D, u && (O *= -1), 0 === m || t.showLabelBackdrop || (M += D / 2 * Math.sin(m))) : (w = S, O = (1 - C) * D / 2), t.showLabelBackdrop) {\n                    const e = ki(t.backdropPadding), i = T.heights[b], s = T.widths[b];\n                    let n = O - e.top, o = 0 - e.left;\n                    switch(A){\n                        case \"middle\":\n                            n -= i / 2;\n                            break;\n                        case \"bottom\":\n                            n -= i;\n                    }\n                    switch(k){\n                        case \"center\":\n                            o -= s / 2;\n                            break;\n                        case \"right\":\n                            o -= s;\n                            break;\n                        case \"inner\":\n                            b === _ - 1 ? o -= s : b > 0 && (o -= s / 2);\n                    }\n                    d = {\n                        left: o,\n                        top: n,\n                        width: s + e.width,\n                        height: i + e.height,\n                        color: t.backdropColor\n                    };\n                }\n                x.push({\n                    label: v,\n                    font: P,\n                    textOffset: O,\n                    options: {\n                        rotation: m,\n                        color: i,\n                        strokeColor: o,\n                        strokeWidth: h,\n                        textAlign: f,\n                        textBaseline: A,\n                        translation: [\n                            M,\n                            w\n                        ],\n                        backdrop: d\n                    }\n                });\n            }\n            return x;\n        }\n        _getXAxisLabelAlignment() {\n            const { position: t, ticks: e } = this.options;\n            if (-$(this.labelRotation)) return \"top\" === t ? \"left\" : \"right\";\n            let i = \"center\";\n            return \"start\" === e.align ? i = \"left\" : \"end\" === e.align ? i = \"right\" : \"inner\" === e.align && (i = \"inner\"), i;\n        }\n        _getYAxisLabelAlignment(t) {\n            const { position: e, ticks: { crossAlign: i, mirror: s, padding: n } } = this.options, o = t + n, a = this._getLabelSizes().widest.width;\n            let r, l;\n            return \"left\" === e ? s ? (l = this.right + n, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l += a)) : (l = this.right - o, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l = this.left)) : \"right\" === e ? s ? (l = this.left + n, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l -= a)) : (l = this.left + o, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l = this.right)) : r = \"right\", {\n                textAlign: r,\n                x: l\n            };\n        }\n        _computeLabelArea() {\n            if (this.options.ticks.mirror) return;\n            const t = this.chart, e = this.options.position;\n            return \"left\" === e || \"right\" === e ? {\n                top: 0,\n                left: this.left,\n                bottom: t.height,\n                right: this.right\n            } : \"top\" === e || \"bottom\" === e ? {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: t.width\n            } : void 0;\n        }\n        drawBackground() {\n            const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: n, height: o } = this;\n            e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore());\n        }\n        getLineWidthForValue(t) {\n            const e = this.options.grid;\n            if (!this._isVisible() || !e.display) return 0;\n            const i = this.ticks.findIndex((e)=>e.value === t);\n            if (i >= 0) return e.setContext(this.getContext(i)).lineWidth;\n            return 0;\n        }\n        drawGrid(t) {\n            const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n            let n, o;\n            const a = (t, e, s)=>{\n                s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore());\n            };\n            if (e.display) for(n = 0, o = s.length; n < o; ++n){\n                const t = s[n];\n                e.drawOnChartArea && a({\n                    x: t.x1,\n                    y: t.y1\n                }, {\n                    x: t.x2,\n                    y: t.y2\n                }, t), e.drawTicks && a({\n                    x: t.tx1,\n                    y: t.ty1\n                }, {\n                    x: t.tx2,\n                    y: t.ty2\n                }, {\n                    color: t.tickColor,\n                    width: t.tickWidth,\n                    borderDash: t.tickBorderDash,\n                    borderDashOffset: t.tickBorderDashOffset\n                });\n            }\n        }\n        drawBorder() {\n            const { chart: t, ctx: e, options: { border: i, grid: s } } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;\n            if (!o) return;\n            const a = s.setContext(this.getContext(0)).lineWidth, r = this._borderValue;\n            let l, h, c, d;\n            this.isHorizontal() ? (l = Ae(t, this.left, o) - o / 2, h = Ae(t, this.right, a) + a / 2, c = d = r) : (c = Ae(t, this.top, o) - o / 2, d = Ae(t, this.bottom, a) + a / 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore();\n        }\n        drawLabels(t) {\n            if (!this.options.ticks.display) return;\n            const e = this.ctx, i = this._computeLabelArea();\n            i && Ie(e, i);\n            const s = this.getLabelItems(t);\n            for (const t of s){\n                const i = t.options, s = t.font;\n                Ne(e, t.label, 0, t.textOffset, s, i);\n            }\n            i && ze(e);\n        }\n        drawTitle() {\n            const { ctx: t, options: { position: e, title: i, reverse: s } } = this;\n            if (!i.display) return;\n            const a = Si(i.font), r = ki(i.padding), l = i.align;\n            let h = a.lineHeight / 2;\n            \"bottom\" === e || \"center\" === e || o(e) ? (h += r.bottom, n(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\n            const { titleX: c, titleY: d, maxWidth: u, rotation: f } = function(t, e, i, s) {\n                const { top: n, left: a, bottom: r, right: l, chart: h } = t, { chartArea: c, scales: d } = h;\n                let u, f, g, p = 0;\n                const m = r - n, x = l - a;\n                if (t.isHorizontal()) {\n                    if (f = ft(s, a, l), o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        g = d[t].getPixelForValue(s) + m - e;\n                    } else g = \"center\" === i ? (c.bottom + c.top) / 2 + m - e : Ys(t, i, e);\n                    u = l - a;\n                } else {\n                    if (o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        f = d[t].getPixelForValue(s) - x + e;\n                    } else f = \"center\" === i ? (c.left + c.right) / 2 - x + e : Ys(t, i, e);\n                    g = ft(s, r, n), p = \"left\" === i ? -E : E;\n                }\n                return {\n                    titleX: f,\n                    titleY: g,\n                    maxWidth: u,\n                    rotation: p\n                };\n            }(this, h, e, l);\n            Ne(t, i.text, 0, 0, a, {\n                color: i.color,\n                maxWidth: u,\n                rotation: f,\n                textAlign: Zs(l, e, s),\n                textBaseline: \"middle\",\n                translation: [\n                    c,\n                    d\n                ]\n            });\n        }\n        draw(t) {\n            this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n        }\n        _layers() {\n            const t = this.options, e = t.ticks && t.ticks.z || 0, i = l(t.grid && t.grid.z, -1), s = l(t.border && t.border.z, 0);\n            return this._isVisible() && this.draw === Js.prototype.draw ? [\n                {\n                    z: i,\n                    draw: (t)=>{\n                        this.drawBackground(), this.drawGrid(t), this.drawTitle();\n                    }\n                },\n                {\n                    z: s,\n                    draw: ()=>{\n                        this.drawBorder();\n                    }\n                },\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.drawLabels(t);\n                    }\n                }\n            ] : [\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.draw(t);\n                    }\n                }\n            ];\n        }\n        getMatchingVisibleMetas(t) {\n            const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + \"AxisID\", s = [];\n            let n, o;\n            for(n = 0, o = e.length; n < o; ++n){\n                const o = e[n];\n                o[i] !== this.id || t && o.type !== t || s.push(o);\n            }\n            return s;\n        }\n        _resolveTickFontOptions(t) {\n            return Si(this.options.ticks.setContext(this.getContext(t)).font);\n        }\n        _maxDigits() {\n            const t = this._resolveTickFontOptions(0).lineHeight;\n            return (this.isHorizontal() ? this.width : this.height) / t;\n        }\n    }\n    class Qs {\n        constructor(t, e, i){\n            this.type = t, this.scope = e, this.override = i, this.items = Object.create(null);\n        }\n        isForType(t) {\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n        }\n        register(t) {\n            const e = Object.getPrototypeOf(t);\n            let i;\n            (function(t) {\n                return \"id\" in t && \"defaults\" in t;\n            })(e) && (i = this.register(e));\n            const s = this.items, n = t.id, o = this.scope + \".\" + n;\n            if (!n) throw new Error(\"class does not have id: \" + t);\n            return n in s || (s[n] = t, function(t, e, i) {\n                const s = x(Object.create(null), [\n                    i ? ue.get(i) : {},\n                    ue.get(e),\n                    t.defaults\n                ]);\n                ue.set(e, s), t.defaultRoutes && function(t, e) {\n                    Object.keys(e).forEach((i)=>{\n                        const s = i.split(\".\"), n = s.pop(), o = [\n                            t\n                        ].concat(s).join(\".\"), a = e[i].split(\".\"), r = a.pop(), l = a.join(\".\");\n                        ue.route(o, n, l, r);\n                    });\n                }(e, t.defaultRoutes);\n                t.descriptors && ue.describe(e, t.descriptors);\n            }(t, o, i), this.override && ue.override(t.id, t.overrides)), o;\n        }\n        get(t) {\n            return this.items[t];\n        }\n        unregister(t) {\n            const e = this.items, i = t.id, s = this.scope;\n            i in e && delete e[i], s && i in ue[s] && (delete ue[s][i], this.override && delete re[i]);\n        }\n    }\n    class tn {\n        constructor(){\n            this.controllers = new Qs(Ns, \"datasets\", !0), this.elements = new Qs(Hs, \"elements\"), this.plugins = new Qs(Object, \"plugins\"), this.scales = new Qs(Js, \"scales\"), this._typedRegistries = [\n                this.controllers,\n                this.scales,\n                this.elements\n            ];\n        }\n        add(...t) {\n            this._each(\"register\", t);\n        }\n        remove(...t) {\n            this._each(\"unregister\", t);\n        }\n        addControllers(...t) {\n            this._each(\"register\", t, this.controllers);\n        }\n        addElements(...t) {\n            this._each(\"register\", t, this.elements);\n        }\n        addPlugins(...t) {\n            this._each(\"register\", t, this.plugins);\n        }\n        addScales(...t) {\n            this._each(\"register\", t, this.scales);\n        }\n        getController(t) {\n            return this._get(t, this.controllers, \"controller\");\n        }\n        getElement(t) {\n            return this._get(t, this.elements, \"element\");\n        }\n        getPlugin(t) {\n            return this._get(t, this.plugins, \"plugin\");\n        }\n        getScale(t) {\n            return this._get(t, this.scales, \"scale\");\n        }\n        removeControllers(...t) {\n            this._each(\"unregister\", t, this.controllers);\n        }\n        removeElements(...t) {\n            this._each(\"unregister\", t, this.elements);\n        }\n        removePlugins(...t) {\n            this._each(\"unregister\", t, this.plugins);\n        }\n        removeScales(...t) {\n            this._each(\"unregister\", t, this.scales);\n        }\n        _each(t, e, i) {\n            [\n                ...e\n            ].forEach((e)=>{\n                const s = i || this._getRegistryForType(e);\n                i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : u(e, (e)=>{\n                    const s = i || this._getRegistryForType(e);\n                    this._exec(t, s, e);\n                });\n            });\n        }\n        _exec(t, e, i) {\n            const s = w(t);\n            d(i[\"before\" + s], [], i), e[t](i), d(i[\"after\" + s], [], i);\n        }\n        _getRegistryForType(t) {\n            for(let e = 0; e < this._typedRegistries.length; e++){\n                const i = this._typedRegistries[e];\n                if (i.isForType(t)) return i;\n            }\n            return this.plugins;\n        }\n        _get(t, e, i) {\n            const s = e.get(t);\n            if (void 0 === s) throw new Error('\"' + t + '\" is not a registered ' + i + \".\");\n            return s;\n        }\n    }\n    var en = new tn;\n    class sn {\n        constructor(){\n            this._init = [];\n        }\n        notify(t, e, i, s) {\n            \"beforeInit\" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n            const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(n, t, e, i);\n            return \"afterDestroy\" === e && (this._notify(n, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), o;\n        }\n        _notify(t, e, i, s) {\n            s = s || {};\n            for (const n of t){\n                const t = n.plugin;\n                if (!1 === d(t[i], [\n                    e,\n                    s,\n                    n.options\n                ], t) && s.cancelable) return !1;\n            }\n            return !0;\n        }\n        invalidate() {\n            s(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n        }\n        _descriptors(t) {\n            if (this._cache) return this._cache;\n            const e = this._cache = this._createDescriptors(t);\n            return this._notifyStateChanges(t), e;\n        }\n        _createDescriptors(t, e) {\n            const i = t && t.config, s = l(i.options && i.options.plugins, {}), n = function(t) {\n                const e = {}, i = [], s = Object.keys(en.plugins.items);\n                for(let t = 0; t < s.length; t++)i.push(en.getPlugin(s[t]));\n                const n = t.plugins || [];\n                for(let t = 0; t < n.length; t++){\n                    const s = n[t];\n                    -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0);\n                }\n                return {\n                    plugins: i,\n                    localIds: e\n                };\n            }(i);\n            return !1 !== s || e ? function(t, { plugins: e, localIds: i }, s, n) {\n                const o = [], a = t.getContext();\n                for (const r of e){\n                    const e = r.id, l = nn(s[e], n);\n                    null !== l && o.push({\n                        plugin: r,\n                        options: on(t.config, {\n                            plugin: r,\n                            local: i[e]\n                        }, l, a)\n                    });\n                }\n                return o;\n            }(t, n, s, e) : [];\n        }\n        _notifyStateChanges(t) {\n            const e = this._oldCache || [], i = this._cache, s = (t, e)=>t.filter((t)=>!e.some((e)=>t.plugin.id === e.plugin.id));\n            this._notify(s(e, i), t, \"stop\"), this._notify(s(i, e), t, \"start\");\n        }\n    }\n    function nn(t, e) {\n        return e || !1 !== t ? !0 === t ? {} : t : null;\n    }\n    function on(t, { plugin: e, local: i }, s, n) {\n        const o = t.pluginScopeKeys(e), a = t.getOptionScopes(s, o);\n        return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [\n            \"\"\n        ], {\n            scriptable: !1,\n            indexable: !1,\n            allKeys: !0\n        });\n    }\n    function an(t, e) {\n        const i = ue.datasets[t] || {};\n        return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || \"x\";\n    }\n    function rn(t) {\n        if (\"x\" === t || \"y\" === t || \"r\" === t) return t;\n    }\n    function ln(t, ...e) {\n        if (rn(t)) return t;\n        for (const s of e){\n            const e = s.axis || (\"top\" === (i = s.position) || \"bottom\" === i ? \"x\" : \"left\" === i || \"right\" === i ? \"y\" : void 0) || t.length > 1 && rn(t[0].toLowerCase());\n            if (e) return e;\n        }\n        var i;\n        throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);\n    }\n    function hn(t, e, i) {\n        if (i[e + \"AxisID\"] === t) return {\n            axis: e\n        };\n    }\n    function cn(t, e) {\n        const i = re[t.type] || {\n            scales: {}\n        }, s = e.scales || {}, n = an(t.type, e), a = Object.create(null);\n        return Object.keys(s).forEach((e)=>{\n            const r = s[e];\n            if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);\n            if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);\n            const l = ln(e, r, function(t, e) {\n                if (e.data && e.data.datasets) {\n                    const i = e.data.datasets.filter((e)=>e.xAxisID === t || e.yAxisID === t);\n                    if (i.length) return hn(t, \"x\", i[0]) || hn(t, \"y\", i[0]);\n                }\n                return {};\n            }(e, t), ue.scales[r.type]), h = function(t, e) {\n                return t === e ? \"_index_\" : \"_value_\";\n            }(l, n), c = i.scales || {};\n            a[e] = b(Object.create(null), [\n                {\n                    axis: l\n                },\n                r,\n                c[l],\n                c[h]\n            ]);\n        }), t.data.datasets.forEach((i)=>{\n            const n = i.type || t.type, o = i.indexAxis || an(n, e), r = (re[n] || {}).scales || {};\n            Object.keys(r).forEach((t)=>{\n                const e = function(t, e) {\n                    let i = t;\n                    return \"_index_\" === t ? i = e : \"_value_\" === t && (i = \"x\" === e ? \"y\" : \"x\"), i;\n                }(t, o), n = i[e + \"AxisID\"] || e;\n                a[n] = a[n] || Object.create(null), b(a[n], [\n                    {\n                        axis: e\n                    },\n                    s[n],\n                    r[t]\n                ]);\n            });\n        }), Object.keys(a).forEach((t)=>{\n            const e = a[t];\n            b(e, [\n                ue.scales[e.type],\n                ue.scale\n            ]);\n        }), a;\n    }\n    function dn(t) {\n        const e = t.options || (t.options = {});\n        e.plugins = l(e.plugins, {}), e.scales = cn(t, e);\n    }\n    function un(t) {\n        return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t;\n    }\n    const fn = new Map, gn = new Set;\n    function pn(t, e) {\n        let i = fn.get(t);\n        return i || (i = e(), fn.set(t, i), gn.add(i)), i;\n    }\n    const mn = (t, e, i)=>{\n        const s = M(e, i);\n        void 0 !== s && t.add(s);\n    };\n    class xn {\n        constructor(t){\n            this._config = function(t) {\n                return (t = t || {}).data = un(t.data), dn(t), t;\n            }(t), this._scopeCache = new Map, this._resolverCache = new Map;\n        }\n        get platform() {\n            return this._config.platform;\n        }\n        get type() {\n            return this._config.type;\n        }\n        set type(t) {\n            this._config.type = t;\n        }\n        get data() {\n            return this._config.data;\n        }\n        set data(t) {\n            this._config.data = un(t);\n        }\n        get options() {\n            return this._config.options;\n        }\n        set options(t) {\n            this._config.options = t;\n        }\n        get plugins() {\n            return this._config.plugins;\n        }\n        update() {\n            const t = this._config;\n            this.clearCache(), dn(t);\n        }\n        clearCache() {\n            this._scopeCache.clear(), this._resolverCache.clear();\n        }\n        datasetScopeKeys(t) {\n            return pn(t, ()=>[\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetAnimationScopeKeys(t, e) {\n            return pn(`${t}.transition.${e}`, ()=>[\n                    [\n                        `datasets.${t}.transitions.${e}`,\n                        `transitions.${e}`\n                    ],\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetElementScopeKeys(t, e) {\n            return pn(`${t}-${e}`, ()=>[\n                    [\n                        `datasets.${t}.elements.${e}`,\n                        `datasets.${t}`,\n                        `elements.${e}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        pluginScopeKeys(t) {\n            const e = t.id;\n            return pn(`${this.type}-plugin-${e}`, ()=>[\n                    [\n                        `plugins.${e}`,\n                        ...t.additionalOptionScopes || []\n                    ]\n                ]);\n        }\n        _cachedScopes(t, e) {\n            const i = this._scopeCache;\n            let s = i.get(t);\n            return s && !e || (s = new Map, i.set(t, s)), s;\n        }\n        getOptionScopes(t, e, i) {\n            const { options: s, type: n } = this, o = this._cachedScopes(t, i), a = o.get(e);\n            if (a) return a;\n            const r = new Set;\n            e.forEach((e)=>{\n                t && (r.add(t), e.forEach((e)=>mn(r, t, e))), e.forEach((t)=>mn(r, s, t)), e.forEach((t)=>mn(r, re[n] || {}, t)), e.forEach((t)=>mn(r, ue, t)), e.forEach((t)=>mn(r, le, t));\n            });\n            const l = Array.from(r);\n            return 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l;\n        }\n        chartOptionScopes() {\n            const { options: t, type: e } = this;\n            return [\n                t,\n                re[e] || {},\n                ue.datasets[e] || {},\n                {\n                    type: e\n                },\n                ue,\n                le\n            ];\n        }\n        resolveNamedOptions(t, e, i, s = [\n            \"\"\n        ]) {\n            const o = {\n                $shared: !0\n            }, { resolver: a, subPrefixes: r } = bn(this._resolverCache, t, s);\n            let l = a;\n            if (function(t, e) {\n                const { isScriptable: i, isIndexable: s } = Ye(t);\n                for (const o of e){\n                    const e = i(o), a = s(o), r = (a || e) && t[o];\n                    if (e && (S(r) || _n(r)) || a && n(r)) return !0;\n                }\n                return !1;\n            }(a, e)) {\n                o.$shared = !1;\n                l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r));\n            }\n            for (const t of e)o[t] = l[t];\n            return o;\n        }\n        createResolver(t, e, i = [\n            \"\"\n        ], s) {\n            const { resolver: n } = bn(this._resolverCache, t, i);\n            return o(e) ? $e(n, e, void 0, s) : n;\n        }\n    }\n    function bn(t, e, i) {\n        let s = t.get(e);\n        s || (s = new Map, t.set(e, s));\n        const n = i.join();\n        let o = s.get(n);\n        if (!o) o = {\n            resolver: je(e, i),\n            subPrefixes: i.filter((t)=>!t.toLowerCase().includes(\"hover\"))\n        }, s.set(n, o);\n        return o;\n    }\n    const _n = (t)=>o(t) && Object.getOwnPropertyNames(t).some((e)=>S(t[e]));\n    const yn = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"chartArea\"\n    ];\n    function vn(t, e) {\n        return \"top\" === t || \"bottom\" === t || -1 === yn.indexOf(t) && \"x\" === e;\n    }\n    function Mn(t, e) {\n        return function(i, s) {\n            return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t];\n        };\n    }\n    function wn(t) {\n        const e = t.chart, i = e.options.animation;\n        e.notifyPlugins(\"afterRender\"), d(i && i.onComplete, [\n            t\n        ], e);\n    }\n    function kn(t) {\n        const e = t.chart, i = e.options.animation;\n        d(i && i.onProgress, [\n            t\n        ], e);\n    }\n    function Sn(t) {\n        return fe() && \"string\" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;\n    }\n    const Pn = {}, Dn = (t)=>{\n        const e = Sn(t);\n        return Object.values(Pn).filter((t)=>t.canvas === e).pop();\n    };\n    function Cn(t, e, i) {\n        const s = Object.keys(t);\n        for (const n of s){\n            const s = +n;\n            if (s >= e) {\n                const o = t[n];\n                delete t[n], (i > 0 || s > e) && (t[s + i] = o);\n            }\n        }\n    }\n    function On(t, e, i) {\n        return t.options.clip ? t[i] : e[i];\n    }\n    class An {\n        static defaults = ue;\n        static instances = Pn;\n        static overrides = re;\n        static registry = en;\n        static version = \"4.4.8\";\n        static getChart = Dn;\n        static register(...t) {\n            en.add(...t), Tn();\n        }\n        static unregister(...t) {\n            en.remove(...t), Tn();\n        }\n        constructor(t, e){\n            const s = this.config = new xn(e), n = Sn(t), o = Dn(n);\n            if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n            const a = s.createResolver(s.chartOptionScopes(), this.getContext());\n            this.platform = new (s.platform || ks(n)), this.platform.updateConfig(s);\n            const r = this.platform.acquireContext(n, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width;\n            this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t)=>this.update(t), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (bt.listen(this, \"complete\", wn), bt.listen(this, \"progress\", kn), this._initialize(), this.attached && this.update()) : console.error(\"Failed to create chart: can't acquire context from the given item\");\n        }\n        get aspectRatio() {\n            const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this;\n            return s(t) ? e && o ? o : n ? i / n : null : t;\n        }\n        get data() {\n            return this.config.data;\n        }\n        set data(t) {\n            this.config.data = t;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(t) {\n            this.config.options = t;\n        }\n        get registry() {\n            return en;\n        }\n        _initialize() {\n            return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n        }\n        clear() {\n            return Te(this.canvas, this.ctx), this;\n        }\n        stop() {\n            return bt.stop(this), this;\n        }\n        resize(t, e) {\n            bt.running(this) ? this._resizeBeforeDraw = {\n                width: t,\n                height: e\n            } : this._resize(t, e);\n        }\n        _resize(t, e) {\n            const i = this.options, s = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, t, e, n), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), r = this.width ? \"resize\" : \"attach\";\n            this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) && (this.notifyPlugins(\"resize\", {\n                size: o\n            }), d(i.onResize, [\n                this,\n                o\n            ], this), this.attached && this._doResize(r) && this.render());\n        }\n        ensureScalesHaveIDs() {\n            u(this.options.scales || {}, (t, e)=>{\n                t.id = e;\n            });\n        }\n        buildOrUpdateScales() {\n            const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((t, e)=>(t[e] = !1, t), {});\n            let n = [];\n            e && (n = n.concat(Object.keys(e).map((t)=>{\n                const i = e[t], s = ln(t, i), n = \"r\" === s, o = \"x\" === s;\n                return {\n                    options: i,\n                    dposition: n ? \"chartArea\" : o ? \"bottom\" : \"left\",\n                    dtype: n ? \"radialLinear\" : o ? \"category\" : \"linear\"\n                };\n            }))), u(n, (e)=>{\n                const n = e.options, o = n.id, a = ln(o, n), r = l(n.type, e.dtype);\n                void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;\n                let h = null;\n                if (o in i && i[o].type === r) h = i[o];\n                else h = new (en.getScale(r))({\n                    id: o,\n                    type: r,\n                    ctx: this.ctx,\n                    chart: this\n                }), i[h.id] = h;\n                h.init(n, t);\n            }), u(s, (t, e)=>{\n                t || delete i[e];\n            }), u(i, (t)=>{\n                as.configure(this, t, t.options), as.addBox(this, t);\n            });\n        }\n        _updateMetasets() {\n            const t = this._metasets, e = this.data.datasets.length, i = t.length;\n            if (t.sort((t, e)=>t.index - e.index), i > e) {\n                for(let t = e; t < i; ++t)this._destroyDatasetMeta(t);\n                t.splice(e, i - e);\n            }\n            this._sortedMetasets = t.slice(0).sort(Mn(\"order\", \"index\"));\n        }\n        _removeUnreferencedMetasets() {\n            const { _metasets: t, data: { datasets: e } } = this;\n            t.length > e.length && delete this._stacks, t.forEach((t, i)=>{\n                0 === e.filter((e)=>e === t._dataset).length && this._destroyDatasetMeta(i);\n            });\n        }\n        buildOrUpdateControllers() {\n            const t = [], e = this.data.datasets;\n            let i, s;\n            for(this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++){\n                const s = e[i];\n                let n = this.getDatasetMeta(i);\n                const o = s.type || this.config.type;\n                if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = \"\" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();\n                else {\n                    const e = en.getController(o), { datasetElementType: s, dataElementType: a } = ue.datasets[o];\n                    Object.assign(e, {\n                        dataElementType: en.getElement(a),\n                        datasetElementType: s && en.getElement(s)\n                    }), n.controller = new e(this, i), t.push(n.controller);\n                }\n            }\n            return this._updateMetasets(), t;\n        }\n        _resetElements() {\n            u(this.data.datasets, (t, e)=>{\n                this.getDatasetMeta(e).controller.reset();\n            }, this);\n        }\n        reset() {\n            this._resetElements(), this.notifyPlugins(\"reset\");\n        }\n        update(t) {\n            const e = this.config;\n            e.update();\n            const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;\n            if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(\"beforeUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) return;\n            const n = this.buildOrUpdateControllers();\n            this.notifyPlugins(\"beforeElementsUpdate\");\n            let o = 0;\n            for(let t = 0, e = this.data.datasets.length; t < e; t++){\n                const { controller: e } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);\n                e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o);\n            }\n            o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t)=>{\n                t.reset();\n            }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n                mode: t\n            }), this._layers.sort(Mn(\"z\", \"_idx\"));\n            const { _active: a, _lastEvent: r } = this;\n            r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n        }\n        _updateScales() {\n            u(this.scales, (t)=>{\n                as.removeBox(this, t);\n            }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n        }\n        _checkEventBindings() {\n            const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);\n            P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents());\n        }\n        _updateHiddenIndices() {\n            const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n            for (const { method: i, start: s, count: n } of e)Cn(t, s, \"_removeElements\" === i ? -n : n);\n        }\n        _getUniformDataChanges() {\n            const t = this._dataChanges;\n            if (!t || !t.length) return;\n            this._dataChanges = [];\n            const e = this.data.datasets.length, i = (e)=>new Set(t.filter((t)=>t[0] === e).map((t, e)=>e + \",\" + t.splice(1).join(\",\"))), s = i(0);\n            for(let t = 1; t < e; t++)if (!P(s, i(t))) return;\n            return Array.from(s).map((t)=>t.split(\",\")).map((t)=>({\n                    method: t[1],\n                    start: +t[2],\n                    count: +t[3]\n                }));\n        }\n        _updateLayout(t) {\n            if (!1 === this.notifyPlugins(\"beforeLayout\", {\n                cancelable: !0\n            })) return;\n            as.update(this, this.width, this.height, t);\n            const e = this.chartArea, i = e.width <= 0 || e.height <= 0;\n            this._layers = [], u(this.boxes, (t)=>{\n                i && \"chartArea\" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()));\n            }, this), this._layers.forEach((t, e)=>{\n                t._idx = e;\n            }), this.notifyPlugins(\"afterLayout\");\n        }\n        _updateDatasets(t) {\n            if (!1 !== this.notifyPlugins(\"beforeDatasetsUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) {\n                for(let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure();\n                for(let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, S(t) ? t({\n                    datasetIndex: e\n                }) : t);\n                this.notifyPlugins(\"afterDatasetsUpdate\", {\n                    mode: t\n                });\n            }\n        }\n        _updateDataset(t, e) {\n            const i = this.getDatasetMeta(t), s = {\n                meta: i,\n                index: t,\n                mode: e,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetUpdate\", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", s));\n        }\n        render() {\n            !1 !== this.notifyPlugins(\"beforeRender\", {\n                cancelable: !0\n            }) && (bt.has(this) ? this.attached && !bt.running(this) && bt.start(this) : (this.draw(), wn({\n                chart: this\n            })));\n        }\n        draw() {\n            let t;\n            if (this._resizeBeforeDraw) {\n                const { width: t, height: e } = this._resizeBeforeDraw;\n                this._resizeBeforeDraw = null, this._resize(t, e);\n            }\n            if (this.clear(), this.width <= 0 || this.height <= 0) return;\n            if (!1 === this.notifyPlugins(\"beforeDraw\", {\n                cancelable: !0\n            })) return;\n            const e = this._layers;\n            for(t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea);\n            for(this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea);\n            this.notifyPlugins(\"afterDraw\");\n        }\n        _getSortedDatasetMetas(t) {\n            const e = this._sortedMetasets, i = [];\n            let s, n;\n            for(s = 0, n = e.length; s < n; ++s){\n                const n = e[s];\n                t && !n.visible || i.push(n);\n            }\n            return i;\n        }\n        getSortedVisibleDatasetMetas() {\n            return this._getSortedDatasetMetas(!0);\n        }\n        _drawDatasets() {\n            if (!1 === this.notifyPlugins(\"beforeDatasetsDraw\", {\n                cancelable: !0\n            })) return;\n            const t = this.getSortedVisibleDatasetMetas();\n            for(let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]);\n            this.notifyPlugins(\"afterDatasetsDraw\");\n        }\n        _drawDataset(t) {\n            const e = this.ctx, i = t._clip, s = !i.disabled, n = function(t, e) {\n                const { xScale: i, yScale: s } = t;\n                return i && s ? {\n                    left: On(i, e, \"left\"),\n                    right: On(i, e, \"right\"),\n                    top: On(s, e, \"top\"),\n                    bottom: On(s, e, \"bottom\")\n                } : e;\n            }(t, this.chartArea), o = {\n                meta: t,\n                index: t.index,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetDraw\", o) && (s && Ie(e, {\n                left: !1 === i.left ? 0 : n.left - i.left,\n                right: !1 === i.right ? this.width : n.right + i.right,\n                top: !1 === i.top ? 0 : n.top - i.top,\n                bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\n            }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", o));\n        }\n        isPointInArea(t) {\n            return Re(t, this.chartArea, this._minPadding);\n        }\n        getElementsAtEventForMode(t, e, i, s) {\n            const n = Xi.modes[e];\n            return \"function\" == typeof n ? n(this, t, i, s) : [];\n        }\n        getDatasetMeta(t) {\n            const e = this.data.datasets[t], i = this._metasets;\n            let s = i.filter((t)=>t && t._dataset === e).pop();\n            return s || (s = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: e && e.order || 0,\n                index: t,\n                _dataset: e,\n                _parsed: [],\n                _sorted: !1\n            }, i.push(s)), s;\n        }\n        getContext() {\n            return this.$context || (this.$context = Ci(null, {\n                chart: this,\n                type: \"chart\"\n            }));\n        }\n        getVisibleDatasetCount() {\n            return this.getSortedVisibleDatasetMetas().length;\n        }\n        isDatasetVisible(t) {\n            const e = this.data.datasets[t];\n            if (!e) return !1;\n            const i = this.getDatasetMeta(t);\n            return \"boolean\" == typeof i.hidden ? !i.hidden : !e.hidden;\n        }\n        setDatasetVisibility(t, e) {\n            this.getDatasetMeta(t).hidden = !e;\n        }\n        toggleDataVisibility(t) {\n            this._hiddenIndices[t] = !this._hiddenIndices[t];\n        }\n        getDataVisibility(t) {\n            return !this._hiddenIndices[t];\n        }\n        _updateVisibility(t, e, i) {\n            const s = i ? \"show\" : \"hide\", n = this.getDatasetMeta(t), o = n.controller._resolveAnimations(void 0, s);\n            k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\n                visible: i\n            }), this.update((e)=>e.datasetIndex === t ? s : void 0));\n        }\n        hide(t, e) {\n            this._updateVisibility(t, e, !1);\n        }\n        show(t, e) {\n            this._updateVisibility(t, e, !0);\n        }\n        _destroyDatasetMeta(t) {\n            const e = this._metasets[t];\n            e && e.controller && e.controller._destroy(), delete this._metasets[t];\n        }\n        _stop() {\n            let t, e;\n            for(this.stop(), bt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t);\n        }\n        destroy() {\n            this.notifyPlugins(\"beforeDestroy\");\n            const { canvas: t, ctx: e } = this;\n            this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins(\"afterDestroy\");\n        }\n        toBase64Image(...t) {\n            return this.canvas.toDataURL(...t);\n        }\n        bindEvents() {\n            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n        }\n        bindUserEvents() {\n            const t = this._listeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (t, e, i)=>{\n                t.offsetX = e, t.offsetY = i, this._eventHandler(t);\n            };\n            u(this.options.events, (t)=>i(t, s));\n        }\n        bindResponsiveEvents() {\n            this._responsiveListeners || (this._responsiveListeners = {});\n            const t = this._responsiveListeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (i, s)=>{\n                t[i] && (e.removeEventListener(this, i, s), delete t[i]);\n            }, n = (t, e)=>{\n                this.canvas && this.resize(t, e);\n            };\n            let o;\n            const a = ()=>{\n                s(\"attach\", a), this.attached = !0, this.resize(), i(\"resize\", n), i(\"detach\", o);\n            };\n            o = ()=>{\n                this.attached = !1, s(\"resize\", n), this._stop(), this._resize(0, 0), i(\"attach\", a);\n            }, e.isAttached(this.canvas) ? a() : o();\n        }\n        unbindEvents() {\n            u(this._listeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._listeners = {}, u(this._responsiveListeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._responsiveListeners = void 0;\n        }\n        updateHoverStyle(t, e, i) {\n            const s = i ? \"set\" : \"remove\";\n            let n, o, a, r;\n            for(\"dataset\" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[\"_\" + s + \"DatasetHoverStyle\"]()), a = 0, r = t.length; a < r; ++a){\n                o = t[a];\n                const e = o && this.getDatasetMeta(o.datasetIndex).controller;\n                e && e[s + \"HoverStyle\"](o.element, o.datasetIndex, o.index);\n            }\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t) {\n            const e = this._active || [], i = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.getDatasetMeta(t);\n                if (!i) throw new Error(\"No dataset found at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            });\n            !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));\n        }\n        notifyPlugins(t, e, i) {\n            return this._plugins.notify(this, t, e, i);\n        }\n        isPluginEnabled(t) {\n            return 1 === this._plugins._cache.filter((e)=>e.plugin.id === t).length;\n        }\n        _updateHoverStyles(t, e, i) {\n            const s = this.options.hover, n = (t, e)=>t.filter((t)=>!e.some((e)=>t.datasetIndex === e.datasetIndex && t.index === e.index)), o = n(e, t), a = i ? t : n(t, e);\n            o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);\n        }\n        _eventHandler(t, e) {\n            const i = {\n                event: t,\n                replay: e,\n                cancelable: !0,\n                inChartArea: this.isPointInArea(t)\n            }, s = (e)=>(e.options.events || this.options.events).includes(t.native.type);\n            if (!1 === this.notifyPlugins(\"beforeEvent\", i, s)) return;\n            const n = this._handleEvent(t, e, i.inChartArea);\n            return i.cancelable = !1, this.notifyPlugins(\"afterEvent\", i, s), (n || i.changed) && this.render(), this;\n        }\n        _handleEvent(t, e, i) {\n            const { _active: s = [], options: n } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {\n                return i && \"mouseout\" !== t.type ? s ? e : t : null;\n            }(t, this._lastEvent, i, r);\n            i && (this._lastEvent = null, d(n.onHover, [\n                t,\n                a,\n                this\n            ], this), r && d(n.onClick, [\n                t,\n                a,\n                this\n            ], this));\n            const h = !f(a, s);\n            return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h;\n        }\n        _getActiveElements(t, e, i, s) {\n            if (\"mouseout\" === t.type) return [];\n            if (!i) return e;\n            const n = this.options.hover;\n            return this.getElementsAtEventForMode(t, n.mode, n, s);\n        }\n    }\n    function Tn() {\n        return u(An.instances, (t)=>t._plugins.invalidate());\n    }\n    function Ln() {\n        throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n    }\n    class En {\n        static override(t) {\n            Object.assign(En.prototype, t);\n        }\n        options;\n        constructor(t){\n            this.options = t || {};\n        }\n        init() {}\n        formats() {\n            return Ln();\n        }\n        parse() {\n            return Ln();\n        }\n        format() {\n            return Ln();\n        }\n        add() {\n            return Ln();\n        }\n        diff() {\n            return Ln();\n        }\n        startOf() {\n            return Ln();\n        }\n        endOf() {\n            return Ln();\n        }\n    }\n    var Rn = {\n        _date: En\n    };\n    function In(t) {\n        const e = t.iScale, i = function(t, e) {\n            if (!t._cache.$bar) {\n                const i = t.getMatchingVisibleMetas(e);\n                let s = [];\n                for(let e = 0, n = i.length; e < n; e++)s = s.concat(i[e].controller.getAllParsedValues(t));\n                t._cache.$bar = lt(s.sort((t, e)=>t - e));\n            }\n            return t._cache.$bar;\n        }(e, t.type);\n        let s, n, o, a, r = e._length;\n        const l = ()=>{\n            32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);\n        };\n        for(s = 0, n = i.length; s < n; ++s)o = e.getPixelForValue(i[s]), l();\n        for(a = void 0, s = 0, n = e.ticks.length; s < n; ++s)o = e.getPixelForTick(s), l();\n        return r;\n    }\n    function zn(t, e, i, s) {\n        return n(t) ? function(t, e, i, s) {\n            const n = i.parse(t[0], s), o = i.parse(t[1], s), a = Math.min(n, o), r = Math.max(n, o);\n            let l = a, h = r;\n            Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {\n                barStart: l,\n                barEnd: h,\n                start: n,\n                end: o,\n                min: a,\n                max: r\n            };\n        }(t, e, i, s) : e[i.axis] = i.parse(t, s), e;\n    }\n    function Fn(t, e, i, s) {\n        const n = t.iScale, o = t.vScale, a = n.getLabels(), r = n === o, l = [];\n        let h, c, d, u;\n        for(h = i, c = i + s; h < c; ++h)u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));\n        return l;\n    }\n    function Vn(t) {\n        return t && void 0 !== t.barStart && void 0 !== t.barEnd;\n    }\n    function Bn(t, e, i, s) {\n        let n = e.borderSkipped;\n        const o = {};\n        if (!n) return void (t.borderSkipped = o);\n        if (!0 === n) return void (t.borderSkipped = {\n            top: !0,\n            right: !0,\n            bottom: !0,\n            left: !0\n        });\n        const { start: a, end: r, reverse: l, top: h, bottom: c } = function(t) {\n            let e, i, s, n, o;\n            return t.horizontal ? (e = t.base > t.x, i = \"left\", s = \"right\") : (e = t.base < t.y, i = \"bottom\", s = \"top\"), e ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n                start: i,\n                end: s,\n                reverse: e,\n                top: n,\n                bottom: o\n            };\n        }(t);\n        \"middle\" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o;\n    }\n    function Wn(t, e, i, s) {\n        var n, o, a;\n        return s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t;\n    }\n    function Nn(t, e, i) {\n        return \"start\" === t ? e : \"end\" === t ? i : t;\n    }\n    function Hn(t, { inflateAmount: e }, i) {\n        t.inflateAmount = \"auto\" === e ? 1 === i ? .33 : 0 : e;\n    }\n    class jn extends Ns {\n        static id = \"doughnut\";\n        static defaults = {\n            datasetElementType: !1,\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !1\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"circumference\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\",\n                        \"startAngle\",\n                        \"x\",\n                        \"y\",\n                        \"offset\",\n                        \"borderWidth\",\n                        \"spacing\"\n                    ]\n                }\n            },\n            cutout: \"50%\",\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\",\n            spacing: 0,\n            indexAxis: \"r\"\n        };\n        static descriptors = {\n            _scriptable: (t)=>\"spacing\" !== t,\n            _indexable: (t)=>\"spacing\" !== t && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\")\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n        }\n        linkScales() {}\n        parse(t, e) {\n            const i = this.getDataset().data, s = this._cachedMeta;\n            if (!1 === this._parsing) s._parsed = i;\n            else {\n                let n, a, r = (t)=>+i[t];\n                if (o(i[t])) {\n                    const { key: t = \"value\" } = this._parsing;\n                    r = (e)=>+M(i[e], t);\n                }\n                for(n = t, a = t + e; n < a; ++n)s._parsed[n] = r(n);\n            }\n        }\n        _getRotation() {\n            return $(this.options.rotation - 90);\n        }\n        _getCircumference() {\n            return $(this.options.circumference);\n        }\n        _getRotationExtents() {\n            let t = O, e = -O;\n            for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), o = s._getCircumference();\n                t = Math.min(t, n), e = Math.max(e, n + o);\n            }\n            return {\n                rotation: t,\n                circumference: e - t\n            };\n        }\n        update(t) {\n            const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), r = Math.min(h(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: g, offsetX: p, offsetY: m } = function(t, e, i) {\n                let s = 1, n = 1, o = 0, a = 0;\n                if (e < O) {\n                    const r = t, l = r + e, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, s)=>Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i), g = (t, e, s)=>Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i), p = f(0, h, d), m = f(E, c, u), x = g(C, h, d), b = g(C + E, c, u);\n                    s = (p - x) / 2, n = (m - b) / 2, o = -(p + x) / 2, a = -(m + b) / 2;\n                }\n                return {\n                    ratioX: s,\n                    ratioY: n,\n                    offsetX: o,\n                    offsetY: a\n                };\n            }(u, d, r), x = (i.width - o) / f, b = (i.height - o) / g, _ = Math.max(Math.min(x, b) / 2, 0), y = c(this.options.radius, _), v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n            this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t);\n        }\n        _circumference(t, e) {\n            const i = this.options, s = this._cachedMeta, n = this._getCircumference();\n            return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O);\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.chartArea, r = o.options.animation, l = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, c = n && r.animateScale, d = c ? 0 : this.innerRadius, u = c ? 0 : this.outerRadius, { sharedOptions: f, includeOptions: g } = this._getSharedOptions(e, s);\n            let p, m = this._getRotation();\n            for(p = 0; p < e; ++p)m += this._circumference(p, n);\n            for(p = e; p < e + i; ++p){\n                const e = this._circumference(p, n), i = t[p], o = {\n                    x: l + this.offsetX,\n                    y: h + this.offsetY,\n                    startAngle: m,\n                    endAngle: m + e,\n                    circumference: e,\n                    outerRadius: u,\n                    innerRadius: d\n                };\n                g && (o.options = f || this.resolveDataElementOptions(p, i.active ? \"active\" : s)), m += e, this.updateElement(i, p, o, s);\n            }\n        }\n        calculateTotal() {\n            const t = this._cachedMeta, e = t.data;\n            let i, s = 0;\n            for(i = 0; i < e.length; i++){\n                const n = t._parsed[i];\n                null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n));\n            }\n            return s;\n        }\n        calculateCircumference(t) {\n            const e = this._cachedMeta.total;\n            return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t], i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        getMaxBorderWidth(t) {\n            let e = 0;\n            const i = this.chart;\n            let s, n, o, a, r;\n            if (!t) {\n                for(s = 0, n = i.data.datasets.length; s < n; ++s)if (i.isDatasetVisible(s)) {\n                    o = i.getDatasetMeta(s), t = o.data, a = o.controller;\n                    break;\n                }\n            }\n            if (!t) return 0;\n            for(s = 0, n = t.length; s < n; ++s)r = a.resolveDataElementOptions(s), \"inner\" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\n            return e;\n        }\n        getMaxOffset(t) {\n            let e = 0;\n            for(let i = 0, s = t.length; i < s; ++i){\n                const t = this.resolveDataElementOptions(i);\n                e = Math.max(e, t.offset || 0, t.hoverOffset || 0);\n            }\n            return e;\n        }\n        _getRingWeightOffset(t) {\n            let e = 0;\n            for(let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));\n            return e;\n        }\n        _getRingWeight(t) {\n            return Math.max(l(this.chart.data.datasets[t].weight, 1), 0);\n        }\n        _getVisibleDatasetWeightTotal() {\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n        }\n    }\n    class $n extends Ns {\n        static id = \"polarArea\";\n        static defaults = {\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !0\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"startAngle\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\"\n                    ]\n                }\n            },\n            indexAxis: \"r\",\n            startAngle: 0\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: \"radialLinear\",\n                    angleLines: {\n                        display: !1\n                    },\n                    beginAtZero: !0,\n                    grid: {\n                        circular: !0\n                    },\n                    pointLabels: {\n                        display: !1\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t].r, i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        parseObjectData(t, e, i, s) {\n            return ii.bind(this)(t, e, i, s);\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this._updateRadius(), this.updateElements(e, 0, e.length, t);\n        }\n        getMinMax() {\n            const t = this._cachedMeta, e = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n            return t.data.forEach((t, i)=>{\n                const s = this.getParsed(i).r;\n                !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s));\n            }), e;\n        }\n        _updateRadius() {\n            const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), n = Math.max(s / 2, 0), o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();\n            this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o;\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.options.animation, r = this._cachedMeta.rScale, l = r.xCenter, h = r.yCenter, c = r.getIndexAngle(0) - .5 * C;\n            let d, u = c;\n            const f = 360 / this.countVisibleElements();\n            for(d = 0; d < e; ++d)u += this._computeAngle(d, s, f);\n            for(d = e; d < e + i; d++){\n                const e = t[d];\n                let i = u, g = u + this._computeAngle(d, s, f), p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\n                u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));\n                const m = {\n                    x: l,\n                    y: h,\n                    innerRadius: 0,\n                    outerRadius: p,\n                    startAngle: i,\n                    endAngle: g,\n                    options: this.resolveDataElementOptions(d, e.active ? \"active\" : s)\n                };\n                this.updateElement(e, d, m, s);\n            }\n        }\n        countVisibleElements() {\n            const t = this._cachedMeta;\n            let e = 0;\n            return t.data.forEach((t, i)=>{\n                !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++;\n            }), e;\n        }\n        _computeAngle(t, e, i) {\n            return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0;\n        }\n    }\n    var Yn = Object.freeze({\n        __proto__: null,\n        BarController: class extends Ns {\n            static id = \"bar\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"bar\",\n                categoryPercentage: .8,\n                barPercentage: .9,\n                grouped: !0,\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"base\",\n                            \"width\",\n                            \"height\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\",\n                        offset: !0,\n                        grid: {\n                            offset: !0\n                        }\n                    },\n                    _value_: {\n                        type: \"linear\",\n                        beginAtZero: !0\n                    }\n                }\n            };\n            parsePrimitiveData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseArrayData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseObjectData(t, e, i, s) {\n                const { iScale: n, vScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = \"x\" === n.axis ? a : r, h = \"x\" === o.axis ? a : r, c = [];\n                let d, u, f, g;\n                for(d = i, u = i + s; d < u; ++d)g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d));\n                return c;\n            }\n            updateRangeFromParsed(t, e, i, s) {\n                super.updateRangeFromParsed(t, e, i, s);\n                const n = i._custom;\n                n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));\n            }\n            getMaxOverflow() {\n                return 0;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), o = n._custom, a = Vn(o) ? \"[\" + o.start + \", \" + o.end + \"]\" : \"\" + s.getLabelForValue(n[s.axis]);\n                return {\n                    label: \"\" + i.getLabelForValue(n[i.axis]),\n                    value: a\n                };\n            }\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n                this._cachedMeta.stack = this.getDataset().stack;\n            }\n            update(t) {\n                const e = this._cachedMeta;\n                this.updateElements(e.data, 0, e.data.length, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n                for(let f = e; f < e + i; f++){\n                    const e = this.getParsed(f), i = o || s(e[r.axis]) ? {\n                        base: l,\n                        head: l\n                    } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), p = (e._stacks || {})[r.axis], m = {\n                        horizontal: h,\n                        base: i.base,\n                        enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom,\n                        x: h ? i.head : g.center,\n                        y: h ? g.center : i.head,\n                        height: h ? g.size : Math.abs(i.size),\n                        width: h ? Math.abs(i.size) : g.size\n                    };\n                    u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n                    const x = m.options || t[f].options;\n                    Bn(m, x, p, a), Hn(m, x, c.ratio), this.updateElement(t[f], f, m, n);\n                }\n            }\n            _getStacks(t, e) {\n                const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t)=>t.controller.options.grouped), o = i.options.stacked, a = [], r = this._cachedMeta.controller.getParsed(e), l = r && r[i.axis], h = (t)=>{\n                    const e = t._parsed.find((t)=>t[i.axis] === l), n = e && e[t.vScale.axis];\n                    if (s(n) || isNaN(n)) return !0;\n                };\n                for (const i of n)if ((void 0 === e || !h(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;\n                return a.length || a.push(void 0), a;\n            }\n            _getStackCount(t) {\n                return this._getStacks(void 0, t).length;\n            }\n            _getStackIndex(t, e, i) {\n                const s = this._getStacks(t, i), n = void 0 !== e ? s.indexOf(e) : -1;\n                return -1 === n ? s.length - 1 : n;\n            }\n            _getRuler() {\n                const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];\n                let n, o;\n                for(n = 0, o = e.data.length; n < o; ++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\n                const a = t.barThickness;\n                return {\n                    min: a || In(e),\n                    pixels: s,\n                    start: i._startPixel,\n                    end: i._endPixel,\n                    stackCount: this._getStackCount(),\n                    scale: i,\n                    grouped: t.grouped,\n                    ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n                };\n            }\n            _calculateBarValuePixels(t) {\n                const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);\n                let d, u, f = l[e.axis], g = 0, p = i ? this.applyStack(e, l, i) : f;\n                p !== f && (g = p - f, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f);\n                const m = s(o) || c ? g : o;\n                let x = e.getPixelForValue(m);\n                if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : x, u = d - x, Math.abs(u) < a) {\n                    u = function(t, e, i) {\n                        return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);\n                    }(u, e, r) * a, f === r && (x -= u / 2);\n                    const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), o = Math.min(t, s), h = Math.max(t, s);\n                    x = Math.max(Math.min(x, h), o), d = x + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(x));\n                }\n                if (x === e.getPixelForValue(r)) {\n                    const t = F(u) * e.getLineWidthForValue(r) / 2;\n                    x += t, u -= t;\n                }\n                return {\n                    size: u,\n                    base: x,\n                    head: d,\n                    center: d + u / 2\n                };\n            }\n            _calculateBarIndexPixels(t, e) {\n                const i = e.scale, n = this.options, o = n.skipNull, a = l(n.maxBarThickness, 1 / 0);\n                let r, h;\n                if (e.grouped) {\n                    const i = o ? this._getStackCount(t) : e.stackCount, l = \"flex\" === n.barThickness ? function(t, e, i, s) {\n                        const n = e.pixels, o = n[t];\n                        let a = t > 0 ? n[t - 1] : null, r = t < n.length - 1 ? n[t + 1] : null;\n                        const l = i.categoryPercentage;\n                        null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);\n                        const h = o - (o - Math.min(a, r)) / 2 * l;\n                        return {\n                            chunk: Math.abs(r - a) / 2 * l / s,\n                            ratio: i.barPercentage,\n                            start: h\n                        };\n                    }(t, e, n, i) : function(t, e, i, n) {\n                        const o = i.barThickness;\n                        let a, r;\n                        return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {\n                            chunk: a / n,\n                            ratio: r,\n                            start: e.pixels[t] - a / 2\n                        };\n                    }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n                    r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio);\n                } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);\n                return {\n                    base: r - h / 2,\n                    head: r + h / 2,\n                    center: r,\n                    size: h\n                };\n            }\n            draw() {\n                const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;\n                let n = 0;\n                for(; n < s; ++n)null === this.getParsed(n)[e.axis] || i[n].hidden || i[n].draw(this._ctx);\n            }\n        },\n        BubbleController: class extends Ns {\n            static id = \"bubble\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"borderWidth\",\n                            \"radius\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n            }\n            parsePrimitiveData(t, e, i, s) {\n                const n = super.parsePrimitiveData(t, e, i, s);\n                for(let t = 0; t < n.length; t++)n[t]._custom = this.resolveDataElementOptions(t + i).radius;\n                return n;\n            }\n            parseArrayData(t, e, i, s) {\n                const n = super.parseArrayData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            parseObjectData(t, e, i, s) {\n                const n = super.parseObjectData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta.data;\n                let e = 0;\n                for(let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);\n                return e > 0 && e;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y), l = o._custom;\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + (l ? \", \" + l : \"\") + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta.data;\n                this.updateElements(e, 0, e.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = \"reset\" === s, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: r, includeOptions: l } = this._getSharedOptions(e, s), h = o.axis, c = a.axis;\n                for(let d = e; d < e + i; d++){\n                    const e = t[d], i = !n && this.getParsed(d), u = {}, f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]), g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\n                    u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? \"active\" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s);\n                }\n            }\n            resolveDataElementOptions(t, e) {\n                const i = this.getParsed(t);\n                let s = super.resolveDataElementOptions(t, e);\n                s.$shared && (s = Object.assign({}, s, {\n                    $shared: !1\n                }));\n                const n = s.radius;\n                return \"active\" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s;\n            }\n        },\n        DoughnutController: jn,\n        LineController: class extends Ns {\n            static id = \"line\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                showLine: !0,\n                spanGaps: !1\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\"\n                    },\n                    _value_: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n            }\n            update(t) {\n                const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: n } = e, o = this.chart._animationsDisabled;\n                let { start: a, count: r } = pt(e, s, o);\n                this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\n                const l = this.resolveDatasetElementOptions(t);\n                this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\n                    animated: !o,\n                    options: l\n                }, t), this.updateElements(s, a, r, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, { sharedOptions: c, includeOptions: d } = this._getSharedOptions(e, n), u = a.axis, f = r.axis, { spanGaps: g, segment: p } = this.options, m = N(g) ? g : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || \"none\" === n, b = e + i, _ = t.length;\n                let y = e > 0 && this.getParsed(e - 1);\n                for(let i = 0; i < _; ++i){\n                    const g = t[i], _ = x ? g : {};\n                    if (i < e || i >= b) {\n                        _.skip = !0;\n                        continue;\n                    }\n                    const v = this.getParsed(i), M = s(v[f]), w = _[u] = a.getPixelForValue(v[u], i), k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);\n                    _.skip = isNaN(w) || isNaN(k) || M, _.stop = i > 0 && Math.abs(v[u] - y[u]) > m, p && (_.parsed = v, _.raw = h.data[i]), d && (_.options = c || this.resolveDataElementOptions(i, g.active ? \"active\" : n)), x || this.updateElement(g, i, _, n), y = v;\n                }\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || [];\n                if (!s.length) return i;\n                const n = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\n                return Math.max(i, n, o) / 2;\n            }\n            draw() {\n                const t = this._cachedMeta;\n                t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n            }\n        },\n        PieController: class extends jn {\n            static id = \"pie\";\n            static defaults = {\n                cutout: 0,\n                rotation: 0,\n                circumference: 360,\n                radius: \"100%\"\n            };\n        },\n        PolarAreaController: $n,\n        RadarController: class extends Ns {\n            static id = \"radar\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                indexAxis: \"r\",\n                showLine: !0,\n                elements: {\n                    line: {\n                        fill: \"start\"\n                    }\n                }\n            };\n            static overrides = {\n                aspectRatio: 1,\n                scales: {\n                    r: {\n                        type: \"radialLinear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta.vScale, i = this.getParsed(t);\n                return {\n                    label: e.getLabels()[t],\n                    value: \"\" + e.getLabelForValue(i[e.axis])\n                };\n            }\n            parseObjectData(t, e, i, s) {\n                return ii.bind(this)(t, e, i, s);\n            }\n            update(t) {\n                const e = this._cachedMeta, i = e.dataset, s = e.data || [], n = e.iScale.getLabels();\n                if (i.points = s, \"resize\" !== t) {\n                    const e = this.resolveDatasetElementOptions(t);\n                    this.options.showLine || (e.borderWidth = 0);\n                    const o = {\n                        _loop: !0,\n                        _fullLoop: n.length === s.length,\n                        options: e\n                    };\n                    this.updateElement(i, void 0, o, t);\n                }\n                this.updateElements(s, 0, s.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = this._cachedMeta.rScale, o = \"reset\" === s;\n                for(let a = e; a < e + i; a++){\n                    const e = t[a], i = this.resolveDataElementOptions(a, e.active ? \"active\" : s), r = n.getPointPositionForValue(a, this.getParsed(a).r), l = o ? n.xCenter : r.x, h = o ? n.yCenter : r.y, c = {\n                        x: l,\n                        y: h,\n                        angle: r.angle,\n                        skip: isNaN(l) || isNaN(h),\n                        options: i\n                    };\n                    this.updateElement(e, a, c, s);\n                }\n            }\n        },\n        ScatterController: class extends Ns {\n            static id = \"scatter\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                showLine: !1,\n                fill: !1\n            };\n            static overrides = {\n                interaction: {\n                    mode: \"point\"\n                },\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y);\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled;\n                let { start: n, count: o } = pt(e, i, s);\n                if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) {\n                    this.datasetElementType || this.addElements();\n                    const { dataset: n, _dataset: o } = e;\n                    n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\n                    const a = this.resolveDatasetElementOptions(t);\n                    a.segment = this.options.segment, this.updateElement(n, void 0, {\n                        animated: !s,\n                        options: a\n                    }, t);\n                } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n                this.updateElements(i, n, o, t);\n            }\n            addElements() {\n                const { showLine: t } = this.options;\n                !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), super.addElements();\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(c), u = this.includeOptions(n, d), f = a.axis, g = r.axis, { spanGaps: p, segment: m } = this.options, x = N(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || \"none\" === n;\n                let _ = e > 0 && this.getParsed(e - 1);\n                for(let c = e; c < e + i; ++c){\n                    const e = t[c], i = this.getParsed(c), p = b ? e : {}, y = s(i[g]), v = p[f] = a.getPixelForValue(i[f], c), M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);\n                    p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > x, m && (p.parsed = i, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? \"active\" : n)), b || this.updateElement(e, c, p, n), _ = i;\n                }\n                this.updateSharedOptions(d, n, c);\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.data || [];\n                if (!this.options.showLine) {\n                    let t = 0;\n                    for(let i = e.length - 1; i >= 0; --i)t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);\n                    return t > 0 && t;\n                }\n                const i = t.dataset, s = i.options && i.options.borderWidth || 0;\n                if (!e.length) return s;\n                const n = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n                return Math.max(s, n, o) / 2;\n            }\n        }\n    });\n    function Un(t, e, i, s) {\n        const n = vi(t.options.borderRadius, [\n            \"outerStart\",\n            \"outerEnd\",\n            \"innerStart\",\n            \"innerEnd\"\n        ]);\n        const o = (i - e) / 2, a = Math.min(o, s * e / 2), r = (t)=>{\n            const e = (i - Math.min(o, t)) * s / 2;\n            return J(t, 0, Math.min(o, e));\n        };\n        return {\n            outerStart: r(n.outerStart),\n            outerEnd: r(n.outerEnd),\n            innerStart: J(n.innerStart, 0, a),\n            innerEnd: J(n.innerEnd, 0, a)\n        };\n    }\n    function Xn(t, e, i, s) {\n        return {\n            x: i + t * Math.cos(e),\n            y: s + t * Math.sin(e)\n        };\n    }\n    function qn(t, e, i, s, n, o) {\n        const { x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;\n        let f = 0;\n        const g = n - l;\n        if (s) {\n            const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;\n            f = (g - (0 !== t ? g * t / (t + s) : g)) / 2;\n        }\n        const p = (g - Math.max(.001, g * d - i / C) / d) / 2, m = l + p + f, x = n - p - f, { outerStart: b, outerEnd: _, innerStart: y, innerEnd: v } = Un(e, u, d, x - m), M = d - b, w = d - _, k = m + b / M, S = x - _ / w, P = u + y, D = u + v, O = m + y / P, A = x - v / D;\n        if (t.beginPath(), o) {\n            const e = (k + S) / 2;\n            if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0) {\n                const e = Xn(w, S, a, r);\n                t.arc(e.x, e.y, _, S, x + E);\n            }\n            const i = Xn(D, x, a, r);\n            if (t.lineTo(i.x, i.y), v > 0) {\n                const e = Xn(D, A, a, r);\n                t.arc(e.x, e.y, v, x + E, A + Math.PI);\n            }\n            const s = (x - v / u + (m + y / u)) / 2;\n            if (t.arc(a, r, u, x - v / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0) {\n                const e = Xn(P, O, a, r);\n                t.arc(e.x, e.y, y, O + Math.PI, m - E);\n            }\n            const n = Xn(M, m, a, r);\n            if (t.lineTo(n.x, n.y), b > 0) {\n                const e = Xn(M, k, a, r);\n                t.arc(e.x, e.y, b, m - E, k);\n            }\n        } else {\n            t.moveTo(a, r);\n            const e = Math.cos(k) * d + a, i = Math.sin(k) * d + r;\n            t.lineTo(e, i);\n            const s = Math.cos(S) * d + a, n = Math.sin(S) * d + r;\n            t.lineTo(s, n);\n        }\n        t.closePath();\n    }\n    function Kn(t, e, i, s, n) {\n        const { fullCircles: o, startAngle: a, circumference: r, options: l } = e, { borderWidth: h, borderJoinStyle: c, borderDash: d, borderDashOffset: u } = l, f = \"inner\" === l.borderAlign;\n        if (!h) return;\n        t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || \"round\") : (t.lineWidth = h, t.lineJoin = c || \"bevel\");\n        let g = e.endAngle;\n        if (o) {\n            qn(t, e, i, s, g, n);\n            for(let e = 0; e < o; ++e)t.stroke();\n            isNaN(r) || (g = a + (r % O || O));\n        }\n        f && function(t, e, i) {\n            const { startAngle: s, pixelMargin: n, x: o, y: a, outerRadius: r, innerRadius: l } = e;\n            let h = n / r;\n            t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip();\n        }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke());\n    }\n    function Gn(t, e, i = e) {\n        t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor);\n    }\n    function Zn(t, e, i) {\n        t.lineTo(i.x, i.y);\n    }\n    function Jn(t, e, i = {}) {\n        const s = t.length, { start: n = 0, end: o = s - 1 } = i, { start: a, end: r } = e, l = Math.max(n, a), h = Math.min(o, r), c = n < a && o < a || n > r && o > r;\n        return {\n            count: s,\n            start: l,\n            loop: e.loop,\n            ilen: h < l && !c ? s + h - l : h - l\n        };\n    }\n    function Qn(t, e, i, s) {\n        const { points: n, options: o } = e, { count: a, start: r, loop: l, ilen: h } = Jn(n, i, s), c = function(t) {\n            return t.stepped ? Fe : t.tension || \"monotone\" === t.cubicInterpolationMode ? Ve : Zn;\n        }(o);\n        let d, u, f, { move: g = !0, reverse: p } = s || {};\n        for(d = 0; d <= h; ++d)u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\n        return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l;\n    }\n    function to(t, e, i, s) {\n        const n = e.points, { count: o, start: a, ilen: r } = Jn(n, i, s), { move: l = !0, reverse: h } = s || {};\n        let c, d, u, f, g, p, m = 0, x = 0;\n        const b = (t)=>(a + (h ? r - t : t)) % o, _ = ()=>{\n            f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p));\n        };\n        for(l && (d = n[b(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c){\n            if (d = n[b(c)], d.skip) continue;\n            const e = d.x, i = d.y, s = 0 | e;\n            s === u ? (i < f ? f = i : i > g && (g = i), m = (x * m + e) / ++x) : (_(), t.lineTo(e, i), u = s, x = 0, f = g = i), p = i;\n        }\n        _();\n    }\n    function eo(t) {\n        const e = t.options, i = e.borderDash && e.borderDash.length;\n        return !(t._decimated || t._loop || e.tension || \"monotone\" === e.cubicInterpolationMode || e.stepped || i) ? to : Qn;\n    }\n    const io = \"function\" == typeof Path2D;\n    function so(t, e, i, s) {\n        io && !e.options.segment ? function(t, e, i, s) {\n            let n = e._path;\n            n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Gn(t, e.options), t.stroke(n);\n        }(t, e, i, s) : function(t, e, i, s) {\n            const { segments: n, options: o } = e, a = eo(e);\n            for (const r of n)Gn(t, o, r.style), t.beginPath(), a(t, e, r, {\n                start: i,\n                end: i + s - 1\n            }) && t.closePath(), t.stroke();\n        }(t, e, i, s);\n    }\n    class no extends Hs {\n        static id = \"line\";\n        static defaults = {\n            borderCapStyle: \"butt\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: \"miter\",\n            borderWidth: 3,\n            capBezierPoints: !0,\n            cubicInterpolationMode: \"default\",\n            fill: !1,\n            spanGaps: !1,\n            stepped: !1,\n            tension: 0\n        };\n        static defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n        static descriptors = {\n            _scriptable: !0,\n            _indexable: (t)=>\"borderDash\" !== t && \"fill\" !== t\n        };\n        constructor(t){\n            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n        }\n        updateControlPoints(t, e) {\n            const i = this.options;\n            if ((i.tension || \"monotone\" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {\n                const s = i.spanGaps ? this._loop : this._fullLoop;\n                hi(this._points, i, t, s, e), this._pointsUpdated = !0;\n            }\n        }\n        set points(t) {\n            this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n        }\n        get points() {\n            return this._points;\n        }\n        get segments() {\n            return this._segments || (this._segments = zi(this, this.options.segment));\n        }\n        first() {\n            const t = this.segments, e = this.points;\n            return t.length && e[t[0].start];\n        }\n        last() {\n            const t = this.segments, e = this.points, i = t.length;\n            return i && e[t[i - 1].end];\n        }\n        interpolate(t, e) {\n            const i = this.options, s = t[e], n = this.points, o = Ii(this, {\n                property: e,\n                start: s,\n                end: s\n            });\n            if (!o.length) return;\n            const a = [], r = function(t) {\n                return t.stepped ? pi : t.tension || \"monotone\" === t.cubicInterpolationMode ? mi : gi;\n            }(i);\n            let l, h;\n            for(l = 0, h = o.length; l < h; ++l){\n                const { start: h, end: c } = o[l], d = n[h], u = n[c];\n                if (d === u) {\n                    a.push(d);\n                    continue;\n                }\n                const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);\n                f[e] = t[e], a.push(f);\n            }\n            return 1 === a.length ? a[0] : a;\n        }\n        pathSegment(t, e, i) {\n            return eo(this)(t, this, e, i);\n        }\n        path(t, e, i) {\n            const s = this.segments, n = eo(this);\n            let o = this._loop;\n            e = e || 0, i = i || this.points.length - e;\n            for (const a of s)o &= n(t, this, a, {\n                start: e,\n                end: e + i - 1\n            });\n            return !!o;\n        }\n        draw(t, e, i, s) {\n            const n = this.options || {};\n            (this.points || []).length && n.borderWidth && (t.save(), so(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n        }\n    }\n    function oo(t, e, i, s) {\n        const n = t.options, { [i]: o } = t.getProps([\n            i\n        ], s);\n        return Math.abs(e - o) < n.radius + n.hitRadius;\n    }\n    function ao(t, e) {\n        const { x: i, y: s, base: n, width: o, height: a } = t.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"width\",\n            \"height\"\n        ], e);\n        let r, l, h, c, d;\n        return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\n            left: r,\n            top: h,\n            right: l,\n            bottom: c\n        };\n    }\n    function ro(t, e, i, s) {\n        return t ? 0 : J(e, i, s);\n    }\n    function lo(t) {\n        const e = ao(t), i = e.right - e.left, s = e.bottom - e.top, n = function(t, e, i) {\n            const s = t.options.borderWidth, n = t.borderSkipped, o = Mi(s);\n            return {\n                t: ro(n.top, o.top, 0, i),\n                r: ro(n.right, o.right, 0, e),\n                b: ro(n.bottom, o.bottom, 0, i),\n                l: ro(n.left, o.left, 0, e)\n            };\n        }(t, i / 2, s / 2), a = function(t, e, i) {\n            const { enableBorderRadius: s } = t.getProps([\n                \"enableBorderRadius\"\n            ]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);\n            return {\n                topLeft: ro(!h || l.top || l.left, a.topLeft, 0, r),\n                topRight: ro(!h || l.top || l.right, a.topRight, 0, r),\n                bottomLeft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r),\n                bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r)\n            };\n        }(t, i / 2, s / 2);\n        return {\n            outer: {\n                x: e.left,\n                y: e.top,\n                w: i,\n                h: s,\n                radius: a\n            },\n            inner: {\n                x: e.left + n.l,\n                y: e.top + n.t,\n                w: i - n.l - n.r,\n                h: s - n.t - n.b,\n                radius: {\n                    topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),\n                    topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),\n                    bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),\n                    bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))\n                }\n            }\n        };\n    }\n    function ho(t, e, i, s) {\n        const n = null === e, o = null === i, a = t && !(n && o) && ao(t, s);\n        return a && (n || tt(e, a.left, a.right)) && (o || tt(i, a.top, a.bottom));\n    }\n    function co(t, e) {\n        t.rect(e.x, e.y, e.w, e.h);\n    }\n    function uo(t, e, i = {}) {\n        const s = t.x !== i.x ? -e : 0, n = t.y !== i.y ? -e : 0, o = (t.x + t.w !== i.x + i.w ? e : 0) - s, a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\n        return {\n            x: t.x + s,\n            y: t.y + n,\n            w: t.w + o,\n            h: t.h + a,\n            radius: t.radius\n        };\n    }\n    var fo = Object.freeze({\n        __proto__: null,\n        ArcElement: class extends Hs {\n            static id = \"arc\";\n            static defaults = {\n                borderAlign: \"center\",\n                borderColor: \"#fff\",\n                borderDash: [],\n                borderDashOffset: 0,\n                borderJoinStyle: void 0,\n                borderRadius: 0,\n                borderWidth: 2,\n                offset: 0,\n                spacing: 0,\n                angle: void 0,\n                circular: !0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\"\n            };\n            static descriptors = {\n                _scriptable: !0,\n                _indexable: (t)=>\"borderDash\" !== t\n            };\n            circumference;\n            endAngle;\n            fullCircles;\n            innerRadius;\n            outerRadius;\n            pixelMargin;\n            startAngle;\n            constructor(t){\n                super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i), { angle: n, distance: o } = X(s, {\n                    x: t,\n                    y: e\n                }), { startAngle: a, endAngle: r, innerRadius: h, outerRadius: c, circumference: d } = this.getProps([\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\",\n                    \"circumference\"\n                ], i), u = (this.options.spacing + this.options.borderWidth) / 2, f = l(d, r - a), g = Z(n, a, r) && a !== r, p = f >= O || g, m = tt(o, h + u, c + u);\n                return p && m;\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, startAngle: s, endAngle: n, innerRadius: o, outerRadius: a } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\"\n                ], t), { offset: r, spacing: l } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;\n                return {\n                    x: e + Math.cos(h) * c,\n                    y: i + Math.sin(h) * c\n                };\n            }\n            tooltipPosition(t) {\n                return this.getCenterPoint(t);\n            }\n            draw(t) {\n                const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular;\n                if (this.pixelMargin = \"inner\" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;\n                t.save();\n                const a = (this.startAngle + this.endAngle) / 2;\n                t.translate(Math.cos(a) * s, Math.sin(a) * s);\n                const r = s * (1 - Math.sin(Math.min(C, i || 0)));\n                t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function(t, e, i, s, n) {\n                    const { fullCircles: o, startAngle: a, circumference: r } = e;\n                    let l = e.endAngle;\n                    if (o) {\n                        qn(t, e, i, s, l, n);\n                        for(let e = 0; e < o; ++e)t.fill();\n                        isNaN(r) || (l = a + (r % O || O));\n                    }\n                    qn(t, e, i, s, l, n), t.fill();\n                }(t, this, r, n, o), Kn(t, this, r, n, o), t.restore();\n            }\n        },\n        BarElement: class extends Hs {\n            static id = \"bar\";\n            static defaults = {\n                borderSkipped: \"start\",\n                borderWidth: 0,\n                borderRadius: 0,\n                inflateAmount: \"auto\",\n                pointStyle: void 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n            }\n            draw(t) {\n                const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: o } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co;\n                var r;\n                t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill(\"evenodd\")), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore();\n            }\n            inRange(t, e, i) {\n                return ho(this, t, e, i);\n            }\n            inXRange(t, e) {\n                return ho(this, t, null, e);\n            }\n            inYRange(t, e) {\n                return ho(this, null, t, e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, base: s, horizontal: n } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"base\",\n                    \"horizontal\"\n                ], t);\n                return {\n                    x: n ? (e + s) / 2 : e,\n                    y: n ? i : (i + s) / 2\n                };\n            }\n            getRange(t) {\n                return \"x\" === t ? this.width / 2 : this.height / 2;\n            }\n        },\n        LineElement: no,\n        PointElement: class extends Hs {\n            static id = \"point\";\n            parsed;\n            skip;\n            stop;\n            static defaults = {\n                borderWidth: 1,\n                hitRadius: 1,\n                hoverBorderWidth: 1,\n                hoverRadius: 4,\n                pointStyle: \"circle\",\n                radius: 3,\n                rotation: 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.options, { x: n, y: o } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i);\n                return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);\n            }\n            inXRange(t, e) {\n                return oo(this, t, \"x\", e);\n            }\n            inYRange(t, e) {\n                return oo(this, t, \"y\", e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], t);\n                return {\n                    x: e,\n                    y: i\n                };\n            }\n            size(t) {\n                let e = (t = t || this.options || {}).radius || 0;\n                e = Math.max(e, e && t.hoverRadius || 0);\n                return 2 * (e + (e && t.borderWidth || 0));\n            }\n            draw(t, e) {\n                const i = this.options;\n                this.skip || i.radius < .1 || !Re(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y));\n            }\n            getRange() {\n                const t = this.options || {};\n                return t.radius + t.hitRadius;\n            }\n        }\n    });\n    function go(t, e, i, s) {\n        const n = t.indexOf(e);\n        if (-1 === n) return ((t, e, i, s)=>(\"string\" == typeof e ? (i = t.push(e) - 1, s.unshift({\n                index: i,\n                label: e\n            })) : isNaN(e) && (i = null), i))(t, e, i, s);\n        return n !== t.lastIndexOf(e) ? i : n;\n    }\n    function po(t) {\n        const e = this.getLabels();\n        return t >= 0 && t < e.length ? e[t] : t;\n    }\n    function mo(t, e, { horizontal: i, minRotation: s }) {\n        const n = $(s), o = (i ? Math.sin(n) : Math.cos(n)) || .001, a = .75 * e * (\"\" + t).length;\n        return Math.min(e / o, a);\n    }\n    class xo extends Js {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            return s(t) || (\"number\" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t;\n        }\n        handleTickRangeOptions() {\n            const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();\n            let { min: s, max: n } = this;\n            const o = (t)=>s = e ? s : t, a = (t)=>n = i ? n : t;\n            if (t) {\n                const t = F(s), e = F(n);\n                t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0);\n            }\n            if (s === n) {\n                let e = 0 === n ? 1 : Math.abs(.05 * n);\n                a(n + e), t || o(s - e);\n            }\n            this.min = s, this.max = n;\n        }\n        getTickLimit() {\n            const t = this.options.ticks;\n            let e, { maxTicksLimit: i, stepSize: s } = t;\n            return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e;\n        }\n        computeTickLimit() {\n            return Number.POSITIVE_INFINITY;\n        }\n        buildTicks() {\n            const t = this.options, e = t.ticks;\n            let i = this.getTickLimit();\n            i = Math.max(2, i);\n            const n = function(t, e) {\n                const i = [], { bounds: n, step: o, min: a, max: r, precision: l, count: h, maxTicks: c, maxDigits: d, includeBounds: u } = t, f = o || 1, g = c - 1, { min: p, max: m } = e, x = !s(a), b = !s(r), _ = !s(h), y = (m - p) / (d + 1);\n                let v, M, w, k, S = B((m - p) / g / f) * f;\n                if (S < 1e-14 && !x && !b) return [\n                    {\n                        value: p\n                    },\n                    {\n                        value: m\n                    }\n                ];\n                k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), \"ticks\" === n ? (M = Math.floor(p / S) * S, w = Math.ceil(m / S) * S) : (M = p, w = m), x && b && o && H((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, M = a, w = r) : _ ? (M = x ? a : M, w = b ? r : w, k = h - 1, S = (w - M) / k) : (k = (w - M) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));\n                const P = Math.max(U(S), U(M));\n                v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;\n                let D = 0;\n                for(x && (u && M !== a ? (i.push({\n                    value: a\n                }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, mo(a, y, t)) && D++) : M < a && D++); D < k; ++D){\n                    const t = Math.round((M + D * S) * v) / v;\n                    if (b && t > r) break;\n                    i.push({\n                        value: t\n                    });\n                }\n                return b && u && w !== r ? i.length && V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({\n                    value: r\n                }) : b && w !== r || i.push({\n                    value: w\n                }), i;\n            }({\n                maxTicks: i,\n                bounds: t.bounds,\n                min: t.min,\n                max: t.max,\n                precision: e.precision,\n                step: e.stepSize,\n                count: e.count,\n                maxDigits: this._maxDigits(),\n                horizontal: this.isHorizontal(),\n                minRotation: e.minRotation || 0,\n                includeBounds: !1 !== e.includeBounds\n            }, this._range || this);\n            return \"ticks\" === t.bounds && j(n, this, \"value\"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;\n        }\n        configure() {\n            const t = this.ticks;\n            let e = this.min, i = this.max;\n            if (super.configure(), this.options.offset && t.length) {\n                const s = (i - e) / Math.max(t.length - 1, 1) / 2;\n                e -= s, i += s;\n            }\n            this._startValue = e, this._endValue = i, this._valueRange = i - e;\n        }\n        getLabelForValue(t) {\n            return ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n    }\n    class bo extends xo {\n        static id = \"linear\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.numeric\n            }\n        };\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            const t = this.isHorizontal(), e = t ? this.width : this.height, i = $(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, n = this._resolveTickFontOptions(0);\n            return Math.ceil(e / Math.min(40, n.lineHeight / s));\n        }\n        getPixelForValue(t) {\n            return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n        }\n    }\n    const _o = (t)=>Math.floor(z(t)), yo = (t, e)=>Math.pow(10, _o(t) + e);\n    function vo(t) {\n        return 1 === t / Math.pow(10, _o(t));\n    }\n    function Mo(t, e, i) {\n        const s = Math.pow(10, i), n = Math.floor(t / s);\n        return Math.ceil(e / s) - n;\n    }\n    function wo(t, { min: e, max: i }) {\n        e = r(t.min, e);\n        const s = [], n = _o(e);\n        let o = function(t, e) {\n            let i = _o(e - t);\n            for(; Mo(t, e, i) > 10;)i++;\n            for(; Mo(t, e, i) < 10;)i--;\n            return Math.min(i, _o(t));\n        }(e, i), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;\n        const l = Math.pow(10, o), h = n > o ? Math.pow(10, n) : 0, c = Math.round((e - h) * a) / a, d = Math.floor((e - h) / l / 10) * l * 10;\n        let u = Math.floor((c - d) / Math.pow(10, o)), f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a);\n        for(; f < i;)s.push({\n            value: f,\n            major: vo(f),\n            significand: u\n        }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a;\n        const g = r(t.max, f);\n        return s.push({\n            value: g,\n            major: vo(g),\n            significand: u\n        }), s;\n    }\n    class ko extends Js {\n        static id = \"logarithmic\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.logarithmic,\n                major: {\n                    enabled: !0\n                }\n            }\n        };\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            const i = xo.prototype.parse.apply(this, [\n                t,\n                e\n            ]);\n            if (0 !== i) return a(i) && i > 0 ? i : null;\n            this._zero = !0;\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions();\n        }\n        handleTickRangeOptions() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let i = this.min, s = this.max;\n            const n = (e)=>i = t ? i : e, o = (t)=>s = e ? s : t;\n            i === s && (i <= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i <= 0 && n(yo(s, -1)), s <= 0 && o(yo(i, 1)), this.min = i, this.max = s;\n        }\n        buildTicks() {\n            const t = this.options, e = wo({\n                min: this._userMin,\n                max: this._userMax\n            }, this);\n            return \"ticks\" === t.bounds && j(e, this, \"value\"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e;\n        }\n        getLabelForValue(t) {\n            return void 0 === t ? \"0\" : ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n        configure() {\n            const t = this.min;\n            super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t);\n        }\n        getPixelForValue(t) {\n            return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            const e = this.getDecimalForPixel(t);\n            return Math.pow(10, this._startValue + e * this._valueRange);\n        }\n    }\n    function So(t) {\n        const e = t.ticks;\n        if (e.display && t.display) {\n            const t = ki(e.backdropPadding);\n            return l(e.font && e.font.size, ue.font.size) + t.height;\n        }\n        return 0;\n    }\n    function Po(t, e, i, s, n) {\n        return t === s || t === n ? {\n            start: e - i / 2,\n            end: e + i / 2\n        } : t < s || t > n ? {\n            start: e - i,\n            end: e\n        } : {\n            start: e,\n            end: e + i\n        };\n    }\n    function Do(t) {\n        const e = {\n            l: t.left + t._padding.left,\n            r: t.right - t._padding.right,\n            t: t.top + t._padding.top,\n            b: t.bottom - t._padding.bottom\n        }, i = Object.assign({}, e), s = [], o = [], a = t._pointLabels.length, r = t.options.pointLabels, l = r.centerPointLabels ? C / a : 0;\n        for(let u = 0; u < a; u++){\n            const a = r.setContext(t.getPointLabelContext(u));\n            o[u] = a.padding;\n            const f = t.getPointPosition(u, t.drawingArea + o[u], l), g = Si(a.font), p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [\n                d\n            ], {\n                w: Oe(h, c.string, d),\n                h: d.length * c.lineHeight\n            });\n            s[u] = p;\n            const m = G(t.getIndexAngle(u) + l), x = Math.round(Y(m));\n            Co(i, e, m, Po(x, f.x, p.w, 0, 180), Po(x, f.y, p.h, 90, 270));\n        }\n        var h, c, d;\n        t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {\n            const s = [], n = t._pointLabels.length, o = t.options, { centerPointLabels: a, display: r } = o.pointLabels, l = {\n                extra: So(o) / 2,\n                additionalAngle: a ? C / n : 0\n            };\n            let h;\n            for(let o = 0; o < n; o++){\n                l.padding = i[o], l.size = e[o];\n                const n = Oo(t, o, l);\n                s.push(n), \"auto\" === r && (n.visible = Ao(n, h), n.visible && (h = n));\n            }\n            return s;\n        }(t, s, o);\n    }\n    function Co(t, e, i, s, n) {\n        const o = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));\n        let r = 0, l = 0;\n        s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l));\n    }\n    function Oo(t, e, i) {\n        const s = t.drawingArea, { extra: n, additionalAngle: o, padding: a, size: r } = i, l = t.getPointPosition(e, s + n + a, o), h = Math.round(Y(G(l.angle + E))), c = function(t, e, i) {\n            90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);\n            return t;\n        }(l.y, r.h, h), d = function(t) {\n            if (0 === t || 180 === t) return \"center\";\n            if (t < 180) return \"left\";\n            return \"right\";\n        }(h), u = function(t, e, i) {\n            \"right\" === i ? t -= e : \"center\" === i && (t -= e / 2);\n            return t;\n        }(l.x, r.w, d);\n        return {\n            visible: !0,\n            x: l.x,\n            y: c,\n            textAlign: d,\n            left: u,\n            top: c,\n            right: u + r.w,\n            bottom: c + r.h\n        };\n    }\n    function Ao(t, e) {\n        if (!e) return !0;\n        const { left: i, top: s, right: n, bottom: o } = t;\n        return !(Re({\n            x: i,\n            y: s\n        }, e) || Re({\n            x: i,\n            y: o\n        }, e) || Re({\n            x: n,\n            y: s\n        }, e) || Re({\n            x: n,\n            y: o\n        }, e));\n    }\n    function To(t, e, i) {\n        const { left: n, top: o, right: a, bottom: r } = i, { backdropColor: l } = e;\n        if (!s(l)) {\n            const i = wi(e.borderRadius), s = ki(e.backdropPadding);\n            t.fillStyle = l;\n            const h = n - s.left, c = o - s.top, d = a - n + s.width, u = r - o + s.height;\n            Object.values(i).some((t)=>0 !== t) ? (t.beginPath(), He(t, {\n                x: h,\n                y: c,\n                w: d,\n                h: u,\n                radius: i\n            }), t.fill()) : t.fillRect(h, c, d, u);\n        }\n    }\n    function Lo(t, e, i, s) {\n        const { ctx: n } = t;\n        if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);\n        else {\n            let i = t.getPointPosition(0, e);\n            n.moveTo(i.x, i.y);\n            for(let o = 1; o < s; o++)i = t.getPointPosition(o, e), n.lineTo(i.x, i.y);\n        }\n    }\n    class Eo extends xo {\n        static id = \"radialLinear\";\n        static defaults = {\n            display: !0,\n            animate: !0,\n            position: \"chartArea\",\n            angleLines: {\n                display: !0,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0\n            },\n            grid: {\n                circular: !1\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: !0,\n                callback: ae.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: void 0,\n                backdropPadding: 2,\n                display: !0,\n                font: {\n                    size: 10\n                },\n                callback: (t)=>t,\n                padding: 5,\n                centerPointLabels: !1\n            }\n        };\n        static defaultRoutes = {\n            \"angleLines.color\": \"borderColor\",\n            \"pointLabels.color\": \"color\",\n            \"ticks.color\": \"color\"\n        };\n        static descriptors = {\n            angleLines: {\n                _fallback: \"grid\"\n            }\n        };\n        constructor(t){\n            super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n        }\n        setDimensions() {\n            const t = this._padding = ki(So(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;\n            this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!1);\n            this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            return Math.ceil(this.drawingArea / So(this.options));\n        }\n        generateTickLabels(t) {\n            xo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e)=>{\n                const i = d(this.options.pointLabels.callback, [\n                    t,\n                    e\n                ], this);\n                return i || 0 === i ? i : \"\";\n            }).filter((t, e)=>this.chart.getDataVisibility(e));\n        }\n        fit() {\n            const t = this.options;\n            t.display && t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0);\n        }\n        setCenterPoint(t, e, i, s) {\n            this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));\n        }\n        getIndexAngle(t) {\n            return G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0));\n        }\n        getDistanceFromCenterForValue(t) {\n            if (s(t)) return NaN;\n            const e = this.drawingArea / (this.max - this.min);\n            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n        }\n        getValueForDistanceFromCenter(t) {\n            if (s(t)) return NaN;\n            const e = t / (this.drawingArea / (this.max - this.min));\n            return this.options.reverse ? this.max - e : this.min + e;\n        }\n        getPointLabelContext(t) {\n            const e = this._pointLabels || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return function(t, e, i) {\n                    return Ci(t, {\n                        label: i,\n                        index: e,\n                        type: \"pointLabel\"\n                    });\n                }(this.getContext(), t, i);\n            }\n        }\n        getPointPosition(t, e, i = 0) {\n            const s = this.getIndexAngle(t) - E + i;\n            return {\n                x: Math.cos(s) * e + this.xCenter,\n                y: Math.sin(s) * e + this.yCenter,\n                angle: s\n            };\n        }\n        getPointPositionForValue(t, e) {\n            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n        }\n        getBasePosition(t) {\n            return this.getPointPositionForValue(t || 0, this.getBaseValue());\n        }\n        getPointLabelPosition(t) {\n            const { left: e, top: i, right: s, bottom: n } = this._pointLabelItems[t];\n            return {\n                left: e,\n                top: i,\n                right: s,\n                bottom: n\n            };\n        }\n        drawBackground() {\n            const { backgroundColor: t, grid: { circular: e } } = this.options;\n            if (t) {\n                const i = this.ctx;\n                i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();\n            }\n        }\n        drawGrid() {\n            const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, o = this._pointLabels.length;\n            let a, r, l;\n            if (e.pointLabels.display && function(t, e) {\n                const { ctx: i, options: { pointLabels: s } } = t;\n                for(let n = e - 1; n >= 0; n--){\n                    const e = t._pointLabelItems[n];\n                    if (!e.visible) continue;\n                    const o = s.setContext(t.getPointLabelContext(n));\n                    To(i, o, e);\n                    const a = Si(o.font), { x: r, y: l, textAlign: h } = e;\n                    Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, {\n                        color: o.color,\n                        textAlign: h,\n                        textBaseline: \"middle\"\n                    });\n                }\n            }(this, o), s.display && this.ticks.forEach((t, e)=>{\n                if (0 !== e || 0 === e && this.min < 0) {\n                    r = this.getDistanceFromCenterForValue(t.value);\n                    const i = this.getContext(e), a = s.setContext(i), l = n.setContext(i);\n                    !function(t, e, i, s, n) {\n                        const o = t.ctx, a = e.circular, { color: r, lineWidth: l } = e;\n                        !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash || []), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore());\n                    }(this, a, r, o, l);\n                }\n            }), i.display) {\n                for(t.save(), a = o - 1; a >= 0; a--){\n                    const s = i.setContext(this.getPointLabelContext(a)), { color: n, lineWidth: o } = s;\n                    o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n                }\n                t.restore();\n            }\n        }\n        drawBorder() {}\n        drawLabels() {\n            const t = this.ctx, e = this.options, i = e.ticks;\n            if (!i.display) return;\n            const s = this.getIndexAngle(0);\n            let n, o;\n            t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((s, a)=>{\n                if (0 === a && this.min >= 0 && !e.reverse) return;\n                const r = i.setContext(this.getContext(a)), l = Si(r.font);\n                if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\n                    t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\n                    const e = ki(r.backdropPadding);\n                    t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height);\n                }\n                Ne(t, s.label, 0, -n, l, {\n                    color: r.color,\n                    strokeColor: r.textStrokeColor,\n                    strokeWidth: r.textStrokeWidth\n                });\n            }), t.restore();\n        }\n        drawTitle() {}\n    }\n    const Ro = {\n        millisecond: {\n            common: !0,\n            size: 1,\n            steps: 1e3\n        },\n        second: {\n            common: !0,\n            size: 1e3,\n            steps: 60\n        },\n        minute: {\n            common: !0,\n            size: 6e4,\n            steps: 60\n        },\n        hour: {\n            common: !0,\n            size: 36e5,\n            steps: 24\n        },\n        day: {\n            common: !0,\n            size: 864e5,\n            steps: 30\n        },\n        week: {\n            common: !1,\n            size: 6048e5,\n            steps: 4\n        },\n        month: {\n            common: !0,\n            size: 2628e6,\n            steps: 12\n        },\n        quarter: {\n            common: !1,\n            size: 7884e6,\n            steps: 4\n        },\n        year: {\n            common: !0,\n            size: 3154e7\n        }\n    }, Io = Object.keys(Ro);\n    function zo(t, e) {\n        return t - e;\n    }\n    function Fo(t, e) {\n        if (s(e)) return null;\n        const i = t._adapter, { parser: n, round: o, isoWeekday: r } = t._parseOpts;\n        let l = e;\n        return \"function\" == typeof n && (l = n(l)), a(l) || (l = \"string\" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = \"week\" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, \"isoWeek\", r)), +l);\n    }\n    function Vo(t, e, i, s) {\n        const n = Io.length;\n        for(let o = Io.indexOf(t); o < n - 1; ++o){\n            const t = Ro[Io[o]], n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\n            if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return Io[o];\n        }\n        return Io[n - 1];\n    }\n    function Bo(t, e, i) {\n        if (i) {\n            if (i.length) {\n                const { lo: s, hi: n } = et(i, e);\n                t[i[s] >= e ? i[s] : i[n]] = !0;\n            }\n        } else t[e] = !0;\n    }\n    function Wo(t, e, i) {\n        const s = [], n = {}, o = e.length;\n        let a, r;\n        for(a = 0; a < o; ++a)r = e[a], n[r] = a, s.push({\n            value: r,\n            major: !1\n        });\n        return 0 !== o && i ? function(t, e, i, s) {\n            const n = t._adapter, o = +n.startOf(e[0].value, s), a = e[e.length - 1].value;\n            let r, l;\n            for(r = o; r <= a; r = +n.add(r, 1, s))l = i[r], l >= 0 && (e[l].major = !0);\n            return e;\n        }(t, s, n, i) : s;\n    }\n    class No extends Js {\n        static id = \"time\";\n        static defaults = {\n            bounds: \"data\",\n            adapters: {},\n            time: {\n                parser: !1,\n                unit: !1,\n                round: !1,\n                isoWeekday: !1,\n                minUnit: \"millisecond\",\n                displayFormats: {}\n            },\n            ticks: {\n                source: \"auto\",\n                callback: !1,\n                major: {\n                    enabled: !1\n                }\n            }\n        };\n        constructor(t){\n            super(t), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n        }\n        init(t, e = {}) {\n            const i = t.time || (t.time = {}), s = this._adapter = new Rn._date(t.adapters.date);\n            s.init(e), b(i.displayFormats, s.formats()), this._parseOpts = {\n                parser: i.parser,\n                round: i.round,\n                isoWeekday: i.isoWeekday\n            }, super.init(t), this._normalized = e.normalized;\n        }\n        parse(t, e) {\n            return void 0 === t ? null : Fo(this, t);\n        }\n        beforeLayout() {\n            super.beforeLayout(), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            };\n        }\n        determineDataLimits() {\n            const t = this.options, e = this._adapter, i = t.time.unit || \"day\";\n            let { min: s, max: n, minDefined: o, maxDefined: r } = this.getUserBounds();\n            function l(t) {\n                o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max));\n            }\n            o && r || (l(this._getLabelBounds()), \"ticks\" === t.bounds && \"labels\" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);\n        }\n        _getLabelBounds() {\n            const t = this.getLabelTimestamps();\n            let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n            return t.length && (e = t[0], i = t[t.length - 1]), {\n                min: e,\n                max: i\n            };\n        }\n        buildTicks() {\n            const t = this.options, e = t.time, i = t.ticks, s = \"labels\" === i.source ? this.getLabelTimestamps() : this._generate();\n            \"ticks\" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\n            const n = this.min, o = nt(s, n, this.max);\n            return this._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {\n                for(let o = Io.length - 1; o >= Io.indexOf(i); o--){\n                    const i = Io[o];\n                    if (Ro[i].common && t._adapter.diff(n, s, i) >= e - 1) return i;\n                }\n                return Io[i ? Io.indexOf(i) : 0];\n            }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && \"year\" !== this._unit ? function(t) {\n                for(let e = Io.indexOf(t) + 1, i = Io.length; e < i; ++e)if (Ro[Io[e]].common) return Io[e];\n            }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), Wo(this, o, this._majorUnit);\n        }\n        afterAutoSkip() {\n            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t)=>+t.value));\n        }\n        initOffsets(t = []) {\n            let e, i, s = 0, n = 0;\n            this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);\n            const o = t.length < 3 ? .5 : .25;\n            s = J(s, 0, o), n = J(n, 0, o), this._offsets = {\n                start: s,\n                end: n,\n                factor: 1 / (s + 1 + n)\n            };\n        }\n        _generate() {\n            const t = this._adapter, e = this.min, i = this.max, s = this.options, n = s.time, o = n.unit || Vo(n.minUnit, e, i, this._getLabelCapacity(e)), a = l(s.ticks.stepSize, 1), r = \"week\" === o && n.isoWeekday, h = N(r) || !0 === r, c = {};\n            let d, u, f = e;\n            if (h && (f = +t.startOf(f, \"isoWeek\", r)), f = +t.startOf(f, h ? \"day\" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n            const g = \"data\" === s.ticks.source && this.getDataTimestamps();\n            for(d = f, u = 0; d < i; d = +t.add(d, a, o), u++)Bo(c, d, g);\n            return d !== i && \"ticks\" !== s.bounds && 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t)=>+t);\n        }\n        getLabelForValue(t) {\n            const e = this._adapter, i = this.options.time;\n            return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);\n        }\n        format(t, e) {\n            const i = this.options.time.displayFormats, s = this._unit, n = e || i[s];\n            return this._adapter.format(t, n);\n        }\n        _tickFormatFunction(t, e, i, s) {\n            const n = this.options, o = n.ticks.callback;\n            if (o) return d(o, [\n                t,\n                e,\n                i\n            ], this);\n            const a = n.time.displayFormats, r = this._unit, l = this._majorUnit, h = r && a[r], c = l && a[l], u = i[e], f = l && c && u && u.major;\n            return this._adapter.format(t, s || (f ? c : h));\n        }\n        generateTickLabels(t) {\n            let e, i, s;\n            for(e = 0, i = t.length; e < i; ++e)s = t[e], s.label = this._tickFormatFunction(s.value, e, t);\n        }\n        getDecimalForValue(t) {\n            return null === t ? NaN : (t - this.min) / (this.max - this.min);\n        }\n        getPixelForValue(t) {\n            const e = this._offsets, i = this.getDecimalForValue(t);\n            return this.getPixelForDecimal((e.start + i) * e.factor);\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n            return this.min + i * (this.max - this.min);\n        }\n        _getLabelSize(t) {\n            const e = this.options.ticks, i = this.ctx.measureText(t).width, s = $(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;\n            return {\n                w: i * n + a * o,\n                h: i * o + a * n\n            };\n        }\n        _getLabelCapacity(t) {\n            const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, Wo(this, [\n                t\n            ], this._majorUnit), s), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;\n            return a > 0 ? a : 1;\n        }\n        getDataTimestamps() {\n            let t, e, i = this._cache.data || [];\n            if (i.length) return i;\n            const s = this.getMatchingVisibleMetas();\n            if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\n            for(t = 0, e = s.length; t < e; ++t)i = i.concat(s[t].controller.getAllParsedValues(this));\n            return this._cache.data = this.normalize(i);\n        }\n        getLabelTimestamps() {\n            const t = this._cache.labels || [];\n            let e, i;\n            if (t.length) return t;\n            const s = this.getLabels();\n            for(e = 0, i = s.length; e < i; ++e)t.push(Fo(this, s[e]));\n            return this._cache.labels = this._normalized ? t : this.normalize(t);\n        }\n        normalize(t) {\n            return lt(t.sort(zo));\n        }\n    }\n    function Ho(t, e, i) {\n        let s, n, o, a, r = 0, l = t.length - 1;\n        i ? (e >= t[r].pos && e <= t[l].pos && ({ lo: r, hi: l } = it(t, \"pos\", e)), { pos: s, time: o } = t[r], { pos: n, time: a } = t[l]) : (e >= t[r].time && e <= t[l].time && ({ lo: r, hi: l } = it(t, \"time\", e)), { time: s, pos: o } = t[r], { time: n, pos: a } = t[l]);\n        const h = n - s;\n        return h ? o + (a - o) * (e - s) / h : o;\n    }\n    var jo = Object.freeze({\n        __proto__: null,\n        CategoryScale: class extends Js {\n            static id = \"category\";\n            static defaults = {\n                ticks: {\n                    callback: po\n                }\n            };\n            constructor(t){\n                super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n            }\n            init(t) {\n                const e = this._addedLabels;\n                if (e.length) {\n                    const t = this.getLabels();\n                    for (const { index: i, label: s } of e)t[i] === s && t.splice(i, 1);\n                    this._addedLabels = [];\n                }\n                super.init(t);\n            }\n            parse(t, e) {\n                if (s(t)) return null;\n                const i = this.getLabels();\n                return ((t, e)=>null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1);\n            }\n            determineDataLimits() {\n                const { minDefined: t, maxDefined: e } = this.getUserBounds();\n                let { min: i, max: s } = this.getMinMax(!0);\n                \"ticks\" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;\n            }\n            buildTicks() {\n                const t = this.min, e = this.max, i = this.options.offset, s = [];\n                let n = this.getLabels();\n                n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\n                for(let i = t; i <= e; i++)s.push({\n                    value: i\n                });\n                return s;\n            }\n            getLabelForValue(t) {\n                return po.call(this, t);\n            }\n            configure() {\n                super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n            }\n            getPixelForValue(t) {\n                return \"number\" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n            }\n            getPixelForTick(t) {\n                const e = this.ticks;\n                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n            }\n            getValueForPixel(t) {\n                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n            }\n            getBasePixel() {\n                return this.bottom;\n            }\n        },\n        LinearScale: bo,\n        LogarithmicScale: ko,\n        RadialLinearScale: Eo,\n        TimeScale: No,\n        TimeSeriesScale: class extends No {\n            static id = \"timeseries\";\n            static defaults = No.defaults;\n            constructor(t){\n                super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n            }\n            initOffsets() {\n                const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n                this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t);\n            }\n            buildLookupTable(t) {\n                const { min: e, max: i } = this, s = [], n = [];\n                let o, a, r, l, h;\n                for(o = 0, a = t.length; o < a; ++o)l = t[o], l >= e && l <= i && s.push(l);\n                if (s.length < 2) return [\n                    {\n                        time: e,\n                        pos: 0\n                    },\n                    {\n                        time: i,\n                        pos: 1\n                    }\n                ];\n                for(o = 0, a = s.length; o < a; ++o)h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({\n                    time: l,\n                    pos: o / (a - 1)\n                });\n                return n;\n            }\n            _generate() {\n                const t = this.min, e = this.max;\n                let i = super.getDataTimestamps();\n                return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort((t, e)=>t - e);\n            }\n            _getTimestampsForTable() {\n                let t = this._cache.all || [];\n                if (t.length) return t;\n                const e = this.getDataTimestamps(), i = this.getLabelTimestamps();\n                return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t;\n            }\n            getDecimalForValue(t) {\n                return (Ho(this._table, t) - this._minPos) / this._tableRange;\n            }\n            getValueForPixel(t) {\n                const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n                return Ho(this._table, i * this._tableRange + this._minPos, !0);\n            }\n        }\n    });\n    const $o = [\n        \"rgb(54, 162, 235)\",\n        \"rgb(255, 99, 132)\",\n        \"rgb(255, 159, 64)\",\n        \"rgb(255, 205, 86)\",\n        \"rgb(75, 192, 192)\",\n        \"rgb(153, 102, 255)\",\n        \"rgb(201, 203, 207)\"\n    ], Yo = $o.map((t)=>t.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\n    function Uo(t) {\n        return $o[t % $o.length];\n    }\n    function Xo(t) {\n        return Yo[t % Yo.length];\n    }\n    function qo(t) {\n        let e = 0;\n        return (i, s)=>{\n            const n = t.getDatasetMeta(s).controller;\n            n instanceof jn ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Uo(e++)), e;\n            }(i, e) : n instanceof $n ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Xo(e++)), e;\n            }(i, e) : n && (e = function(t, e) {\n                return t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e;\n            }(i, e));\n        };\n    }\n    function Ko(t) {\n        let e;\n        for(e in t)if (t[e].borderColor || t[e].backgroundColor) return !0;\n        return !1;\n    }\n    var Go = {\n        id: \"colors\",\n        defaults: {\n            enabled: !0,\n            forceOverride: !1\n        },\n        beforeLayout (t, e, i) {\n            if (!i.enabled) return;\n            const { data: { datasets: s }, options: n } = t.config, { elements: o } = n, a = Ko(s) || (r = n) && (r.borderColor || r.backgroundColor) || o && Ko(o) || \"rgba(0,0,0,0.1)\" !== ue.borderColor || \"rgba(0,0,0,0.1)\" !== ue.backgroundColor;\n            var r;\n            if (!i.forceOverride && a) return;\n            const l = qo(t);\n            s.forEach(l);\n        }\n    };\n    function Zo(t) {\n        if (t._decimated) {\n            const e = t._data;\n            delete t._decimated, delete t._data, Object.defineProperty(t, \"data\", {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0,\n                value: e\n            });\n        }\n    }\n    function Jo(t) {\n        t.data.datasets.forEach((t)=>{\n            Zo(t);\n        });\n    }\n    var Qo = {\n        id: \"decimation\",\n        defaults: {\n            algorithm: \"min-max\",\n            enabled: !1\n        },\n        beforeElementsUpdate: (t, e, i)=>{\n            if (!i.enabled) return void Jo(t);\n            const n = t.width;\n            t.data.datasets.forEach((e, o)=>{\n                const { _data: a, indexAxis: r } = e, l = t.getDatasetMeta(o), h = a || e.data;\n                if (\"y\" === Pi([\n                    r,\n                    t.options.indexAxis\n                ])) return;\n                if (!l.controller.supportsDecimation) return;\n                const c = t.scales[l.xAxisID];\n                if (\"linear\" !== c.type && \"time\" !== c.type) return;\n                if (t.options.parsing) return;\n                let { start: d, count: u } = function(t, e) {\n                    const i = e.length;\n                    let s, n = 0;\n                    const { iScale: o } = t, { min: a, max: r, minDefined: l, maxDefined: h } = o.getUserBounds();\n                    return l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {\n                        start: n,\n                        count: s\n                    };\n                }(l, h);\n                if (u <= (i.threshold || 4 * n)) return void Zo(e);\n                let f;\n                switch(s(a) && (e._data = h, delete e.data, Object.defineProperty(e, \"data\", {\n                    configurable: !0,\n                    enumerable: !0,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(t) {\n                        this._data = t;\n                    }\n                })), i.algorithm){\n                    case \"lttb\":\n                        f = function(t, e, i, s, n) {\n                            const o = n.samples || s;\n                            if (o >= i) return t.slice(e, e + i);\n                            const a = [], r = (i - 2) / (o - 2);\n                            let l = 0;\n                            const h = e + i - 1;\n                            let c, d, u, f, g, p = e;\n                            for(a[l++] = t[p], c = 0; c < o - 2; c++){\n                                let s, n = 0, o = 0;\n                                const h = Math.floor((c + 1) * r) + 1 + e, m = Math.min(Math.floor((c + 2) * r) + 1, i) + e, x = m - h;\n                                for(s = h; s < m; s++)n += t[s].x, o += t[s].y;\n                                n /= x, o /= x;\n                                const b = Math.floor(c * r) + 1 + e, _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e, { x: y, y: v } = t[p];\n                                for(u = f = -1, s = b; s < _; s++)f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);\n                                a[l++] = d, p = g;\n                            }\n                            return a[l++] = t[h], a;\n                        }(h, d, u, n, i);\n                        break;\n                    case \"min-max\":\n                        f = function(t, e, i, n) {\n                            let o, a, r, l, h, c, d, u, f, g, p = 0, m = 0;\n                            const x = [], b = e + i - 1, _ = t[e].x, y = t[b].x - _;\n                            for(o = e; o < e + i; ++o){\n                                a = t[o], r = (a.x - _) / y * n, l = a.y;\n                                const e = 0 | r;\n                                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;\n                                else {\n                                    const i = o - 1;\n                                    if (!s(c) && !s(d)) {\n                                        const e = Math.min(c, d), s = Math.max(c, d);\n                                        e !== u && e !== i && x.push({\n                                            ...t[e],\n                                            x: p\n                                        }), s !== u && s !== i && x.push({\n                                            ...t[s],\n                                            x: p\n                                        });\n                                    }\n                                    o > 0 && i !== u && x.push(t[i]), x.push(a), h = e, m = 0, f = g = l, c = d = u = o;\n                                }\n                            }\n                            return x;\n                        }(h, d, u, n);\n                        break;\n                    default:\n                        throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);\n                }\n                e._decimated = f;\n            });\n        },\n        destroy (t) {\n            Jo(t);\n        }\n    };\n    function ta(t, e, i, s) {\n        if (s) return;\n        let n = e[t], o = i[t];\n        return \"angle\" === t && (n = G(n), o = G(o)), {\n            property: t,\n            start: n,\n            end: o\n        };\n    }\n    function ea(t, e, i) {\n        for(; e > t; e--){\n            const t = i[e];\n            if (!isNaN(t.x) && !isNaN(t.y)) break;\n        }\n        return e;\n    }\n    function ia(t, e, i, s) {\n        return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;\n    }\n    function sa(t, e) {\n        let i = [], s = !1;\n        return n(t) ? (s = !0, i = t) : i = function(t, e) {\n            const { x: i = null, y: s = null } = t || {}, n = e.points, o = [];\n            return e.segments.forEach(({ start: t, end: e })=>{\n                e = ea(t, e, n);\n                const a = n[t], r = n[e];\n                null !== s ? (o.push({\n                    x: a.x,\n                    y: s\n                }), o.push({\n                    x: r.x,\n                    y: s\n                })) : null !== i && (o.push({\n                    x: i,\n                    y: a.y\n                }), o.push({\n                    x: i,\n                    y: r.y\n                }));\n            }), o;\n        }(t, e), i.length ? new no({\n            points: i,\n            options: {\n                tension: 0\n            },\n            _loop: s,\n            _fullLoop: s\n        }) : null;\n    }\n    function na(t) {\n        return t && !1 !== t.fill;\n    }\n    function oa(t, e, i) {\n        let s = t[e].fill;\n        const n = [\n            e\n        ];\n        let o;\n        if (!i) return s;\n        for(; !1 !== s && -1 === n.indexOf(s);){\n            if (!a(s)) return s;\n            if (o = t[s], !o) return !1;\n            if (o.visible) return s;\n            n.push(s), s = o.fill;\n        }\n        return !1;\n    }\n    function aa(t, e, i) {\n        const s = function(t) {\n            const e = t.options, i = e.fill;\n            let s = l(i && i.target, i);\n            void 0 === s && (s = !!e.backgroundColor);\n            if (!1 === s || null === s) return !1;\n            if (!0 === s) return \"origin\";\n            return s;\n        }(t);\n        if (o(s)) return !isNaN(s.value) && s;\n        let n = parseFloat(s);\n        return a(n) && Math.floor(n) === n ? function(t, e, i, s) {\n            \"-\" !== t && \"+\" !== t || (i = e + i);\n            if (i === e || i < 0 || i >= s) return !1;\n            return i;\n        }(s[0], e, n, i) : [\n            \"origin\",\n            \"start\",\n            \"end\",\n            \"stack\",\n            \"shape\"\n        ].indexOf(s) >= 0 && s;\n    }\n    function ra(t, e, i) {\n        const s = [];\n        for(let n = 0; n < i.length; n++){\n            const o = i[n], { first: a, last: r, point: l } = la(o, e, \"x\");\n            if (!(!l || a && r)) {\n                if (a) s.unshift(l);\n                else if (t.push(l), !r) break;\n            }\n        }\n        t.push(...s);\n    }\n    function la(t, e, i) {\n        const s = t.interpolate(e, i);\n        if (!s) return {};\n        const n = s[i], o = t.segments, a = t.points;\n        let r = !1, l = !1;\n        for(let t = 0; t < o.length; t++){\n            const e = o[t], s = a[e.start][i], h = a[e.end][i];\n            if (tt(n, s, h)) {\n                r = n === s, l = n === h;\n                break;\n            }\n        }\n        return {\n            first: r,\n            last: l,\n            point: s\n        };\n    }\n    class ha {\n        constructor(t){\n            this.x = t.x, this.y = t.y, this.radius = t.radius;\n        }\n        pathSegment(t, e, i) {\n            const { x: s, y: n, radius: o } = this;\n            return e = e || {\n                start: 0,\n                end: O\n            }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds;\n        }\n        interpolate(t) {\n            const { x: e, y: i, radius: s } = this, n = t.angle;\n            return {\n                x: e + Math.cos(n) * s,\n                y: i + Math.sin(n) * s,\n                angle: n\n            };\n        }\n    }\n    function ca(t) {\n        const { chart: e, fill: i, line: s } = t;\n        if (a(i)) return function(t, e) {\n            const i = t.getDatasetMeta(e), s = i && t.isDatasetVisible(e);\n            return s ? i.dataset : null;\n        }(e, i);\n        if (\"stack\" === i) return function(t) {\n            const { scale: e, index: i, line: s } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {\n                const i = [], s = t.getMatchingVisibleMetas(\"line\");\n                for(let t = 0; t < s.length; t++){\n                    const n = s[t];\n                    if (n.index === e) break;\n                    n.hidden || i.unshift(n.dataset);\n                }\n                return i;\n            }(e, i);\n            r.push(sa({\n                x: null,\n                y: e.bottom\n            }, s));\n            for(let t = 0; t < o.length; t++){\n                const e = o[t];\n                for(let t = e.start; t <= e.end; t++)ra(n, a[t], r);\n            }\n            return new no({\n                points: n,\n                options: {}\n            });\n        }(t);\n        if (\"shape\" === i) return !0;\n        const n = function(t) {\n            const e = t.scale || {};\n            if (e.getPointPositionForValue) return function(t) {\n                const { scale: e, fill: i } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {\n                    let s;\n                    return s = \"start\" === t ? i : \"end\" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s;\n                }(i, e, a), l = [];\n                if (s.grid.circular) {\n                    const t = e.getPointPositionForValue(0, a);\n                    return new ha({\n                        x: t.x,\n                        y: t.y,\n                        radius: e.getDistanceFromCenterForValue(r)\n                    });\n                }\n                for(let t = 0; t < n; ++t)l.push(e.getPointPositionForValue(t, r));\n                return l;\n            }(t);\n            return function(t) {\n                const { scale: e = {}, fill: i } = t, s = function(t, e) {\n                    let i = null;\n                    return \"start\" === t ? i = e.bottom : \"end\" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;\n                }(i, e);\n                if (a(s)) {\n                    const t = e.isHorizontal();\n                    return {\n                        x: t ? s : null,\n                        y: t ? null : s\n                    };\n                }\n                return null;\n            }(t);\n        }(t);\n        return n instanceof ha ? n : sa(n, s);\n    }\n    function da(t, e, i) {\n        const s = ca(e), { line: n, scale: o, axis: a } = e, r = n.options, l = r.fill, h = r.backgroundColor, { above: c = h, below: d = h } = l || {};\n        s && n.points.length && (Ie(t, i), function(t, e) {\n            const { line: i, target: s, above: n, below: o, area: a, scale: r } = e, l = i._loop ? \"angle\" : e.axis;\n            t.save(), \"x\" === l && o !== n && (ua(t, s, a.top), fa(t, {\n                line: i,\n                target: s,\n                color: n,\n                scale: r,\n                property: l\n            }), t.restore(), t.save(), ua(t, s, a.bottom));\n            fa(t, {\n                line: i,\n                target: s,\n                color: o,\n                scale: r,\n                property: l\n            }), t.restore();\n        }(t, {\n            line: n,\n            target: s,\n            above: c,\n            below: d,\n            area: i,\n            scale: o,\n            axis: a\n        }), ze(t));\n    }\n    function ua(t, e, i) {\n        const { segments: s, points: n } = e;\n        let o = !0, a = !1;\n        t.beginPath();\n        for (const r of s){\n            const { start: s, end: l } = r, h = n[s], c = n[ea(s, l, n)];\n            o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\n                move: a\n            }), a ? t.closePath() : t.lineTo(c.x, i);\n        }\n        t.lineTo(e.first().x, i), t.closePath(), t.clip();\n    }\n    function fa(t, e) {\n        const { line: i, target: s, property: n, color: o, scale: a } = e, r = function(t, e, i) {\n            const s = t.segments, n = t.points, o = e.points, a = [];\n            for (const t of s){\n                let { start: s, end: r } = t;\n                r = ea(s, r, n);\n                const l = ta(i, n[s], n[r], t.loop);\n                if (!e.segments) {\n                    a.push({\n                        source: t,\n                        target: l,\n                        start: n[s],\n                        end: n[r]\n                    });\n                    continue;\n                }\n                const h = Ii(e, l);\n                for (const e of h){\n                    const s = ta(i, o[e.start], o[e.end], e.loop), r = Ri(t, n, s);\n                    for (const t of r)a.push({\n                        source: t,\n                        target: e,\n                        start: {\n                            [i]: ia(l, s, \"start\", Math.max)\n                        },\n                        end: {\n                            [i]: ia(l, s, \"end\", Math.min)\n                        }\n                    });\n                }\n            }\n            return a;\n        }(i, s, n);\n        for (const { source: e, target: l, start: h, end: c } of r){\n            const { style: { backgroundColor: r = o } = {} } = e, d = !0 !== s;\n            t.save(), t.fillStyle = r, ga(t, a, d && ta(n, h, c)), t.beginPath();\n            const u = !!i.pathSegment(t, e);\n            let f;\n            if (d) {\n                u ? t.closePath() : pa(t, s, c, n);\n                const e = !!s.pathSegment(t, l, {\n                    move: u,\n                    reverse: !0\n                });\n                f = u && e, f || pa(t, s, h, n);\n            }\n            t.closePath(), t.fill(f ? \"evenodd\" : \"nonzero\"), t.restore();\n        }\n    }\n    function ga(t, e, i) {\n        const { top: s, bottom: n } = e.chart.chartArea, { property: o, start: a, end: r } = i || {};\n        \"x\" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip());\n    }\n    function pa(t, e, i, s) {\n        const n = e.interpolate(i, s);\n        n && t.lineTo(n.x, n.y);\n    }\n    var ma = {\n        id: \"filler\",\n        afterDatasetsUpdate (t, e, i) {\n            const s = (t.data.datasets || []).length, n = [];\n            let o, a, r, l;\n            for(a = 0; a < s; ++a)o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof no && (l = {\n                visible: t.isDatasetVisible(a),\n                index: a,\n                fill: aa(r, a, s),\n                chart: t,\n                axis: o.controller.options.indexAxis,\n                scale: o.vScale,\n                line: r\n            }), o.$filler = l, n.push(l);\n            for(a = 0; a < s; ++a)l = n[a], l && !1 !== l.fill && (l.fill = oa(n, a, i.propagate));\n        },\n        beforeDraw (t, e, i) {\n            const s = \"beforeDraw\" === i.drawTime, n = t.getSortedVisibleDatasetMetas(), o = t.chartArea;\n            for(let e = n.length - 1; e >= 0; --e){\n                const i = n[e].$filler;\n                i && (i.line.updateControlPoints(o, i.axis), s && i.fill && da(t.ctx, i, o));\n            }\n        },\n        beforeDatasetsDraw (t, e, i) {\n            if (\"beforeDatasetsDraw\" !== i.drawTime) return;\n            const s = t.getSortedVisibleDatasetMetas();\n            for(let e = s.length - 1; e >= 0; --e){\n                const i = s[e].$filler;\n                na(i) && da(t.ctx, i, t.chartArea);\n            }\n        },\n        beforeDatasetDraw (t, e, i) {\n            const s = e.meta.$filler;\n            na(s) && \"beforeDatasetDraw\" === i.drawTime && da(t.ctx, s, t.chartArea);\n        },\n        defaults: {\n            propagate: !0,\n            drawTime: \"beforeDatasetDraw\"\n        }\n    };\n    const xa = (t, e)=>{\n        let { boxHeight: i = e, boxWidth: s = e } = t;\n        return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\n            boxWidth: s,\n            boxHeight: i,\n            itemHeight: Math.max(e, i)\n        };\n    };\n    class ba extends Hs {\n        constructor(t){\n            super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e, i) {\n            this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n        }\n        buildLabels() {\n            const t = this.options.labels || {};\n            let e = d(t.generateLabels, [\n                this.chart\n            ], this) || [];\n            t.filter && (e = e.filter((e)=>t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i)=>t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n        }\n        fit() {\n            const { options: t, ctx: e } = this;\n            if (!t.display) return void (this.width = this.height = 0);\n            const i = t.labels, s = Si(i.font), n = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: r } = xa(i, n);\n            let l, h;\n            e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n        }\n        _fitRows(t, e, i, s) {\n            const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [\n                0\n            ], h = s + a;\n            let c = t;\n            n.textAlign = \"left\", n.textBaseline = \"middle\";\n            let d = -1, u = -h;\n            return this.legendItems.forEach((t, f)=>{\n                const g = i + e / 2 + n.measureText(t.text).width;\n                (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\n                    left: 0,\n                    top: u,\n                    row: d,\n                    width: g,\n                    height: s\n                }, l[l.length - 1] += g + a;\n            }), c;\n        }\n        _fitCols(t, e, i, s) {\n            const { ctx: n, maxHeight: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;\n            let c = a, d = 0, u = 0, f = 0, g = 0;\n            return this.legendItems.forEach((t, o)=>{\n                const { itemWidth: p, itemHeight: m } = function(t, e, i, s, n) {\n                    const o = function(t, e, i, s) {\n                        let n = t.text;\n                        n && \"string\" != typeof n && (n = n.reduce((t, e)=>t.length > e.length ? t : e));\n                        return e + i.size / 2 + s.measureText(n).width;\n                    }(s, t, e, i), a = function(t, e, i) {\n                        let s = t;\n                        \"string\" != typeof e.text && (s = _a(e, i));\n                        return s;\n                    }(n, s, e.lineHeight);\n                    return {\n                        itemWidth: o,\n                        itemHeight: a\n                    };\n                }(i, e, n, t, s);\n                o > 0 && u + m + 2 * a > h && (c += d + a, l.push({\n                    width: d,\n                    height: u\n                }), f += d + a, g++, d = u = 0), r[o] = {\n                    left: f,\n                    top: u,\n                    col: g,\n                    width: p,\n                    height: m\n                }, d = Math.max(d, p), u += m + a;\n            }), c += d, l.push({\n                width: d,\n                height: u\n            }), c;\n        }\n        adjustHitBoxes() {\n            if (!this.options.display) return;\n            const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, o = Oi(n, this.left, this.width);\n            if (this.isHorizontal()) {\n                let n = 0, a = ft(i, this.left + s, this.right - this.lineWidths[n]);\n                for (const r of e)n !== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s;\n            } else {\n                let n = 0, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\n                for (const r of e)r.col !== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s;\n            }\n        }\n        isHorizontal() {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n        }\n        draw() {\n            if (this.options.display) {\n                const t = this.ctx;\n                Ie(t, this), this._draw(), ze(t);\n            }\n        }\n        _draw() {\n            const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: n, labels: o } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), { padding: c } = o, d = h.size, u = d / 2;\n            let f;\n            this.drawTitle(), s.textAlign = r.textAlign(\"left\"), s.textBaseline = \"middle\", s.lineWidth = .5, s.font = h.string;\n            const { boxWidth: g, boxHeight: p, itemHeight: m } = xa(o, d), x = this.isHorizontal(), b = this._computeTitleHeight();\n            f = x ? {\n                x: ft(n, this.left + c, this.right - i[0]),\n                y: this.top + c + b,\n                line: 0\n            } : {\n                x: this.left + c,\n                y: ft(n, this.top + b + c, this.bottom - e[0].height),\n                line: 0\n            }, Ai(this.ctx, t.textDirection);\n            const _ = m + c;\n            this.legendItems.forEach((y, v)=>{\n                s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;\n                const M = s.measureText(y.text).width, w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = g + u + M;\n                let S = f.x, P = f.y;\n                r.setWidth(this.width), x ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + b + c, this.bottom - e[f.line].height));\n                if (function(t, e, i) {\n                    if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return;\n                    s.save();\n                    const n = l(i.lineWidth, 1);\n                    if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, \"butt\"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, \"miter\"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {\n                        const a = {\n                            radius: p * Math.SQRT2 / 2,\n                            pointStyle: i.pointStyle,\n                            rotation: i.rotation,\n                            borderWidth: n\n                        }, l = r.xPlus(t, g / 2);\n                        Ee(s, a, l, e + u, o.pointStyleWidth && g);\n                    } else {\n                        const o = e + Math.max((d - p) / 2, 0), a = r.leftForLtr(t, g), l = wi(i.borderRadius);\n                        s.beginPath(), Object.values(l).some((t)=>0 !== t) ? He(s, {\n                            x: a,\n                            y: o,\n                            w: g,\n                            h: p,\n                            radius: l\n                        }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke();\n                    }\n                    s.restore();\n                }(r.x(S), P, y), S = gt(w, S + g + u, x ? S + k : this.right, t.rtl), function(t, e, i) {\n                    Ne(s, i.text, t, e + m / 2, h, {\n                        strikethrough: i.hidden,\n                        textAlign: r.textAlign(i.textAlign)\n                    });\n                }(r.x(S), P, y), x) f.x += k + c;\n                else if (\"string\" != typeof y.text) {\n                    const t = h.lineHeight;\n                    f.y += _a(y, t) + c;\n                } else f.y += _;\n            }), Ti(this.ctx, t.textDirection);\n        }\n        drawTitle() {\n            const t = this.options, e = t.title, i = Si(e.font), s = ki(e.padding);\n            if (!e.display) return;\n            const n = Oi(t.rtl, this.left, this.width), o = this.ctx, a = e.position, r = i.size / 2, l = s.top + r;\n            let h, c = this.left, d = this.width;\n            if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);\n            else {\n                const e = this.columnSizes.reduce((t, e)=>Math.max(t, e.height), 0);\n                h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight());\n            }\n            const u = ft(a, c, c + d);\n            o.textAlign = n.textAlign(ut(a)), o.textBaseline = \"middle\", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i);\n        }\n        _computeTitleHeight() {\n            const t = this.options.title, e = Si(t.font), i = ki(t.padding);\n            return t.display ? e.lineHeight + i.height : 0;\n        }\n        _getLegendItemAt(t, e) {\n            let i, s, n;\n            if (tt(t, this.left, this.right) && tt(e, this.top, this.bottom)) {\n                for(n = this.legendHitBoxes, i = 0; i < n.length; ++i)if (s = n[i], tt(t, s.left, s.left + s.width) && tt(e, s.top, s.top + s.height)) return this.legendItems[i];\n            }\n            return null;\n        }\n        handleEvent(t) {\n            const e = this.options;\n            if (!function(t, e) {\n                if ((\"mousemove\" === t || \"mouseout\" === t) && (e.onHover || e.onLeave)) return !0;\n                if (e.onClick && (\"click\" === t || \"mouseup\" === t)) return !0;\n                return !1;\n            }(t.type, e)) return;\n            const i = this._getLegendItemAt(t.x, t.y);\n            if (\"mousemove\" === t.type || \"mouseout\" === t.type) {\n                const o = this._hoveredItem, a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);\n                o && !a && d(e.onLeave, [\n                    t,\n                    o,\n                    this\n                ], this), this._hoveredItem = i, i && !a && d(e.onHover, [\n                    t,\n                    i,\n                    this\n                ], this);\n            } else i && d(e.onClick, [\n                t,\n                i,\n                this\n            ], this);\n            var s, n;\n        }\n    }\n    function _a(t, e) {\n        return e * (t.text ? t.text.length : 0);\n    }\n    var ya = {\n        id: \"legend\",\n        _element: ba,\n        start (t, e, i) {\n            const s = t.legend = new ba({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, t.legend), delete t.legend;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.legend;\n            as.configure(t, s, i), s.options = i;\n        },\n        afterUpdate (t) {\n            const e = t.legend;\n            e.buildLabels(), e.adjustHitBoxes();\n        },\n        afterEvent (t, e) {\n            e.replay || t.legend.handleEvent(e.event);\n        },\n        defaults: {\n            display: !0,\n            position: \"top\",\n            align: \"center\",\n            fullSize: !0,\n            reverse: !1,\n            weight: 1e3,\n            onClick (t, e, i) {\n                const s = e.datasetIndex, n = i.chart;\n                n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1);\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                color: (t)=>t.chart.options.color,\n                boxWidth: 40,\n                padding: 10,\n                generateLabels (t) {\n                    const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: s, textAlign: n, color: o, useBorderRadius: a, borderRadius: r } } = t.legend.options;\n                    return t._getSortedDatasetMetas().map((t)=>{\n                        const l = t.controller.getStyle(i ? 0 : void 0), h = ki(l.borderWidth);\n                        return {\n                            text: e[t.index].label,\n                            fillStyle: l.backgroundColor,\n                            fontColor: o,\n                            hidden: !t.visible,\n                            lineCap: l.borderCapStyle,\n                            lineDash: l.borderDash,\n                            lineDashOffset: l.borderDashOffset,\n                            lineJoin: l.borderJoinStyle,\n                            lineWidth: (h.width + h.height) / 4,\n                            strokeStyle: l.borderColor,\n                            pointStyle: s || l.pointStyle,\n                            rotation: l.rotation,\n                            textAlign: n || l.textAlign,\n                            borderRadius: a && (r || l.borderRadius),\n                            datasetIndex: t.index\n                        };\n                    }, this);\n                }\n            },\n            title: {\n                color: (t)=>t.chart.options.color,\n                display: !1,\n                position: \"center\",\n                text: \"\"\n            }\n        },\n        descriptors: {\n            _scriptable: (t)=>!t.startsWith(\"on\"),\n            labels: {\n                _scriptable: (t)=>![\n                        \"generateLabels\",\n                        \"filter\",\n                        \"sort\"\n                    ].includes(t)\n            }\n        }\n    };\n    class va extends Hs {\n        constructor(t){\n            super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e) {\n            const i = this.options;\n            if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);\n            this.width = this.right = t, this.height = this.bottom = e;\n            const s = n(i.text) ? i.text.length : 1;\n            this._padding = ki(i.padding);\n            const o = s * Si(i.font).lineHeight + this._padding.height;\n            this.isHorizontal() ? this.height = o : this.width = o;\n        }\n        isHorizontal() {\n            const t = this.options.position;\n            return \"top\" === t || \"bottom\" === t;\n        }\n        _drawArgs(t) {\n            const { top: e, left: i, bottom: s, right: n, options: o } = this, a = o.align;\n            let r, l, h, c = 0;\n            return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : (\"left\" === o.position ? (l = i + t, h = ft(a, s, e), c = -0.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {\n                titleX: l,\n                titleY: h,\n                maxWidth: r,\n                rotation: c\n            };\n        }\n        draw() {\n            const t = this.ctx, e = this.options;\n            if (!e.display) return;\n            const i = Si(e.font), s = i.lineHeight / 2 + this._padding.top, { titleX: n, titleY: o, maxWidth: a, rotation: r } = this._drawArgs(s);\n            Ne(t, e.text, 0, 0, i, {\n                color: e.color,\n                maxWidth: a,\n                rotation: r,\n                textAlign: ut(e.align),\n                textBaseline: \"middle\",\n                translation: [\n                    n,\n                    o\n                ]\n            });\n        }\n    }\n    var Ma = {\n        id: \"title\",\n        _element: va,\n        start (t, e, i) {\n            !function(t, e) {\n                const i = new va({\n                    ctx: t.ctx,\n                    options: e,\n                    chart: t\n                });\n                as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i;\n            }(t, i);\n        },\n        stop (t) {\n            const e = t.titleBlock;\n            as.removeBox(t, e), delete t.titleBlock;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.titleBlock;\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"bold\"\n            },\n            fullSize: !0,\n            padding: 10,\n            position: \"top\",\n            text: \"\",\n            weight: 2e3\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const wa = new WeakMap;\n    var ka = {\n        id: \"subtitle\",\n        start (t, e, i) {\n            const s = new va({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s), wa.set(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, wa.get(t)), wa.delete(t);\n        },\n        beforeUpdate (t, e, i) {\n            const s = wa.get(t);\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"normal\"\n            },\n            fullSize: !0,\n            padding: 0,\n            position: \"top\",\n            text: \"\",\n            weight: 1500\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const Sa = {\n        average (t) {\n            if (!t.length) return !1;\n            let e, i, s = new Set, n = 0, o = 0;\n            for(e = 0, i = t.length; e < i; ++e){\n                const i = t[e].element;\n                if (i && i.hasValue()) {\n                    const t = i.tooltipPosition();\n                    s.add(t.x), n += t.y, ++o;\n                }\n            }\n            if (0 === o || 0 === s.size) return !1;\n            return {\n                x: [\n                    ...s\n                ].reduce((t, e)=>t + e) / s.size,\n                y: n / o\n            };\n        },\n        nearest (t, e) {\n            if (!t.length) return !1;\n            let i, s, n, o = e.x, a = e.y, r = Number.POSITIVE_INFINITY;\n            for(i = 0, s = t.length; i < s; ++i){\n                const s = t[i].element;\n                if (s && s.hasValue()) {\n                    const t = q(e, s.getCenterPoint());\n                    t < r && (r = t, n = s);\n                }\n            }\n            if (n) {\n                const t = n.tooltipPosition();\n                o = t.x, a = t.y;\n            }\n            return {\n                x: o,\n                y: a\n            };\n        }\n    };\n    function Pa(t, e) {\n        return e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n    }\n    function Da(t) {\n        return (\"string\" == typeof t || t instanceof String) && t.indexOf(\"\\n\") > -1 ? t.split(\"\\n\") : t;\n    }\n    function Ca(t, e) {\n        const { element: i, datasetIndex: s, index: n } = e, o = t.getDatasetMeta(s).controller, { label: a, value: r } = o.getLabelAndValue(n);\n        return {\n            chart: t,\n            label: a,\n            parsed: o.getParsed(n),\n            raw: t.data.datasets[s].data[n],\n            formattedValue: r,\n            dataset: o.getDataset(),\n            dataIndex: n,\n            datasetIndex: s,\n            element: i\n        };\n    }\n    function Oa(t, e) {\n        const i = t.chart.ctx, { body: s, footer: n, title: o } = t, { boxWidth: a, boxHeight: r } = e, l = Si(e.bodyFont), h = Si(e.titleFont), c = Si(e.footerFont), d = o.length, f = n.length, g = s.length, p = ki(e.padding);\n        let m = p.height, x = 0, b = s.reduce((t, e)=>t + e.before.length + e.lines.length + e.after.length, 0);\n        if (b += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (b - g) * l.lineHeight + (b - 1) * e.bodySpacing;\n        f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\n        let _ = 0;\n        const y = function(t) {\n            x = Math.max(x, i.measureText(t).width + _);\n        };\n        return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t)=>{\n            u(t.before, y), u(t.lines, y), u(t.after, y);\n        }), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), x += p.width, {\n            width: x,\n            height: m\n        };\n    }\n    function Aa(t, e, i, s) {\n        const { x: n, width: o } = i, { width: a, chartArea: { left: r, right: l } } = t;\n        let h = \"center\";\n        return \"center\" === s ? h = n <= (r + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? h = \"left\" : n >= a - o / 2 && (h = \"right\"), function(t, e, i, s) {\n            const { x: n, width: o } = s, a = i.caretSize + i.caretPadding;\n            return \"left\" === t && n + o + a > e.width || \"right\" === t && n - o - a < 0 || void 0;\n        }(h, t, e, i) && (h = \"center\"), h;\n    }\n    function Ta(t, e, i) {\n        const s = i.yAlign || e.yAlign || function(t, e) {\n            const { y: i, height: s } = e;\n            return i < s / 2 ? \"top\" : i > t.height - s / 2 ? \"bottom\" : \"center\";\n        }(t, i);\n        return {\n            xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s),\n            yAlign: s\n        };\n    }\n    function La(t, e, i, s) {\n        const { caretSize: n, caretPadding: o, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, h = n + o, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(a);\n        let g = function(t, e) {\n            let { x: i, width: s } = t;\n            return \"right\" === e ? i -= s : \"center\" === e && (i -= s / 2), i;\n        }(e, r);\n        const p = function(t, e, i) {\n            let { y: s, height: n } = t;\n            return \"top\" === e ? s += i : s -= \"bottom\" === e ? n + i : n / 2, s;\n        }(e, l, h);\n        return \"center\" === l ? \"left\" === r ? g += h : \"right\" === r && (g -= h) : \"left\" === r ? g -= Math.max(c, u) + n : \"right\" === r && (g += Math.max(d, f) + n), {\n            x: J(g, 0, s.width - e.width),\n            y: J(p, 0, s.height - e.height)\n        };\n    }\n    function Ea(t, e, i) {\n        const s = ki(i.padding);\n        return \"center\" === e ? t.x + t.width / 2 : \"right\" === e ? t.x + t.width - s.right : t.x + s.left;\n    }\n    function Ra(t) {\n        return Pa([], Da(t));\n    }\n    function Ia(t, e) {\n        const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;\n        return i ? t.override(i) : t;\n    }\n    const za = {\n        beforeTitle: e,\n        title (t) {\n            if (t.length > 0) {\n                const e = t[0], i = e.chart.data.labels, s = i ? i.length : 0;\n                if (this && this.options && \"dataset\" === this.options.mode) return e.dataset.label || \"\";\n                if (e.label) return e.label;\n                if (s > 0 && e.dataIndex < s) return i[e.dataIndex];\n            }\n            return \"\";\n        },\n        afterTitle: e,\n        beforeBody: e,\n        beforeLabel: e,\n        label (t) {\n            if (this && this.options && \"dataset\" === this.options.mode) return t.label + \": \" + t.formattedValue || t.formattedValue;\n            let e = t.dataset.label || \"\";\n            e && (e += \": \");\n            const i = t.formattedValue;\n            return s(i) || (e += i), e;\n        },\n        labelColor (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                borderColor: e.borderColor,\n                backgroundColor: e.backgroundColor,\n                borderWidth: e.borderWidth,\n                borderDash: e.borderDash,\n                borderDashOffset: e.borderDashOffset,\n                borderRadius: 0\n            };\n        },\n        labelTextColor () {\n            return this.options.bodyColor;\n        },\n        labelPointStyle (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                pointStyle: e.pointStyle,\n                rotation: e.rotation\n            };\n        },\n        afterLabel: e,\n        afterBody: e,\n        beforeFooter: e,\n        footer: e,\n        afterFooter: e\n    };\n    function Fa(t, e, i, s) {\n        const n = t[e].call(i, s);\n        return void 0 === n ? za[e].call(i, s) : n;\n    }\n    class Va extends Hs {\n        static positioners = Sa;\n        constructor(t){\n            super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n        }\n        initialize(t) {\n            this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n        }\n        _resolveAnimations() {\n            const t = this._cachedAnimations;\n            if (t) return t;\n            const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new Os(this.chart, s);\n            return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;\n        }\n        getContext() {\n            var t, e, i;\n            return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {\n                tooltip: e,\n                tooltipItems: i,\n                type: \"tooltip\"\n            })));\n        }\n        getTitle(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeTitle\", this, t), n = Fa(i, \"title\", this, t), o = Fa(i, \"afterTitle\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        getBeforeBody(t, e) {\n            return Ra(Fa(e.callbacks, \"beforeBody\", this, t));\n        }\n        getBody(t, e) {\n            const { callbacks: i } = e, s = [];\n            return u(t, (t)=>{\n                const e = {\n                    before: [],\n                    lines: [],\n                    after: []\n                }, n = Ia(i, t);\n                Pa(e.before, Da(Fa(n, \"beforeLabel\", this, t))), Pa(e.lines, Fa(n, \"label\", this, t)), Pa(e.after, Da(Fa(n, \"afterLabel\", this, t))), s.push(e);\n            }), s;\n        }\n        getAfterBody(t, e) {\n            return Ra(Fa(e.callbacks, \"afterBody\", this, t));\n        }\n        getFooter(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeFooter\", this, t), n = Fa(i, \"footer\", this, t), o = Fa(i, \"afterFooter\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        _createItems(t) {\n            const e = this._active, i = this.chart.data, s = [], n = [], o = [];\n            let a, r, l = [];\n            for(a = 0, r = e.length; a < r; ++a)l.push(Ca(this.chart, e[a]));\n            return t.filter && (l = l.filter((e, s, n)=>t.filter(e, s, n, i))), t.itemSort && (l = l.sort((e, s)=>t.itemSort(e, s, i))), u(l, (e)=>{\n                const i = Ia(t.callbacks, e);\n                s.push(Fa(i, \"labelColor\", this, e)), n.push(Fa(i, \"labelPointStyle\", this, e)), o.push(Fa(i, \"labelTextColor\", this, e));\n            }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l;\n        }\n        update(t, e) {\n            const i = this.options.setContext(this.getContext()), s = this._active;\n            let n, o = [];\n            if (s.length) {\n                const t = Sa[i.position].call(this, s, this._eventPosition);\n                o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\n                const e = this._size = Oa(this, i), a = Object.assign({}, t, e), r = Ta(this.chart, i, a), l = La(i, a, r, this.chart);\n                this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\n                    opacity: 1,\n                    x: l.x,\n                    y: l.y,\n                    width: e.width,\n                    height: e.height,\n                    caretX: t.x,\n                    caretY: t.y\n                };\n            } else 0 !== this.opacity && (n = {\n                opacity: 0\n            });\n            this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay: e\n            });\n        }\n        drawCaret(t, e, i, s) {\n            const n = this.getCaretPosition(t, i, s);\n            e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);\n        }\n        getCaretPosition(t, e, i) {\n            const { xAlign: s, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: r, topRight: l, bottomLeft: h, bottomRight: c } = wi(a), { x: d, y: u } = t, { width: f, height: g } = e;\n            let p, m, x, b, _, y;\n            return \"center\" === n ? (_ = u + g / 2, \"left\" === s ? (p = d, m = p - o, b = _ + o, y = _ - o) : (p = d + f, m = p + o, b = _ - o, y = _ + o), x = p) : (m = \"left\" === s ? d + Math.max(r, h) + o : \"right\" === s ? d + f - Math.max(l, c) - o : this.caretX, \"top\" === n ? (b = u, _ = b - o, p = m - o, x = m + o) : (b = u + g, _ = b + o, p = m + o, x = m - o), y = b), {\n                x1: p,\n                x2: m,\n                x3: x,\n                y1: b,\n                y2: _,\n                y3: y\n            };\n        }\n        drawTitle(t, e, i) {\n            const s = this.title, n = s.length;\n            let o, a, r;\n            if (n) {\n                const l = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = \"middle\", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r)e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a);\n            }\n        }\n        _drawColorBox(t, e, i, s, n) {\n            const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h } = n, c = Si(n.bodyFont), d = Ea(this, \"left\", n), u = s.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = e.y + f;\n            if (n.usePointStyle) {\n                const e = {\n                    radius: Math.min(h, l) / 2,\n                    pointStyle: r.pointStyle,\n                    rotation: r.rotation,\n                    borderWidth: 1\n                }, i = s.leftForLtr(u, h) + h / 2, o = g + l / 2;\n                t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o);\n            } else {\n                t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\n                const e = s.leftForLtr(u, h), i = s.leftForLtr(s.xPlus(u, 1), h - 2), r = wi(a.borderRadius);\n                Object.values(r).some((t)=>0 !== t) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {\n                    x: e,\n                    y: g,\n                    w: h,\n                    h: l,\n                    radius: r\n                }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {\n                    x: i,\n                    y: g + 1,\n                    w: h - 2,\n                    h: l - 2,\n                    radius: r\n                }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2));\n            }\n            t.fillStyle = this.labelTextColors[i];\n        }\n        drawBody(t, e, i) {\n            const { body: s } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h } = i, c = Si(i.bodyFont);\n            let d = c.lineHeight, f = 0;\n            const g = Oi(i.rtl, this.x, this.width), p = function(i) {\n                e.fillText(i, g.x(t.x + f), t.y + d / 2), t.y += d + n;\n            }, m = g.textAlign(o);\n            let x, b, _, y, v, M, w;\n            for(e.textAlign = o, e.textBaseline = \"middle\", e.font = c.string, t.x = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a && \"right\" !== m ? \"center\" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.length; y < M; ++y){\n                for(x = s[y], b = this.labelTextColors[y], e.fillStyle = b, u(x.before, p), _ = x.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v < w; ++v)p(_[v]), d = c.lineHeight;\n                u(x.after, p);\n            }\n            f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n;\n        }\n        drawFooter(t, e, i) {\n            const s = this.footer, n = s.length;\n            let o, a;\n            if (n) {\n                const r = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = \"middle\", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a)e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;\n            }\n        }\n        drawBackground(t, e, i, s) {\n            const { xAlign: n, yAlign: o } = this, { x: a, y: r } = t, { width: l, height: h } = i, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(s.cornerRadius);\n            e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), \"top\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), \"center\" === o && \"right\" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), \"bottom\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), \"center\" === o && \"left\" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();\n        }\n        _updateAnimationTarget(t) {\n            const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y;\n            if (s || n) {\n                const i = Sa[t.position].call(this, this._active, this._eventPosition);\n                if (!i) return;\n                const o = this._size = Oa(this, t), a = Object.assign({}, i, this._size), r = Ta(e, t, a), l = La(t, a, r, e);\n                s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l));\n            }\n        }\n        _willRender() {\n            return !!this.opacity;\n        }\n        draw(t) {\n            const e = this.options.setContext(this.getContext());\n            let i = this.opacity;\n            if (!i) return;\n            this._updateAnimationTarget(e);\n            const s = {\n                width: this.width,\n                height: this.height\n            }, n = {\n                x: this.x,\n                y: this.y\n            };\n            i = Math.abs(i) < .001 ? 0 : i;\n            const o = ki(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n            e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore());\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t, e) {\n            const i = this._active, s = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.chart.getDatasetMeta(t);\n                if (!i) throw new Error(\"Cannot find a dataset at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            }), n = !f(i, s), o = this._positionChanged(s, e);\n            (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n        }\n        handleEvent(t, e, i = !0) {\n            if (e && this._ignoreReplayEvents) return !1;\n            this._ignoreReplayEvents = !1;\n            const s = this.options, n = this._active || [], o = this._getActiveElements(t, n, e, i), a = this._positionChanged(o, t), r = e || !f(o, n) || a;\n            return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {\n                x: t.x,\n                y: t.y\n            }, this.update(!0, e))), r;\n        }\n        _getActiveElements(t, e, i, s) {\n            const n = this.options;\n            if (\"mouseout\" === t.type) return [];\n            if (!s) return e.filter((t)=>this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index));\n            const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\n            return n.reverse && o.reverse(), o;\n        }\n        _positionChanged(t, e) {\n            const { caretX: i, caretY: s, options: n } = this, o = Sa[n.position].call(this, t, e);\n            return !1 !== o && (i !== o.x || s !== o.y);\n        }\n    }\n    var Ba = {\n        id: \"tooltip\",\n        _element: Va,\n        positioners: Sa,\n        afterInit (t, e, i) {\n            i && (t.tooltip = new Va({\n                chart: t,\n                options: i\n            }));\n        },\n        beforeUpdate (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        reset (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        afterDraw (t) {\n            const e = t.tooltip;\n            if (e && e._willRender()) {\n                const i = {\n                    tooltip: e\n                };\n                if (!1 === t.notifyPlugins(\"beforeTooltipDraw\", {\n                    ...i,\n                    cancelable: !0\n                })) return;\n                e.draw(t.ctx), t.notifyPlugins(\"afterTooltipDraw\", i);\n            }\n        },\n        afterEvent (t, e) {\n            if (t.tooltip) {\n                const i = e.replay;\n                t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);\n            }\n        },\n        defaults: {\n            enabled: !0,\n            external: null,\n            position: \"average\",\n            backgroundColor: \"rgba(0,0,0,0.8)\",\n            titleColor: \"#fff\",\n            titleFont: {\n                weight: \"bold\"\n            },\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleAlign: \"left\",\n            bodyColor: \"#fff\",\n            bodySpacing: 2,\n            bodyFont: {},\n            bodyAlign: \"left\",\n            footerColor: \"#fff\",\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFont: {\n                weight: \"bold\"\n            },\n            footerAlign: \"left\",\n            padding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            boxHeight: (t, e)=>e.bodyFont.size,\n            boxWidth: (t, e)=>e.bodyFont.size,\n            multiKeyBackground: \"#fff\",\n            displayColors: !0,\n            boxPadding: 0,\n            borderColor: \"rgba(0,0,0,0)\",\n            borderWidth: 0,\n            animation: {\n                duration: 400,\n                easing: \"easeOutQuart\"\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"width\",\n                        \"height\",\n                        \"caretX\",\n                        \"caretY\"\n                    ]\n                },\n                opacity: {\n                    easing: \"linear\",\n                    duration: 200\n                }\n            },\n            callbacks: za\n        },\n        defaultRoutes: {\n            bodyFont: \"font\",\n            footerFont: \"font\",\n            titleFont: \"font\"\n        },\n        descriptors: {\n            _scriptable: (t)=>\"filter\" !== t && \"itemSort\" !== t && \"external\" !== t,\n            _indexable: !1,\n            callbacks: {\n                _scriptable: !1,\n                _indexable: !1\n            },\n            animation: {\n                _fallback: !1\n            },\n            animations: {\n                _fallback: \"animation\"\n            }\n        },\n        additionalOptionScopes: [\n            \"interaction\"\n        ]\n    };\n    return An.register(Yn, jo, fo, t), An.helpers = {\n        ...Wi\n    }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = bt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, \"undefined\" != typeof window && (window.Chart = An), An;\n});\n\n//# sourceMappingURL=walkthrough.6c82c9da.js.map\n","/*!\n * Chart.js v4.4.8\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){\"use strict\";var t=Object.freeze({__proto__:null,get Colors(){return Go},get Decimation(){return Qo},get Filler(){return ma},get Legend(){return ya},get SubTitle(){return ka},get Title(){return Ma},get Tooltip(){return Ba}});function e(){}const i=(()=>{let t=0;return()=>t++})();function s(t){return null==t}function n(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return\"[object\"===e.slice(0,7)&&\"Array]\"===e.slice(-6)}function o(t){return null!==t&&\"[object Object]\"===Object.prototype.toString.call(t)}function a(t){return(\"number\"==typeof t||t instanceof Number)&&isFinite(+t)}function r(t,e){return a(t)?t:e}function l(t,e){return void 0===t?e:t}const h=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100:+t/e,c=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100*e:+t;function d(t,e,i){if(t&&\"function\"==typeof t.call)return t.apply(i,e)}function u(t,e,i,s){let a,r,l;if(n(t))if(r=t.length,s)for(a=r-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<r;a++)e.call(i,t[a],a);else if(o(t))for(l=Object.keys(t),r=l.length,a=0;a<r;a++)e.call(i,t[l[a]],l[a])}function f(t,e){let i,s,n,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,s=t.length;i<s;++i)if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)return!1;return!0}function g(t){if(n(t))return t.map(g);if(o(t)){const e=Object.create(null),i=Object.keys(t),s=i.length;let n=0;for(;n<s;++n)e[i[n]]=g(t[i[n]]);return e}return t}function p(t){return-1===[\"__proto__\",\"prototype\",\"constructor\"].indexOf(t)}function m(t,e,i,s){if(!p(t))return;const n=e[t],a=i[t];o(n)&&o(a)?x(n,a,s):e[t]=g(a)}function x(t,e,i){const s=n(e)?e:[e],a=s.length;if(!o(t))return t;const r=(i=i||{}).merger||m;let l;for(let e=0;e<a;++e){if(l=s[e],!o(l))continue;const n=Object.keys(l);for(let e=0,s=n.length;e<s;++e)r(n[e],t,l,i)}return t}function b(t,e){return x(t,e,{merger:_})}function _(t,e,i){if(!p(t))return;const s=e[t],n=i[t];o(s)&&o(n)?b(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=g(n))}const y={\"\":t=>t,x:t=>t.x,y:t=>t.y};function v(t){const e=t.split(\".\"),i=[];let s=\"\";for(const t of e)s+=t,s.endsWith(\"\\\\\")?s=s.slice(0,-1)+\".\":(i.push(s),s=\"\");return i}function M(t,e){const i=y[e]||(y[e]=function(t){const e=v(t);return t=>{for(const i of e){if(\"\"===i)break;t=t&&t[i]}return t}}(e));return i(t)}function w(t){return t.charAt(0).toUpperCase()+t.slice(1)}const k=t=>void 0!==t,S=t=>\"function\"==typeof t,P=(t,e)=>{if(t.size!==e.size)return!1;for(const i of t)if(!e.has(i))return!1;return!0};function D(t){return\"mouseup\"===t.type||\"click\"===t.type||\"contextmenu\"===t.type}const C=Math.PI,O=2*C,A=O+C,T=Number.POSITIVE_INFINITY,L=C/180,E=C/2,R=C/4,I=2*C/3,z=Math.log10,F=Math.sign;function V(t,e,i){return Math.abs(t-e)<i}function B(t){const e=Math.round(t);t=V(t,e,t/1e3)?e:t;const i=Math.pow(10,Math.floor(z(t))),s=t/i;return(s<=1?1:s<=2?2:s<=5?5:10)*i}function W(t){const e=[],i=Math.sqrt(t);let s;for(s=1;s<i;s++)t%s==0&&(e.push(s),e.push(t/s));return i===(0|i)&&e.push(i),e.sort(((t,e)=>t-e)).pop(),e}function N(t){return!function(t){return\"symbol\"==typeof t||\"object\"==typeof t&&null!==t&&!(Symbol.toPrimitive in t||\"toString\"in t||\"valueOf\"in t)}(t)&&!isNaN(parseFloat(t))&&isFinite(t)}function H(t,e){const i=Math.round(t);return i-e<=t&&i+e>=t}function j(t,e,i){let s,n,o;for(s=0,n=t.length;s<n;s++)o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}function $(t){return t*(C/180)}function Y(t){return t*(180/C)}function U(t){if(!a(t))return;let e=1,i=0;for(;Math.round(t*e)/e!==t;)e*=10,i++;return i}function X(t,e){const i=e.x-t.x,s=e.y-t.y,n=Math.sqrt(i*i+s*s);let o=Math.atan2(s,i);return o<-.5*C&&(o+=O),{angle:o,distance:n}}function q(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function K(t,e){return(t-e+A)%O-C}function G(t){return(t%O+O)%O}function Z(t,e,i,s){const n=G(t),o=G(e),a=G(i),r=G(o-n),l=G(a-n),h=G(n-o),c=G(n-a);return n===o||n===a||s&&o===a||r>l&&h<c}function J(t,e,i){return Math.max(e,Math.min(i,t))}function Q(t){return J(t,-32768,32767)}function tt(t,e,i,s=1e-6){return t>=Math.min(e,i)-s&&t<=Math.max(e,i)+s}function et(t,e,i){i=i||(i=>t[i]<e);let s,n=t.length-1,o=0;for(;n-o>1;)s=o+n>>1,i(s)?o=s:n=s;return{lo:o,hi:n}}const it=(t,e,i,s)=>et(t,i,s?s=>{const n=t[s][e];return n<i||n===i&&t[s+1][e]===i}:s=>t[s][e]<i),st=(t,e,i)=>et(t,i,(s=>t[s][e]>=i));function nt(t,e,i){let s=0,n=t.length;for(;s<n&&t[s]<e;)s++;for(;n>s&&t[n-1]>i;)n--;return s>0||n<t.length?t.slice(s,n):t}const ot=[\"push\",\"pop\",\"shift\",\"splice\",\"unshift\"];function at(t,e){t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,\"_chartjs\",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),ot.forEach((e=>{const i=\"_onData\"+w(e),s=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value(...e){const n=s.apply(this,e);return t._chartjs.listeners.forEach((t=>{\"function\"==typeof t[i]&&t[i](...e)})),n}})})))}function rt(t,e){const i=t._chartjs;if(!i)return;const s=i.listeners,n=s.indexOf(e);-1!==n&&s.splice(n,1),s.length>0||(ot.forEach((e=>{delete t[e]})),delete t._chartjs)}function lt(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const ht=\"undefined\"==typeof window?function(t){return t()}:window.requestAnimationFrame;function ct(t,e){let i=[],s=!1;return function(...n){i=n,s||(s=!0,ht.call(window,(()=>{s=!1,t.apply(e,i)})))}}function dt(t,e){let i;return function(...s){return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}}const ut=t=>\"start\"===t?\"left\":\"end\"===t?\"right\":\"center\",ft=(t,e,i)=>\"start\"===t?e:\"end\"===t?i:(e+i)/2,gt=(t,e,i,s)=>t===(s?\"left\":\"right\")?i:\"center\"===t?(e+i)/2:e;function pt(t,e,i){const n=e.length;let o=0,a=n;if(t._sorted){const{iScale:r,vScale:l,_parsed:h}=t,c=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null,d=r.axis,{min:u,max:f,minDefined:g,maxDefined:p}=r.getUserBounds();if(g){if(o=Math.min(it(h,d,u).lo,i?n:it(e,d,r.getPixelForValue(u)).lo),c){const t=h.slice(0,o+1).reverse().findIndex((t=>!s(t[l.axis])));o-=Math.max(0,t)}o=J(o,0,n-1)}if(p){let t=Math.max(it(h,r.axis,f,!0).hi+1,i?0:it(e,d,r.getPixelForValue(f),!0).hi+1);if(c){const e=h.slice(t-1).findIndex((t=>!s(t[l.axis])));t+=Math.max(0,e)}a=J(t,o,n)-o}else a=n-o}return{start:o,count:a}}function mt(t){const{xScale:e,yScale:i,_scaleRanges:s}=t,n={xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};if(!s)return t._scaleRanges=n,!0;const o=s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;return Object.assign(s,n),o}class xt{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,s){const n=e.listeners[s],o=e.duration;n.forEach((s=>s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)})))}_refresh(){this._request||(this._running=!0,this._request=ht.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((i,s)=>{if(!i.running||!i.items.length)return;const n=i.items;let o,a=n.length-1,r=!1;for(;a>=0;--a)o=n[a],o._active?(o._total>i.duration&&(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());r&&(s.draw(),this._notify(s,i,t,\"progress\")),n.length||(i.running=!1,this._notify(s,i,t,\"complete\"),i.initial=!1),e+=n.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let s=i.length-1;for(;s>=0;--s)i[s].cancel();e.items=[],this._notify(t,e,Date.now(),\"complete\")}remove(t){return this._charts.delete(t)}}var bt=new xt;\n/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */function _t(t){return t+.5|0}const yt=(t,e,i)=>Math.max(Math.min(t,i),e);function vt(t){return yt(_t(2.55*t),0,255)}function Mt(t){return yt(_t(255*t),0,255)}function wt(t){return yt(_t(t/2.55)/100,0,1)}function kt(t){return yt(_t(100*t),0,100)}const St={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Pt=[...\"0123456789ABCDEF\"],Dt=t=>Pt[15&t],Ct=t=>Pt[(240&t)>>4]+Pt[15&t],Ot=t=>(240&t)>>4==(15&t);function At(t){var e=(t=>Ot(t.r)&&Ot(t.g)&&Ot(t.b)&&Ot(t.a))(t)?Dt:Ct;return t?\"#\"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):\"\")(t.a,e):void 0}const Tt=/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function Lt(t,e,i){const s=e*Math.min(i,1-i),n=(e,n=(e+t/30)%12)=>i-s*Math.max(Math.min(n-3,9-n,1),-1);return[n(0),n(8),n(4)]}function Et(t,e,i){const s=(s,n=(s+t/60)%6)=>i-i*e*Math.max(Math.min(n,4-n,1),0);return[s(5),s(3),s(1)]}function Rt(t,e,i){const s=Lt(t,1,.5);let n;for(e+i>1&&(n=1/(e+i),e*=n,i*=n),n=0;n<3;n++)s[n]*=1-e-i,s[n]+=e;return s}function It(t){const e=t.r/255,i=t.g/255,s=t.b/255,n=Math.max(e,i,s),o=Math.min(e,i,s),a=(n+o)/2;let r,l,h;return n!==o&&(h=n-o,l=a>.5?h/(2-n-o):h/(n+o),r=function(t,e,i,s,n){return t===n?(e-i)/s+(e<i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}function zt(t,e,i,s){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(Mt)}function Ft(t,e,i){return zt(Lt,t,e,i)}function Vt(t){return(t%360+360)%360}function Bt(t){const e=Tt.exec(t);let i,s=255;if(!e)return;e[5]!==i&&(s=e[6]?vt(+e[5]):Mt(+e[5]));const n=Vt(+e[2]),o=+e[3]/100,a=+e[4]/100;return i=\"hwb\"===e[1]?function(t,e,i){return zt(Rt,t,e,i)}(n,o,a):\"hsv\"===e[1]?function(t,e,i){return zt(Et,t,e,i)}(n,o,a):Ft(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}const Wt={x:\"dark\",Z:\"light\",Y:\"re\",X:\"blu\",W:\"gr\",V:\"medium\",U:\"slate\",A:\"ee\",T:\"ol\",S:\"or\",B:\"ra\",C:\"lateg\",D:\"ights\",R:\"in\",Q:\"turquois\",E:\"hi\",P:\"ro\",O:\"al\",N:\"le\",M:\"de\",L:\"yello\",F:\"en\",K:\"ch\",G:\"arks\",H:\"ea\",I:\"ightg\",J:\"wh\"},Nt={OiceXe:\"f0f8ff\",antiquewEte:\"faebd7\",aqua:\"ffff\",aquamarRe:\"7fffd4\",azuY:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"0\",blanKedOmond:\"ffebcd\",Xe:\"ff\",XeviTet:\"8a2be2\",bPwn:\"a52a2a\",burlywood:\"deb887\",caMtXe:\"5f9ea0\",KartYuse:\"7fff00\",KocTate:\"d2691e\",cSO:\"ff7f50\",cSnflowerXe:\"6495ed\",cSnsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"ffff\",xXe:\"8b\",xcyan:\"8b8b\",xgTMnPd:\"b8860b\",xWay:\"a9a9a9\",xgYF:\"6400\",xgYy:\"a9a9a9\",xkhaki:\"bdb76b\",xmagFta:\"8b008b\",xTivegYF:\"556b2f\",xSange:\"ff8c00\",xScEd:\"9932cc\",xYd:\"8b0000\",xsOmon:\"e9967a\",xsHgYF:\"8fbc8f\",xUXe:\"483d8b\",xUWay:\"2f4f4f\",xUgYy:\"2f4f4f\",xQe:\"ced1\",xviTet:\"9400d3\",dAppRk:\"ff1493\",dApskyXe:\"bfff\",dimWay:\"696969\",dimgYy:\"696969\",dodgerXe:\"1e90ff\",fiYbrick:\"b22222\",flSOwEte:\"fffaf0\",foYstWAn:\"228b22\",fuKsia:\"ff00ff\",gaRsbSo:\"dcdcdc\",ghostwEte:\"f8f8ff\",gTd:\"ffd700\",gTMnPd:\"daa520\",Way:\"808080\",gYF:\"8000\",gYFLw:\"adff2f\",gYy:\"808080\",honeyMw:\"f0fff0\",hotpRk:\"ff69b4\",RdianYd:\"cd5c5c\",Rdigo:\"4b0082\",ivSy:\"fffff0\",khaki:\"f0e68c\",lavFMr:\"e6e6fa\",lavFMrXsh:\"fff0f5\",lawngYF:\"7cfc00\",NmoncEffon:\"fffacd\",ZXe:\"add8e6\",ZcSO:\"f08080\",Zcyan:\"e0ffff\",ZgTMnPdLw:\"fafad2\",ZWay:\"d3d3d3\",ZgYF:\"90ee90\",ZgYy:\"d3d3d3\",ZpRk:\"ffb6c1\",ZsOmon:\"ffa07a\",ZsHgYF:\"20b2aa\",ZskyXe:\"87cefa\",ZUWay:\"778899\",ZUgYy:\"778899\",ZstAlXe:\"b0c4de\",ZLw:\"ffffe0\",lime:\"ff00\",limegYF:\"32cd32\",lRF:\"faf0e6\",magFta:\"ff00ff\",maPon:\"800000\",VaquamarRe:\"66cdaa\",VXe:\"cd\",VScEd:\"ba55d3\",VpurpN:\"9370db\",VsHgYF:\"3cb371\",VUXe:\"7b68ee\",VsprRggYF:\"fa9a\",VQe:\"48d1cc\",VviTetYd:\"c71585\",midnightXe:\"191970\",mRtcYam:\"f5fffa\",mistyPse:\"ffe4e1\",moccasR:\"ffe4b5\",navajowEte:\"ffdead\",navy:\"80\",Tdlace:\"fdf5e6\",Tive:\"808000\",TivedBb:\"6b8e23\",Sange:\"ffa500\",SangeYd:\"ff4500\",ScEd:\"da70d6\",pOegTMnPd:\"eee8aa\",pOegYF:\"98fb98\",pOeQe:\"afeeee\",pOeviTetYd:\"db7093\",papayawEp:\"ffefd5\",pHKpuff:\"ffdab9\",peru:\"cd853f\",pRk:\"ffc0cb\",plum:\"dda0dd\",powMrXe:\"b0e0e6\",purpN:\"800080\",YbeccapurpN:\"663399\",Yd:\"ff0000\",Psybrown:\"bc8f8f\",PyOXe:\"4169e1\",saddNbPwn:\"8b4513\",sOmon:\"fa8072\",sandybPwn:\"f4a460\",sHgYF:\"2e8b57\",sHshell:\"fff5ee\",siFna:\"a0522d\",silver:\"c0c0c0\",skyXe:\"87ceeb\",UXe:\"6a5acd\",UWay:\"708090\",UgYy:\"708090\",snow:\"fffafa\",sprRggYF:\"ff7f\",stAlXe:\"4682b4\",tan:\"d2b48c\",teO:\"8080\",tEstN:\"d8bfd8\",tomato:\"ff6347\",Qe:\"40e0d0\",viTet:\"ee82ee\",JHt:\"f5deb3\",wEte:\"ffffff\",wEtesmoke:\"f5f5f5\",Lw:\"ffff00\",LwgYF:\"9acd32\"};let Ht;function jt(t){Ht||(Ht=function(){const t={},e=Object.keys(Nt),i=Object.keys(Wt);let s,n,o,a,r;for(s=0;s<e.length;s++){for(a=r=e[s],n=0;n<i.length;n++)o=i[n],r=r.replace(o,Wt[o]);o=parseInt(Nt[a],16),t[r]=[o>>16&255,o>>8&255,255&o]}return t}(),Ht.transparent=[0,0,0,0]);const e=Ht[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const $t=/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;const Yt=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ut=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function Xt(t,e,i){if(t){let s=It(t);s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),t.r=s[0],t.g=s[1],t.b=s[2]}}function qt(t,e){return t?Object.assign(e||{},t):t}function Kt(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(e.a),e}function Gt(t){return\"r\"===t.charAt(0)?function(t){const e=$t.exec(t);let i,s,n,o=255;if(e){if(e[7]!==i){const t=+e[7];o=e[8]?vt(t):yt(255*t,0,255)}return i=+e[1],s=+e[3],n=+e[5],i=255&(e[2]?vt(i):yt(i,0,255)),s=255&(e[4]?vt(s):yt(s,0,255)),n=255&(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}}(t):Bt(t)}class Zt{constructor(t){if(t instanceof Zt)return t;const e=typeof t;let i;var s,n,o;\"object\"===e?i=Kt(t):\"string\"===e&&(o=(s=t).length,\"#\"===s[0]&&(4===o||5===o?n={r:255&17*St[s[1]],g:255&17*St[s[2]],b:255&17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!==o&&9!==o||(n={r:St[s[1]]<<4|St[s[2]],g:St[s[3]]<<4|St[s[4]],b:St[s[5]]<<4|St[s[6]],a:9===o?St[s[7]]<<4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=qt(this._rgb);return t&&(t.a=wt(t.a)),t}set rgb(t){this._rgb=Kt(t)}rgbString(){return this._valid?(t=this._rgb)&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;var t}hexString(){return this._valid?At(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=It(t),i=e[0],s=kt(e[1]),n=kt(e[2]);return t.a<255?`hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,s=t.rgb;let n;const o=e===n?.5:e,a=2*o-1,r=i.a-s.a,l=((a*r==-1?a:(a+r)/(1+a*r))+1)/2;n=1-l,i.r=255&l*i.r+n*s.r+.5,i.g=255&l*i.g+n*s.g+.5,i.b=255&l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,i){const s=Ut(wt(t.r)),n=Ut(wt(t.g)),o=Ut(wt(t.b));return{r:Mt(Yt(s+i*(Ut(wt(e.r))-s))),g:Mt(Yt(n+i*(Ut(wt(e.g))-n))),b:Mt(Yt(o+i*(Ut(wt(e.b))-o))),a:t.a+i*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new Zt(this.rgb)}alpha(t){return this._rgb.a=Mt(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=_t(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Xt(this._rgb,2,t),this}darken(t){return Xt(this._rgb,2,-t),this}saturate(t){return Xt(this._rgb,1,t),this}desaturate(t){return Xt(this._rgb,1,-t),this}rotate(t){return function(t,e){var i=It(t);i[0]=Vt(i[0]+e),i=Ft(i),t.r=i[0],t.g=i[1],t.b=i[2]}(this._rgb,t),this}}function Jt(t){if(t&&\"object\"==typeof t){const e=t.toString();return\"[object CanvasPattern]\"===e||\"[object CanvasGradient]\"===e}return!1}function Qt(t){return Jt(t)?t:new Zt(t)}function te(t){return Jt(t)?t:new Zt(t).saturate(.5).darken(.1).hexString()}const ee=[\"x\",\"y\",\"borderWidth\",\"radius\",\"tension\"],ie=[\"color\",\"borderColor\",\"backgroundColor\"];const se=new Map;function ne(t,e,i){return function(t,e){e=e||{};const i=t+JSON.stringify(e);let s=se.get(i);return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}(e,i).format(t)}const oe={values:t=>n(t)?t:\"\"+t,numeric(t,e,i){if(0===t)return\"0\";const s=this.chart.options.locale;let n,o=t;if(i.length>1){const e=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(e<1e-4||e>1e15)&&(n=\"scientific\"),o=function(t,e){let i=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(i)>=1&&t!==Math.floor(t)&&(i=t-Math.floor(t));return i}(t,i)}const a=z(Math.abs(o)),r=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};return Object.assign(l,this.options.ticks.format),ne(t,s,l)},logarithmic(t,e,i){if(0===t)return\"0\";const s=i[e].significand||t/Math.pow(10,Math.floor(z(t)));return[1,2,3,5,10,15].includes(s)||e>.8*i.length?oe.numeric.call(this,t,e,i):\"\"}};var ae={formatters:oe};const re=Object.create(null),le=Object.create(null);function he(t,e){if(!e)return t;const i=e.split(\".\");for(let e=0,s=i.length;e<s;++e){const s=i[e];t=t[s]||(t[s]=Object.create(null))}return t}function ce(t,e,i){return\"string\"==typeof e?x(he(t,e),i):x(he(t,\"\"),e)}class de{constructor(t,e){this.animation=void 0,this.backgroundColor=\"rgba(0,0,0,0.1)\",this.borderColor=\"rgba(0,0,0,0.1)\",this.color=\"#666\",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=[\"mousemove\",\"mouseout\",\"click\",\"touchstart\",\"touchmove\"],this.font={family:\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",size:12,style:\"normal\",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>te(e.backgroundColor),this.hoverBorderColor=(t,e)=>te(e.borderColor),this.hoverColor=(t,e)=>te(e.color),this.indexAxis=\"x\",this.interaction={mode:\"nearest\",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return ce(this,t,e)}get(t){return he(this,t)}describe(t,e){return ce(le,t,e)}override(t,e){return ce(re,t,e)}route(t,e,i,s){const n=he(this,t),a=he(this,i),r=\"_\"+e;Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[r],e=a[s];return o(t)?Object.assign({},e,t):l(t,e)},set(t){this[r]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ue=new de({_scriptable:t=>!t.startsWith(\"on\"),_indexable:t=>\"events\"!==t,hover:{_fallback:\"interaction\"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set(\"animation\",{delay:void 0,duration:1e3,easing:\"easeOutQuart\",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe(\"animation\",{_fallback:!1,_indexable:!1,_scriptable:t=>\"onProgress\"!==t&&\"onComplete\"!==t&&\"fn\"!==t}),t.set(\"animations\",{colors:{type:\"color\",properties:ie},numbers:{type:\"number\",properties:ee}}),t.describe(\"animations\",{_fallback:\"animation\"}),t.set(\"transitions\",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:\"transparent\"},visible:{type:\"boolean\",duration:0}}},hide:{animations:{colors:{to:\"transparent\"},visible:{type:\"boolean\",easing:\"linear\",fn:t=>0|t}}}})},function(t){t.set(\"layout\",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set(\"scale\",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:\"ticks\",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:\"\",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:\"\",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ae.formatters.values,minor:{},major:{},align:\"center\",crossAlign:\"near\",showLabelBackdrop:!1,backdropColor:\"rgba(255, 255, 255, 0.75)\",backdropPadding:2}}),t.route(\"scale.ticks\",\"color\",\"\",\"color\"),t.route(\"scale.grid\",\"color\",\"\",\"borderColor\"),t.route(\"scale.border\",\"color\",\"\",\"borderColor\"),t.route(\"scale.title\",\"color\",\"\",\"color\"),t.describe(\"scale\",{_fallback:!1,_scriptable:t=>!t.startsWith(\"before\")&&!t.startsWith(\"after\")&&\"callback\"!==t&&\"parser\"!==t,_indexable:t=>\"borderDash\"!==t&&\"tickBorderDash\"!==t&&\"dash\"!==t}),t.describe(\"scales\",{_fallback:\"scale\"}),t.describe(\"scale.ticks\",{_scriptable:t=>\"backdropPadding\"!==t&&\"callback\"!==t,_indexable:t=>\"backdropPadding\"!==t})}]);function fe(){return\"undefined\"!=typeof window&&\"undefined\"!=typeof document}function ge(t){let e=t.parentNode;return e&&\"[object ShadowRoot]\"===e.toString()&&(e=e.host),e}function pe(t,e,i){let s;return\"string\"==typeof t?(s=parseInt(t,10),-1!==t.indexOf(\"%\")&&(s=s/100*e.parentNode[i])):s=t,s}const me=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);function xe(t,e){return me(t).getPropertyValue(e)}const be=[\"top\",\"right\",\"bottom\",\"left\"];function _e(t,e,i){const s={};i=i?\"-\"+i:\"\";for(let n=0;n<4;n++){const o=be[n];s[o]=parseFloat(t[e+\"-\"+o+i])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const ye=(t,e,i)=>(t>0||e>0)&&(!i||!i.shadowRoot);function ve(t,e){if(\"native\"in t)return t;const{canvas:i,currentDevicePixelRatio:s}=e,n=me(i),o=\"border-box\"===n.boxSizing,a=_e(n,\"padding\"),r=_e(n,\"border\",\"width\"),{x:l,y:h,box:c}=function(t,e){const i=t.touches,s=i&&i.length?i[0]:t,{offsetX:n,offsetY:o}=s;let a,r,l=!1;if(ye(n,o,t.target))a=n,r=o;else{const t=e.getBoundingClientRect();a=s.clientX-t.left,r=s.clientY-t.top,l=!0}return{x:a,y:r,box:l}}(t,i),d=a.left+(c&&r.left),u=a.top+(c&&r.top);let{width:f,height:g}=e;return o&&(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}const Me=t=>Math.round(10*t)/10;function we(t,e,i,s){const n=me(t),o=_e(n,\"margin\"),a=pe(n.maxWidth,t,\"clientWidth\")||T,r=pe(n.maxHeight,t,\"clientHeight\")||T,l=function(t,e,i){let s,n;if(void 0===e||void 0===i){const o=t&&ge(t);if(o){const t=o.getBoundingClientRect(),a=me(o),r=_e(a,\"border\",\"width\"),l=_e(a,\"padding\");e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=pe(a.maxWidth,o,\"clientWidth\"),n=pe(a.maxHeight,o,\"clientHeight\")}else e=t.clientWidth,i=t.clientHeight}return{width:e,height:i,maxWidth:s||T,maxHeight:n||T}}(t,e,i);let{width:h,height:c}=l;if(\"content-box\"===n.boxSizing){const t=_e(n,\"border\",\"width\"),e=_e(n,\"padding\");h-=e.width+t.width,c-=e.height+t.height}h=Math.max(0,h-o.width),c=Math.max(0,s?h/s:c-o.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&&!c&&(c=Me(h/2));return(void 0!==e||void 0!==i)&&s&&l.height&&c>l.height&&(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}function ke(t,e,i){const s=e||1,n=Math.floor(t.height*s),o=Math.floor(t.width*s);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const a=t.canvas;return a.style&&(i||!a.style.height&&!a.style.width)&&(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&&(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}const Se=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};fe()&&(window.addEventListener(\"test\",null,e),window.removeEventListener(\"test\",null,e))}catch(t){}return t}();function Pe(t,e){const i=xe(t,e),s=i&&i.match(/^(\\d+)(\\.\\d+)?px$/);return s?+s[1]:void 0}function De(t){return!t||s(t.size)||s(t.family)?null:(t.style?t.style+\" \":\"\")+(t.weight?t.weight+\" \":\"\")+t.size+\"px \"+t.family}function Ce(t,e,i,s,n){let o=e[n];return o||(o=e[n]=t.measureText(n).width,i.push(n)),o>s&&(s=o),s}function Oe(t,e,i,s){let o=(s=s||{}).data=s.data||{},a=s.garbageCollect=s.garbageCollect||[];s.font!==e&&(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;let r=0;const l=i.length;let h,c,d,u,f;for(h=0;h<l;h++)if(u=i[h],null==u||n(u)){if(n(u))for(c=0,d=u.length;c<d;c++)f=u[c],null==f||n(f)||(r=Ce(t,o,a,r,f))}else r=Ce(t,o,a,r,u);t.restore();const g=a.length/2;if(g>i.length){for(h=0;h<g;h++)delete o[a[h]];a.splice(0,g)}return r}function Ae(t,e,i){const s=t.currentDevicePixelRatio,n=0!==i?Math.max(i/2,.5):0;return Math.round((e-n)*s)/s+n}function Te(t,e){(e||t)&&((e=e||t.getContext(\"2d\")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}function Le(t,e,i,s){Ee(t,e,i,s,null)}function Ee(t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=e.pointStyle,g=e.rotation,p=e.radius;let m=(g||0)*L;if(f&&\"object\"==typeof f&&(o=f.toString(),\"[object HTMLImageElement]\"===o||\"[object HTMLCanvasElement]\"===o))return t.save(),t.translate(i,s),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();if(!(isNaN(p)||p<=0)){switch(t.beginPath(),f){default:n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();break;case\"triangle\":c=n?n/2:p,t.moveTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();break;case\"rectRounded\":h=.516*p,l=p-h,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(i-d,s-r,h,m-C,m-E),t.arc(i+u,s-a,h,m-E,m),t.arc(i+d,s+r,h,m,m+E),t.arc(i-u,s+a,h,m+E,m+C),t.closePath();break;case\"rect\":if(!g){l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);break}m+=R;case\"rectRot\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+u,s-a),t.lineTo(i+d,s+r),t.lineTo(i-u,s+a),t.closePath();break;case\"crossRot\":m+=R;case\"cross\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"star\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"line\":a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);break;case\"dash\":t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function Re(t,e,i){return i=i||.5,!e||t&&t.x>e.left-i&&t.x<e.right+i&&t.y>e.top-i&&t.y<e.bottom+i}function Ie(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function ze(t){t.restore()}function Fe(t,e,i,s,n){if(!e)return t.lineTo(i.x,i.y);if(\"middle\"===n){const s=(e.x+i.x)/2;t.lineTo(s,e.y),t.lineTo(s,i.y)}else\"after\"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}function Ve(t,e,i,s){if(!e)return t.lineTo(i.x,i.y);t.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}function Be(t,e,i,s,n){if(n.strikethrough||n.underline){const o=t.measureText(s),a=e-o.actualBoundingBoxLeft,r=e+o.actualBoundingBoxRight,l=i-o.actualBoundingBoxAscent,h=i+o.actualBoundingBoxDescent,c=n.strikethrough?(l+h)/2:h;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}}function We(t,e){const i=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}function Ne(t,e,i,o,a,r={}){const l=n(e)?e:[e],h=r.strokeWidth>0&&\"\"!==r.strokeColor;let c,d;for(t.save(),t.font=a.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,r),c=0;c<l.length;++c)d=l[c],r.backdrop&&We(t,r.backdrop),h&&(r.strokeColor&&(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);t.restore()}function He(t,e){const{x:i,y:s,w:n,h:o,radius:a}=e;t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,1.5*C,C,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,E,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-E,!0),t.lineTo(i+a.topLeft,s)}function je(t,e=[\"\"],i,s,n=(()=>t[0])){const o=i||t;void 0===s&&(s=ti(\"_fallback\",t));const a={[Symbol.toStringTag]:\"Object\",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:i=>je([i,...t],e,o,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete e._keys,delete t[0][i],!0),get:(i,s)=>qe(i,s,(()=>function(t,e,i,s){let n;for(const o of e)if(n=ti(Ue(o,t),i),void 0!==n)return Xe(t,n)?Je(i,s,t,n):n}(s,e,t,i))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>ei(t).includes(e),ownKeys:t=>ei(t),set(t,e,i){const s=t._storage||(t._storage=n());return t[e]=s[e]=i,delete t._keys,!0}})}function $e(t,e,i,s){const a={_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:e=>$e(t,e,i,s),override:n=>$e(t.override(n),e,i,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete t[i],!0),get:(t,e,i)=>qe(t,e,(()=>function(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=t;let h=s[e];S(h)&&l.isScriptable(e)&&(h=function(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=i;if(r.has(t))throw new Error(\"Recursion detected: \"+Array.from(r).join(\"->\")+\"->\"+t);r.add(t);let l=e(o,a||s);r.delete(t),Xe(t,l)&&(l=Je(n._scopes,n,t,l));return l}(e,h,t,i));n(h)&&h.length&&(h=function(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=i;if(void 0!==a.index&&s(t))return e[a.index%e.length];if(o(e[0])){const i=e,s=n._scopes.filter((t=>t!==i));e=[];for(const o of i){const i=Je(s,n,t,o);e.push($e(i,a,r&&r[t],l))}}return e}(e,h,t,l.isIndexable));Xe(e,h)&&(h=$e(h,a,r&&r[e],l));return h}(t,e,i))),getOwnPropertyDescriptor:(e,i)=>e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,i)=>Reflect.has(t,i),ownKeys:()=>Reflect.ownKeys(t),set:(e,i,s)=>(t[i]=s,delete e[i],!0)})}function Ye(t,e={scriptable:!0,indexable:!0}){const{_scriptable:i=e.scriptable,_indexable:s=e.indexable,_allKeys:n=e.allKeys}=t;return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:()=>i,isIndexable:S(s)?s:()=>s}}const Ue=(t,e)=>t?t+w(e):e,Xe=(t,e)=>o(e)&&\"adapters\"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function qe(t,e,i){if(Object.prototype.hasOwnProperty.call(t,e)||\"constructor\"===e)return t[e];const s=i();return t[e]=s,s}function Ke(t,e,i){return S(t)?t(e,i):t}const Ge=(t,e)=>!0===t?e:\"string\"==typeof t?M(e,t):void 0;function Ze(t,e,i,s,n){for(const o of e){const e=Ge(i,o);if(e){t.add(e);const o=Ke(e._fallback,i,n);if(void 0!==o&&o!==i&&o!==s)return o}else if(!1===e&&void 0!==s&&i!==s)return null}return!1}function Je(t,e,i,s){const a=e._rootScopes,r=Ke(e._fallback,i,s),l=[...t,...a],h=new Set;h.add(s);let c=Qe(h,l,i,r||i,s);return null!==c&&((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&&je(Array.from(h),[\"\"],a,r,(()=>function(t,e,i){const s=t._getTarget();e in s||(s[e]={});const a=s[e];if(n(a)&&o(i))return i;return a||{}}(e,i,s))))}function Qe(t,e,i,s,n){for(;i;)i=Ze(t,e,i,s,n);return i}function ti(t,e){for(const i of e){if(!i)continue;const e=i[t];if(void 0!==e)return e}}function ei(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const i of t)for(const t of Object.keys(i).filter((t=>!t.startsWith(\"_\"))))e.add(t);return Array.from(e)}(t._scopes)),e}function ii(t,e,i,s){const{iScale:n}=t,{key:o=\"r\"}=this._parsing,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};return a}const si=Number.EPSILON||1e-14,ni=(t,e)=>e<t.length&&!t[e].skip&&t[e],oi=t=>\"x\"===t?\"y\":\"x\";function ai(t,e,i,s){const n=t.skip?e:t,o=e,a=i.skip?e:i,r=q(o,n),l=q(a,o);let h=r/(r+l),c=l/(r+l);h=isNaN(h)?0:h,c=isNaN(c)?0:c;const d=s*h,u=s*c;return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}function ri(t,e=\"x\"){const i=oi(e),s=t.length,n=Array(s).fill(0),o=Array(s);let a,r,l,h=ni(t,0);for(a=0;a<s;++a)if(r=l,l=h,h=ni(t,a+1),l){if(h){const t=h[e]-l[e];n[a]=0!==t?(h[i]-l[i])/t:0}o[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}!function(t,e,i){const s=t.length;let n,o,a,r,l,h=ni(t,0);for(let c=0;c<s-1;++c)l=h,h=ni(t,c+1),l&&h&&(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r<=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}(t,n,o),function(t,e,i=\"x\"){const s=oi(i),n=t.length;let o,a,r,l=ni(t,0);for(let h=0;h<n;++h){if(a=r,r=l,l=ni(t,h+1),!r)continue;const n=r[i],c=r[s];a&&(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&&(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}}(t,o,e)}function li(t,e,i){return Math.max(Math.min(t,i),e)}function hi(t,e,i,s,n){let o,a,r,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),\"monotone\"===e.cubicInterpolationMode)ri(t,n);else{let i=s?t[t.length-1]:t[0];for(o=0,a=t.length;o<a;++o)r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}e.capBezierPoints&&function(t,e){let i,s,n,o,a,r=Re(t[0],e);for(i=0,s=t.length;i<s;++i)a=o,o=r,r=i<s-1&&Re(t[i+1],e),o&&(n=t[i],a&&(n.cp1x=li(n.cp1x,e.left,e.right),n.cp1y=li(n.cp1y,e.top,e.bottom)),r&&(n.cp2x=li(n.cp2x,e.left,e.right),n.cp2y=li(n.cp2y,e.top,e.bottom)))}(t,i)}const ci=t=>0===t||1===t,di=(t,e,i)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),ui=(t,e,i)=>Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,fi={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*E),easeOutSine:t=>Math.sin(t*E),easeInOutSine:t=>-.5*(Math.cos(C*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>ci(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>ci(t)?t:di(t,.075,.3),easeOutElastic:t=>ci(t)?t:ui(t,.075,.3),easeInOutElastic(t){const e=.1125;return ci(t)?t:t<.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-fi.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},easeInOutBounce:t=>t<.5?.5*fi.easeInBounce(2*t):.5*fi.easeOutBounce(2*t-1)+.5};function gi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}function pi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:\"middle\"===s?i<.5?t.y:e.y:\"after\"===s?i<1?t.y:e.y:i>0?e.y:t.y}}function mi(t,e,i,s){const n={x:t.cp2x,y:t.cp2y},o={x:e.cp1x,y:e.cp1y},a=gi(t,n,i),r=gi(n,o,i),l=gi(o,e,i),h=gi(a,r,i),c=gi(r,l,i);return gi(h,c,i)}const xi=/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,bi=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function _i(t,e){const i=(\"\"+t).match(xi);if(!i||\"normal\"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case\"px\":return t;case\"%\":t/=100}return e*t}const yi=t=>+t||0;function vi(t,e){const i={},s=o(e),n=s?Object.keys(e):e,a=o(t)?s?i=>l(t[i],t[e[i]]):e=>t[e]:()=>t;for(const t of n)i[t]=yi(a(t));return i}function Mi(t){return vi(t,{top:\"y\",right:\"x\",bottom:\"y\",left:\"x\"})}function wi(t){return vi(t,[\"topLeft\",\"topRight\",\"bottomLeft\",\"bottomRight\"])}function ki(t){const e=Mi(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Si(t,e){t=t||{},e=e||ue.font;let i=l(t.size,e.size);\"string\"==typeof i&&(i=parseInt(i,10));let s=l(t.style,e.style);s&&!(\"\"+s).match(bi)&&(console.warn('Invalid font style specified: \"'+s+'\"'),s=void 0);const n={family:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:\"\"};return n.string=De(n),n}function Pi(t,e,i,s){let o,a,r,l=!0;for(o=0,a=t.length;o<a;++o)if(r=t[o],void 0!==r&&(void 0!==e&&\"function\"==typeof r&&(r=r(e),l=!1),void 0!==i&&n(r)&&(r=r[i%r.length],l=!1),void 0!==r))return s&&!l&&(s.cacheable=!1),r}function Di(t,e,i){const{min:s,max:n}=t,o=c(e,(n-s)/2),a=(t,e)=>i&&0===t?0:t+e;return{min:a(s,-Math.abs(o)),max:a(n,o)}}function Ci(t,e){return Object.assign(Object.create(t),e)}function Oi(t,e,i){return t?function(t,e){return{x:i=>t+t+e-i,setWidth(t){e=t},textAlign:t=>\"center\"===t?t:\"right\"===t?\"left\":\"right\",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,i):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Ai(t,e){let i,s;\"ltr\"!==e&&\"rtl\"!==e||(i=t.canvas.style,s=[i.getPropertyValue(\"direction\"),i.getPropertyPriority(\"direction\")],i.setProperty(\"direction\",e,\"important\"),t.prevTextDirection=s)}function Ti(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty(\"direction\",e[0],e[1]))}function Li(t){return\"angle\"===t?{between:Z,compare:K,normalize:G}:{between:tt,compare:(t,e)=>t-e,normalize:t=>t}}function Ei({start:t,end:e,count:i,loop:s,style:n}){return{start:t%i,end:e%i,loop:s&&(e-t+1)%i==0,style:n}}function Ri(t,e,i){if(!i)return[t];const{property:s,start:n,end:o}=i,a=e.length,{compare:r,between:l,normalize:h}=Li(s),{start:c,end:d,loop:u,style:f}=function(t,e,i){const{property:s,start:n,end:o}=i,{between:a,normalize:r}=Li(s),l=e.length;let h,c,{start:d,end:u,loop:f}=t;if(f){for(d+=l,u+=l,h=0,c=l;h<c&&a(r(e[d%l][s]),n,o);++h)d--,u--;d%=l,u%=l}return u<d&&(u+=l),{start:d,end:u,loop:f,style:t.style}}(t,e,i),g=[];let p,m,x,b=!1,_=null;const y=()=>b||l(n,x,p)&&0!==r(n,x),v=()=>!b||0===r(o,p)||l(o,x,p);for(let t=c,i=c;t<=d;++t)m=e[t%a],m.skip||(p=h(m[s]),p!==x&&(b=l(p,n,o),null===_&&y()&&(_=0===r(p,n)?t:i),null!==_&&v()&&(g.push(Ei({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,x=p));return null!==_&&g.push(Ei({start:_,end:d,loop:u,count:a,style:f})),g}function Ii(t,e){const i=[],s=t.segments;for(let n=0;n<s.length;n++){const o=Ri(s[n],t.points,e);o.length&&i.push(...o)}return i}function zi(t,e){const i=t.points,s=t.options.spanGaps,n=i.length;if(!n)return[];const o=!!t._loop,{start:a,end:r}=function(t,e,i,s){let n=0,o=e-1;if(i&&!s)for(;n<e&&!t[n].skip;)n++;for(;n<e&&t[n].skip;)n++;for(n%=e,i&&(o+=n);o>n&&t[o%e].skip;)o--;return o%=e,{start:n,end:o}}(i,n,o,s);if(!0===s)return Fi(t,[{start:a,end:r,loop:o}],i,e);return Fi(t,function(t,e,i,s){const n=t.length,o=[];let a,r=e,l=t[e];for(a=e+1;a<=i;++a){const i=t[a%n];i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&&(e=a)),l=i}return null!==r&&o.push({start:e%n,end:r%n,loop:s}),o}(i,a,r<a?r+n:r,!!t._fullLoop&&0===a&&r===n-1),i,e)}function Fi(t,e,i,s){return s&&s.setContext&&i?function(t,e,i,s){const n=t._chart.getContext(),o=Vi(t.options),{_datasetIndex:a,options:{spanGaps:r}}=t,l=i.length,h=[];let c=o,d=e[0].start,u=d;function f(t,e,s,n){const o=r?-1:1;if(t!==e){for(t+=l;i[t%l].skip;)t-=o;for(;i[e%l].skip;)e+=o;t%l!=e%l&&(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}}for(const t of e){d=r?d:t.start;let e,o=i[d%l];for(u=d+1;u<=t.end;u++){const r=i[u%l];e=Vi(s.setContext(Ci(n,{type:\"segment\",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&&f(d,u-1,t.loop,c),o=r,c=e}d<u-1&&f(d,u-1,t.loop,c)}return h}(t,e,i,s):e}function Vi(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function Bi(t,e){if(!e)return!1;const i=[],s=function(t,e){return Jt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e};return JSON.stringify(t,s)!==JSON.stringify(e,s)}var Wi=Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:Z,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:function(t,e,i,s){void 0!==e&&console.warn(t+': \"'+i+'\" is deprecated. Please use \"'+s+'\" instead')},_descriptors:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:J,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation:pi,_steppedLineTo:Fe,_textX:gt,_toLeftRightCenter:ut,_updateBezierControlPoints:hi,addRoundedRectPath:He,almostEquals:V,almostWhole:H,callback:d,clearCanvas:Te,clipArea:Ie,clone:g,color:Qt,createContext:Ci,debounce:dt,defined:k,distanceBetweenPoints:q,drawPoint:Le,drawPointLegend:Ee,each:u,easingEffects:fi,finiteOrDefault:r,fontString:function(t,e,i){return e+\" \"+t+\"px \"+i},formatNumber:ne,getAngleFromPoint:X,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:xe,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Jt,listenArrayEvents:at,log10:z,merge:x,mergeIf:b,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve:Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});function Ni(t,e,i,n){const{controller:o,data:a,_sorted:r}=t,l=o._cachedMeta.iScale,h=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null;if(l&&e===l.axis&&\"r\"!==e&&r&&a.length){const r=l._reversePixels?st:it;if(!n){const n=r(a,e,i);if(h){const{vScale:e}=o._cachedMeta,{_parsed:i}=t,a=i.slice(0,n.lo+1).reverse().findIndex((t=>!s(t[e.axis])));n.lo-=Math.max(0,a);const r=i.slice(n.hi).findIndex((t=>!s(t[e.axis])));n.hi+=Math.max(0,r)}return n}if(o._sharedOptions){const t=a[0],s=\"function\"==typeof t.getRange&&t.getRange(e);if(s){const t=r(a,e,i-s),n=r(a,e,i+s);return{lo:t.lo,hi:n.hi}}}}return{lo:0,hi:a.length-1}}function Hi(t,e,i,s,n){const o=t.getSortedVisibleDatasetMetas(),a=i[e];for(let t=0,i=o.length;t<i;++t){const{index:i,data:r}=o[t],{lo:l,hi:h}=Ni(o[t],e,a,n);for(let t=l;t<=h;++t){const e=r[t];e.skip||s(e,i,t)}}}function ji(t,e,i,s,n){const o=[];if(!n&&!t.isPointInArea(e))return o;return Hi(t,i,e,(function(i,a,r){(n||Re(i,t.chartArea,0))&&i.inRange(e.x,e.y,s)&&o.push({element:i,datasetIndex:a,index:r})}),!0),o}function $i(t,e,i,s,n,o){let a=[];const r=function(t){const e=-1!==t.indexOf(\"x\"),i=-1!==t.indexOf(\"y\");return function(t,s){const n=e?Math.abs(t.x-s.x):0,o=i?Math.abs(t.y-s.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}(i);let l=Number.POSITIVE_INFINITY;return Hi(t,i,e,(function(i,h,c){const d=i.inRange(e.x,e.y,n);if(s&&!d)return;const u=i.getCenterPoint(n);if(!(!!o||t.isPointInArea(u))&&!d)return;const f=r(e,u);f<l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&&a.push({element:i,datasetIndex:h,index:c})})),a}function Yi(t,e,i,s,n,o){return o||t.isPointInArea(e)?\"r\"!==i||s?$i(t,e,i,s,n,o):function(t,e,i,s){let n=[];return Hi(t,i,e,(function(t,i,o){const{startAngle:a,endAngle:r}=t.getProps([\"startAngle\",\"endAngle\"],s),{angle:l}=X(t,{x:e.x,y:e.y});Z(l,a,r)&&n.push({element:t,datasetIndex:i,index:o})})),n}(t,e,i,n):[]}function Ui(t,e,i,s,n){const o=[],a=\"x\"===i?\"inXRange\":\"inYRange\";let r=!1;return Hi(t,i,e,((t,s,l)=>{t[a]&&t[a](e[i],n)&&(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))})),s&&!r?[]:o}var Xi={evaluateInteractionItems:Hi,modes:{index(t,e,i,s){const n=ve(e,t),o=i.axis||\"x\",a=i.includeInvisible||!1,r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a),l=[];return r.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index,i=t.data[e];i&&!i.skip&&l.push({element:i,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;let r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a);if(r.length>0){const e=r[0].datasetIndex,i=t.getDatasetMeta(e).data;r=[];for(let t=0;t<i.length;++t)r.push({element:i[t],datasetIndex:e,index:t})}return r},point:(t,e,i,s)=>ji(t,ve(e,t),i.axis||\"xy\",s,i.includeInvisible||!1),nearest(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;return Yi(t,n,o,i.intersect,s,a)},x:(t,e,i,s)=>Ui(t,ve(e,t),\"x\",i.intersect,s),y:(t,e,i,s)=>Ui(t,ve(e,t),\"y\",i.intersect,s)}};const qi=[\"left\",\"top\",\"right\",\"bottom\"];function Ki(t,e){return t.filter((t=>t.pos===e))}function Gi(t,e){return t.filter((t=>-1===qi.indexOf(t.pos)&&t.box.axis===e))}function Zi(t,e){return t.sort(((t,i)=>{const s=e?i:t,n=e?t:i;return s.weight===n.weight?s.index-n.index:s.weight-n.weight}))}function Ji(t,e){const i=function(t){const e={};for(const i of t){const{stack:t,pos:s,stackWeight:n}=i;if(!t||!qi.includes(s))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=n}return e}(t),{vBoxMaxWidth:s,hBoxMaxHeight:n}=e;let o,a,r;for(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box,l=i[r.stack],h=l&&r.stackWeight/l.weight;r.horizontal?(r.width=h?h*s:a&&e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&&e.availableHeight)}return i}function Qi(t,e,i,s){return Math.max(t[i],e[i])+Math.max(t[s],e[s])}function ts(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function es(t,e,i,s){const{pos:n,box:a}=i,r=t.maxPadding;if(!o(n)){i.size&&(t[n]-=i.size);const e=s[i.stack]||{size:0,count:1};e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}a.getPadding&&ts(r,a.getPadding());const l=Math.max(0,e.outerWidth-Qi(r,t,\"left\",\"right\")),h=Math.max(0,e.outerHeight-Qi(r,t,\"top\",\"bottom\")),c=l!==t.w,d=h!==t.h;return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}function is(t,e){const i=e.maxPadding;function s(t){const s={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{s[t]=Math.max(e[t],i[t])})),s}return s(t?[\"left\",\"right\"]:[\"top\",\"bottom\"])}function ss(t,e,i,s){const n=[];let o,a,r,l,h,c;for(o=0,a=t.length,h=0;o<a;++o){r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,is(r.horizontal,e));const{same:a,other:d}=es(e,i,r,s);h|=a&&n.length,c=c||d,l.fullSize||n.push(r)}return h&&ss(n,e,i,s)||c}function ns(t,e,i,s,n){t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}function os(t,e,i,s){const n=i.padding;let{x:o,y:a}=e;for(const r of t){const t=r.box,l=s[r.stack]||{count:1,placed:0,weight:1},h=r.stackWeight/l.weight||1;if(r.horizontal){const s=e.w*h,o=l.size||t.height;k(l.start)&&(a=l.start),t.fullSize?ns(t,n.left,a,i.outerWidth-n.right-n.left,o):ns(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}else{const s=e.h*h,a=l.size||t.width;k(l.start)&&(o=l.start),t.fullSize?ns(t,o,n.top,a,i.outerHeight-n.bottom-n.top):ns(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}}e.x=o,e.y=a}var as={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||\"top\",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure(t,e,i){e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight},update(t,e,i,s){if(!t)return;const n=ki(t.options.layout.padding),o=Math.max(e-n.width,0),a=Math.max(i-n.height,0),r=function(t){const e=function(t){const e=[];let i,s,n,o,a,r;for(i=0,s=(t||[]).length;i<s;++i)n=t[i],({position:o,options:{stack:a,stackWeight:r=1}}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r});return e}(t),i=Zi(e.filter((t=>t.box.fullSize)),!0),s=Zi(Ki(e,\"left\"),!0),n=Zi(Ki(e,\"right\")),o=Zi(Ki(e,\"top\"),!0),a=Zi(Ki(e,\"bottom\")),r=Gi(e,\"x\"),l=Gi(e,\"y\");return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ki(e,\"chartArea\"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}(t.boxes),l=r.vertical,h=r.horizontal;u(t.boxes,(t=>{\"function\"==typeof t.beforeLayout&&t.beforeLayout()}));const c=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),f=Object.assign({},n);ts(f,ki(s));const g=Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),p=Ji(l.concat(h),d);ss(r.fullSize,g,d,p),ss(l,g,d,p),ss(h,g,d,p)&&ss(l,g,d,p),function(t){const e=t.maxPadding;function i(i){const s=Math.max(e[i]-t[i],0);return t[i]+=s,s}t.y+=i(\"top\"),t.x+=i(\"left\"),i(\"right\"),i(\"bottom\")}(g),os(r.leftAndTop,g,d,p),g.x+=g.w,g.y+=g.h,os(r.rightAndBottom,g,d,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},u(r.chartArea,(e=>{const i=e.box;Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}))}};class rs{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,s){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){return!0}updateConfig(t){}}class ls extends rs{acquireContext(t){return t&&t.getContext&&t.getContext(\"2d\")||null}updateConfig(t){t.options.animation=!1}}const hs=\"$chartjs\",cs={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\",pointerenter:\"mouseenter\",pointerdown:\"mousedown\",pointermove:\"mousemove\",pointerup:\"mouseup\",pointerleave:\"mouseout\",pointerout:\"mouseout\"},ds=t=>null===t||\"\"===t;const us=!!Se&&{passive:!0};function fs(t,e,i){t&&t.canvas&&t.canvas.removeEventListener(e,i,us)}function gs(t,e){for(const i of t)if(i===e||i.contains(e))return!0}function ps(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.addedNodes,s),e=e&&!gs(i.removedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}function ms(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.removedNodes,s),e=e&&!gs(i.addedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}const xs=new Map;let bs=0;function _s(){const t=window.devicePixelRatio;t!==bs&&(bs=t,xs.forEach(((e,i)=>{i.currentDevicePixelRatio!==t&&e()})))}function ys(t,e,i){const s=t.canvas,n=s&&ge(s);if(!n)return;const o=ct(((t,e)=>{const s=n.clientWidth;i(t,e),s<n.clientWidth&&i()}),window),a=new ResizeObserver((t=>{const e=t[0],i=e.contentRect.width,s=e.contentRect.height;0===i&&0===s||o(i,s)}));return a.observe(n),function(t,e){xs.size||window.addEventListener(\"resize\",_s),xs.set(t,e)}(t,o),a}function vs(t,e,i){i&&i.disconnect(),\"resize\"===e&&function(t){xs.delete(t),xs.size||window.removeEventListener(\"resize\",_s)}(t)}function Ms(t,e,i){const s=t.canvas,n=ct((e=>{null!==t.ctx&&i(function(t,e){const i=cs[t.type]||t.type,{x:s,y:n}=ve(t,e);return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}(e,t))}),t);return function(t,e,i){t&&t.addEventListener(e,i,us)}(s,e,n),n}class ws extends rs{acquireContext(t,e){const i=t&&t.getContext&&t.getContext(\"2d\");return i&&i.canvas===t?(function(t,e){const i=t.style,s=t.getAttribute(\"height\"),n=t.getAttribute(\"width\");if(t[hs]={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||\"block\",i.boxSizing=i.boxSizing||\"border-box\",ds(n)){const e=Pe(t,\"width\");void 0!==e&&(t.width=e)}if(ds(s))if(\"\"===t.style.height)t.height=t.width/(e||2);else{const e=Pe(t,\"height\");void 0!==e&&(t.height=e)}}(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[hs])return!1;const i=e[hs].initial;[\"height\",\"width\"].forEach((t=>{const n=i[t];s(n)?e.removeAttribute(t):e.setAttribute(t,n)}));const n=i.style||{};return Object.keys(n).forEach((t=>{e.style[t]=n[t]})),e.width=e.width,delete e[hs],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),n={attach:ps,detach:ms,resize:ys}[e]||Ms;s[e]=n(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:vs,detach:vs,resize:vs}[e]||fs)(t,e,s),i[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,s){return we(t,e,i,s)}isAttached(t){const e=t&&ge(t);return!(!e||!e.isConnected)}}function ks(t){return!fe()||\"undefined\"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?ls:ws}var Ss=Object.freeze({__proto__:null,BasePlatform:rs,BasicPlatform:ls,DomPlatform:ws,_detectPlatform:ks});const Ps=\"transparent\",Ds={boolean:(t,e,i)=>i>.5?e:t,color(t,e,i){const s=Qt(t||Ps),n=s.valid&&Qt(e||Ps);return n&&n.valid?n.mix(s,i).hexString():e},number:(t,e,i)=>t+(e-t)*i};class Cs{constructor(t,e,i,s){const n=e[i];s=Pi([t.to,s,n,t.from]);const o=Pi([t.from,n,s]);this._active=!0,this._fn=t.fn||Ds[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const s=this._target[this._prop],n=i-this._start,o=this._duration-n;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,n=this._from,o=this._loop,a=this._to;let r;if(this._active=n!==a&&(o||e<i),!this._active)return this._target[s]=a,void this._notify(!0);e<0?this._target[s]=n:(r=e/i%2,r=o&&r>1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,i)=>{t.push({res:e,rej:i})}))}_notify(t){const e=t?\"res\":\"rej\",i=this._promises||[];for(let t=0;t<i.length;t++)i[t][e]()}}class Os{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!o(t))return;const e=Object.keys(ue.animation),i=this._properties;Object.getOwnPropertyNames(t).forEach((s=>{const a=t[s];if(!o(a))return;const r={};for(const t of e)r[t]=a[t];(n(a.properties)&&a.properties||[s]).forEach((t=>{t!==s&&i.has(t)||i.set(t,r)}))}))}_animateOptions(t,e){const i=e.options,s=function(t,e){if(!e)return;let i=t.options;if(!i)return void(t.options=e);i.$shared&&(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));return i}(t,i);if(!s)return[];const n=this._createAnimations(s,i);return i.$shared&&function(t,e){const i=[],s=Object.keys(e);for(let e=0;e<s.length;e++){const n=t[s[e]];n&&n.active()&&i.push(n.wait())}return Promise.all(i)}(t.options.$animations,i).then((()=>{t.options=i}),(()=>{})),n}_createAnimations(t,e){const i=this._properties,s=[],n=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];if(\"$\"===l.charAt(0))continue;if(\"options\"===l){s.push(...this._animateOptions(t,e));continue}const h=e[l];let c=n[l];const d=i.get(l);if(c){if(d&&c.active()){c.update(d,h,a);continue}c.cancel()}d&&d.duration?(n[l]=c=new Cs(d,t,l,h),s.push(c)):t[l]=h}return s}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const i=this._createAnimations(t,e);return i.length?(bt.add(this._chart,i),!0):void 0}}function As(t,e){const i=t&&t.options||{},s=i.reverse,n=void 0===i.min?e:0,o=void 0===i.max?e:0;return{start:s?o:n,end:s?n:o}}function Ts(t,e){const i=[],s=t._getSortedDatasetMetas(e);let n,o;for(n=0,o=s.length;n<o;++n)i.push(s[n].index);return i}function Ls(t,e,i,s={}){const n=t.keys,o=\"single\"===s.mode;let r,l,h,c;if(null===e)return;let d=!1;for(r=0,l=n.length;r<l;++r){if(h=+n[r],h===i){if(d=!0,s.all)continue;break}c=t.values[h],a(c)&&(o||0===e||F(e)===F(c))&&(e+=c)}return d||s.all?e:0}function Es(t,e){const i=t&&t.options.stacked;return i||void 0===i&&void 0!==e.stack}function Rs(t,e,i){const s=t[e]||(t[e]={});return s[i]||(s[i]={})}function Is(t,e,i,s){for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=t[n.index];if(i&&e>0||!i&&e<0)return n.index}return null}function zs(t,e){const{chart:i,_cachedMeta:s}=t,n=i._stacks||(i._stacks={}),{iScale:o,vScale:a,index:r}=s,l=o.axis,h=a.axis,c=function(t,e,i){return`${t.id}.${e.id}.${i.stack||i.type}`}(o,a,s),d=e.length;let u;for(let t=0;t<d;++t){const i=e[t],{[l]:o,[h]:d}=i;u=(i._stacks||(i._stacks={}))[h]=Rs(n,c,o),u[r]=d,u._top=Is(u,a,!0,s.type),u._bottom=Is(u,a,!1,s.type);(u._visualValues||(u._visualValues={}))[r]=d}}function Fs(t,e){const i=t.scales;return Object.keys(i).filter((t=>i[t].axis===e)).shift()}function Vs(t,e){const i=t.controller.index,s=t.vScale&&t.vScale.axis;if(s){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[s]||void 0===e[s][i])return;delete e[s][i],void 0!==e[s]._visualValues&&void 0!==e[s]._visualValues[i]&&delete e[s]._visualValues[i]}}}const Bs=t=>\"reset\"===t||\"none\"===t,Ws=(t,e)=>e?t:Object.assign({},t);class Ns{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Es(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled(\"filler\")&&console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\")}updateIndex(t){this.index!==t&&Vs(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(t,e,i,s)=>\"x\"===t?e:\"r\"===t?s:i,n=e.xAxisID=l(i.xAxisID,Fs(t,\"x\")),o=e.yAxisID=l(i.yAxisID,Fs(t,\"y\")),a=e.rAxisID=l(i.rAxisID,Fs(t,\"r\")),r=e.indexAxis,h=e.iAxisID=s(r,n,o,a),c=e.vAxisID=s(r,o,n,a);e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update(\"reset\")}_destroy(){const t=this._cachedMeta;this._data&&rt(this._data,this),t._stacked&&Vs(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;if(o(e)){const t=this._cachedMeta;this._data=function(t,e){const{iScale:i,vScale:s}=e,n=\"x\"===i.axis?\"x\":\"y\",o=\"x\"===s.axis?\"x\":\"y\",a=Object.keys(t),r=new Array(a.length);let l,h,c;for(l=0,h=a.length;l<h;++l)c=a[l],r[l]={[n]:c,[o]:t[c]};return r}(e,t)}else if(i!==e){if(i){rt(i,this);const t=this._cachedMeta;Vs(t),t._parsed=[]}e&&Object.isExtensible(e)&&at(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const n=e._stacked;e._stacked=Es(e.vScale,e),e.stack!==i.stack&&(s=!0,Vs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&&(zs(this,e._parsed),e._stacked=Es(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:a,_stacked:r}=i,l=a.axis;let h,c,d,u=0===t&&e===s.length||i._sorted,f=t>0&&i._parsed[t-1];if(!1===this._parsing)i._parsed=s,i._sorted=!0,d=s;else{d=n(s[t])?this.parseArrayData(i,s,t,e):o(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);const a=()=>null===c[l]||f&&c[l]<f[l];for(h=0;h<e;++h)i._parsed[h+t]=c=d[h],u&&(a()&&(u=!1),f=c);i._sorted=u}r&&zs(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=t,a=n.axis,r=o.axis,l=n.getLabels(),h=n===o,c=new Array(s);let d,u,f;for(d=0,u=s;d<u;++d)f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};return c}parseArrayData(t,e,i,s){const{xScale:n,yScale:o}=t,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};return a}parseObjectData(t,e,i,s){const{xScale:n,yScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=new Array(s);let h,c,d,u;for(h=0,c=s;h<c;++h)d=h+i,u=e[d],l[h]={x:n.parse(M(u,a),d),y:o.parse(M(u,r),d)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,i){const s=this.chart,n=this._cachedMeta,o=e[t.axis];return Ls({keys:Ts(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}updateRangeFromParsed(t,e,i,s){const n=i[e.axis];let o=null===n?NaN:n;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=Ls(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,n=i._sorted&&t===i.iScale,o=s.length,r=this._getOtherScale(t),l=((t,e,i)=>t&&!e.hidden&&e._stacked&&{keys:Ts(i,!0),values:null})(e,i,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:d}=function(t){const{min:e,max:i,minDefined:s,maxDefined:n}=t.getUserBounds();return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}(r);let u,f;function g(){f=s[u];const e=f[r.axis];return!a(f[t.axis])||c>e||d<e}for(u=0;u<o&&(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);if(n)for(u=o-1;u>=0;--u)if(!g()){this.updateRangeFromParsed(h,t,f,l);break}return h}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s][t.axis],a(o)&&i.push(o);return i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,n=this.getParsed(t);return{label:i?\"\"+i.getLabelForValue(n[i.axis]):\"\",value:s?\"\"+s.getLabelForValue(n[s.axis]):\"\"}}_update(t){const e=this._cachedMeta;this.update(t||\"default\"),e._clip=function(t){let e,i,s,n;return o(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}(l(this.options.clip,function(t,e,i){if(!1===i)return!1;const s=As(t,i),n=As(e,i);return{top:n.end,right:s.end,bottom:n.start,left:s.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],n=e.chartArea,o=[],a=this._drawStart||0,r=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,n,a,r),h=a;h<a+r;++h){const e=s[h];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(h=0;h<o.length;++h)o[h].draw(t,n)}getStyle(t,e){const i=e?\"active\":\"default\";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let n;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){return Ci(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:\"default\",type:\"data\"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}else n=this.$context||(this.$context=function(t,e){return Ci(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:\"default\",type:\"dataset\"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;return n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e=\"default\",i){const s=\"active\"===e,n=this._cachedDataOpts,o=t+\"-\"+e,a=n[o],r=this.enableOptionSharing&&k(i);if(a)return Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,\"hover\",t,\"\"]:[t,\"\"],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getContext(i,s,e)),c);return f.$shared&&(f.$shared=r,n[o]=Object.freeze(Ws(f,r))),f}_resolveAnimations(t,e,i){const s=this.chart,n=this._cachedDataOpts,o=`animation-${e}`,a=n[o];if(a)return a;let r;if(!1!==s.options.animation){const s=this.chart.config,n=s.datasetAnimationScopeKeys(this._type,e),o=s.getOptionScopes(this.getDataset(),n);r=s.createResolver(o,this.getContext(t,i,e))}const l=new Os(s,r&&r.animations);return r&&r._cacheable&&(n[o]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||Bs(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const i=this.resolveDataElementOptions(t,e),s=this._sharedOptions,n=this.getSharedOptions(i),o=this.includeOptions(e,n)||n!==s;return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}updateElement(t,e,i,s){Bs(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!Bs(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const n=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[t,e,i]of this._syncList)this[t](e,i);this._syncList=[];const s=i.length,n=e.length,o=Math.min(n,s);o&&this.parse(0,o),n>s?this._insertElements(s,n-s,t):n<s&&this._removeElements(n,s-n)}_insertElements(t,e,i=!0){const s=this._cachedMeta,n=s.data,o=t+e;let a;const r=t=>{for(t.length+=e,a=t.length-1;a>=o;a--)t[a]=t[a-e]};for(r(n),a=t;a<o;++a)n[a]=new this.dataElementType;this._parsing&&r(s._parsed),this.parse(t,e),i&&this.updateElements(n,t,e,\"reset\")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;if(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&Vs(i,s)}i.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync([\"_insertElements\",this.getDataset().data.length-t,t])}_onDataPop(){this._sync([\"_removeElements\",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync([\"_removeElements\",0,1])}_onDataSplice(t,e){e&&this._sync([\"_removeElements\",t,e]);const i=arguments.length-2;i&&this._sync([\"_insertElements\",t,i])}_onDataUnshift(){this._sync([\"_insertElements\",0,arguments.length])}}class Hs{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}hasValue(){return N(this.x)&&N(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const s={};return t.forEach((t=>{s[t]=i[t]&&i[t].active()?i[t]._to:this[t]})),s}}function js(t,e){const i=t.options.ticks,n=function(t){const e=t.options.offset,i=t._tickSize(),s=t._length/i+(e?0:1),n=t._maxLength/i;return Math.floor(Math.min(s,n))}(t),o=Math.min(i.maxTicksLimit||n,n),a=i.major.enabled?function(t){const e=[];let i,s;for(i=0,s=t.length;i<s;i++)t[i].major&&e.push(i);return e}(e):[],r=a.length,l=a[0],h=a[r-1],c=[];if(r>o)return function(t,e,i,s){let n,o=0,a=i[0];for(s=Math.ceil(s),n=0;n<t.length;n++)n===a&&(e.push(t[n]),o++,a=i[o*s])}(e,c,a,r/o),c;const d=function(t,e,i){const s=function(t){const e=t.length;let i,s;if(e<2)return!1;for(s=t[0],i=1;i<e;++i)if(t[i]-t[i-1]!==s)return!1;return s}(t),n=e.length/i;if(!s)return Math.max(n,1);const o=W(s);for(let t=0,e=o.length-1;t<e;t++){const e=o[t];if(e>n)return e}return Math.max(n,1)}(a,e,o);if(r>0){let t,i;const n=r>1?Math.round((h-l)/(r-1)):null;for($s(e,c,d,s(n)?0:l-n,l),t=0,i=r-1;t<i;t++)$s(e,c,d,a[t],a[t+1]);return $s(e,c,d,h,s(n)?e.length:h+n),c}return $s(e,c,d),c}function $s(t,e,i,s,n){const o=l(s,0),a=Math.min(l(n,t.length),t.length);let r,h,c,d=0;for(i=Math.ceil(i),n&&(r=n-s,i=r/Math.floor(r/i)),c=o;c<0;)d++,c=Math.round(o+d*i);for(h=Math.max(o,0);h<a;h++)h===c&&(e.push(t[h]),d++,c=Math.round(o+d*i))}const Ys=(t,e,i)=>\"top\"===e||\"left\"===e?t[e]+i:t[e]-i,Us=(t,e)=>Math.min(e||t,t);function Xs(t,e){const i=[],s=t.length/e,n=t.length;let o=0;for(;o<n;o+=s)i.push(t[Math.floor(o)]);return i}function qs(t,e,i){const s=t.ticks.length,n=Math.min(e,s-1),o=t._startPixel,a=t._endPixel,r=1e-6;let l,h=t.getPixelForTick(n);if(!(i&&(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n<e?l:-l,h<o-r||h>a+r)))return h}function Ks(t){return t.drawTicks?t.tickLength:0}function Gs(t,e){if(!t.display)return 0;const i=Si(t.font,e),s=ki(t.padding);return(n(t.text)?t.text.length:1)*i.lineHeight+s.height}function Zs(t,e,i){let s=ut(t);return(i&&\"right\"!==e||!i&&\"right\"===e)&&(s=(t=>\"left\"===t?\"right\":\"right\"===t?\"left\":t)(s)),s}class Js extends Hs{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=r(t,Number.POSITIVE_INFINITY),e=r(e,Number.NEGATIVE_INFINITY),i=r(i,Number.POSITIVE_INFINITY),s=r(s,Number.NEGATIVE_INFINITY),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}getMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=this.getUserBounds();if(n&&o)return{min:i,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r)e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));return i=o&&i>s?s:i,s=n&&i>s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){d(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Di(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?Xs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||\"auto\"===o.source)&&(this.ticks=js(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,i=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){d(this.options.afterUpdate,[this])}beforeSetDimensions(){d(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){d(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}beforeDataLimits(){this._callHooks(\"beforeDataLimits\")}determineDataLimits(){}afterDataLimits(){this._callHooks(\"afterDataLimits\")}beforeBuildTicks(){this._callHooks(\"beforeBuildTicks\")}buildTicks(){return[]}afterBuildTicks(){this._callHooks(\"afterBuildTicks\")}beforeTickToLabelConversion(){d(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,s,n;for(i=0,s=t.length;i<s;i++)n=t[i],n.label=d(e.callback,[n.value,i,t],this)}afterTickToLabelConversion(){d(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){d(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=Us(this.ticks.length,t.ticks.maxTicksLimit),s=e.minRotation||0,n=e.maxRotation;let o,a,r,l=s;if(!this._isVisible()||!e.display||s>=n||i<=1||!this.isHorizontal())return void(this.labelRotation=s);const h=this._getLabelSizes(),c=h.widest.width,d=h.highest.height,u=J(this.chart.width-c,0,this.maxWidth);o=t.offset?this.maxWidth/i:u/(i-1),c+6>o&&(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ks(t.grid)-e.padding-Gs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin(J((h.highest.height+6)/o,-1,1)),Math.asin(J(a/r,-1,1))-Math.asin(J(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}afterCalculateLabelRotation(){d(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){d(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:n}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const o=Gs(s,e.options.font);if(a?(t.width=this.maxWidth,t.height=Ks(n)+o):(t.height=this.maxHeight,t.width=Ks(n)+o),i.display&&this.ticks.length){const{first:e,last:s,widest:n,highest:o}=this._getLabelSizes(),r=2*i.padding,l=$(this.labelRotation),h=Math.cos(l),c=Math.sin(l);if(a){const e=i.mirror?0:c*n.width+h*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=i.mirror?0:h*n.width+c*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,s,c,h)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=this.options,r=0!==this.labelRotation,l=\"top\"!==a&&\"x\"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let c=0,d=0;r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):\"start\"===n?d=e.width:\"end\"===n?c=t.width:\"inner\"!==n&&(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let i=e.height/2,s=t.height/2;\"start\"===n?(i=0,s=t.height):\"end\"===n&&(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){d(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return\"top\"===e||\"bottom\"===e||\"x\"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)s(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Xs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=this,r=[],l=[],h=Math.floor(e/Us(e,i));let c,d,f,g,p,m,x,b,_,y,v,M=0,w=0;for(c=0;c<e;c+=h){if(g=t[c].label,p=this._resolveTickFontOptions(c),o.font=m=p.string,x=a[m]=a[m]||{data:{},gc:[]},b=p.lineHeight,_=y=0,s(g)||n(g)){if(n(g))for(d=0,f=g.length;d<f;++d)v=g[d],s(v)||n(v)||(_=Ce(o,x.data,x.gc,_,v),y+=b)}else _=Ce(o,x.data,x.gc,_,g),y=b;r.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}!function(t,e){u(t,(t=>{const i=t.gc,s=i.length/2;let n;if(s>e){for(n=0;n<s;++n)delete t.data[i[n]];i.splice(0,s)}}))}(a,e);const k=r.indexOf(M),S=l.indexOf(w),P=t=>({width:r[t]||0,height:l[t]||0});return{first:P(0),last:P(e-1),widest:P(k),highest:P(S),widths:r,heights:l}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Q(this._alignToPixels?Ae(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=function(t,e,i){return Ci(t,{tick:i,index:e,type:\"tick\"})}(this.getContext(),t,i))}return this.$context||(this.$context=Ci(this.chart.getContext(),{scale:this,type:\"scale\"}))}_tickSize(){const t=this.options.ticks,e=$(this.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),n=this._getLabelSizes(),o=t.autoSkipPadding||0,a=n?n.widest.width+o:0,r=n?n.highest.height+o:0;return this.isHorizontal()?r*i>a*s?a/i:r/s:r*s<a*i?r/i:a/s}_isVisible(){const t=this.options.display;return\"auto\"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:n,position:a,border:r}=s,h=n.offset,c=this.isHorizontal(),d=this.ticks.length+(h?1:0),u=Ks(n),f=[],g=r.setContext(this.getContext()),p=g.display?g.width:0,m=p/2,x=function(t){return Ae(i,t,p)};let b,_,y,v,M,w,k,S,P,D,C,O;if(\"top\"===a)b=x(this.bottom),w=this.bottom-u,S=b-m,D=x(t.top)+m,O=t.bottom;else if(\"bottom\"===a)b=x(this.top),D=t.top,O=x(t.bottom)-m,w=b+m,S=this.top+u;else if(\"left\"===a)b=x(this.right),M=this.right-u,k=b-m,P=x(t.left)+m,C=t.right;else if(\"right\"===a)b=x(this.left),P=t.left,C=x(t.right)-m,M=b+m,k=this.left+u;else if(\"x\"===e){if(\"center\"===a)b=x((t.top+t.bottom)/2+.5);else if(o(a)){const t=Object.keys(a)[0],e=a[t];b=x(this.chart.scales[t].getPixelForValue(e))}D=t.top,O=t.bottom,w=b+m,S=w+u}else if(\"y\"===e){if(\"center\"===a)b=x((t.left+t.right)/2);else if(o(a)){const t=Object.keys(a)[0],e=a[t];b=x(this.chart.scales[t].getPixelForValue(e))}M=b-m,k=M-u,P=t.left,C=t.right}const A=l(s.ticks.maxTicksLimit,d),T=Math.max(1,Math.ceil(d/A));for(_=0;_<d;_+=T){const t=this.getContext(_),e=n.setContext(t),s=r.setContext(t),o=e.lineWidth,a=e.color,l=s.dash||[],d=s.dashOffset,u=e.tickWidth,g=e.tickColor,p=e.tickBorderDash||[],m=e.tickBorderDashOffset;y=qs(this,_,h),void 0!==y&&(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}return this._ticksLength=d,this._borderValue=b,f}_computeLabelItems(t){const e=this.axis,i=this.options,{position:s,ticks:a}=i,r=this.isHorizontal(),l=this.ticks,{align:h,crossAlign:c,padding:d,mirror:u}=a,f=Ks(i.grid),g=f+d,p=u?-d:g,m=-$(this.labelRotation),x=[];let b,_,y,v,M,w,k,S,P,D,C,O,A=\"middle\";if(\"top\"===s)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if(\"bottom\"===s)w=this.top+p,k=this._getXAxisLabelAlignment();else if(\"left\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"right\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"x\"===e){if(\"center\"===s)w=(t.top+t.bottom)/2+g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];w=this.chart.scales[t].getPixelForValue(e)+g}k=this._getXAxisLabelAlignment()}else if(\"y\"===e){if(\"center\"===s)M=(t.left+t.right)/2-g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];M=this.chart.scales[t].getPixelForValue(e)}k=this._getYAxisLabelAlignment(f).textAlign}\"y\"===e&&(\"start\"===h?A=\"top\":\"end\"===h&&(A=\"bottom\"));const T=this._getLabelSizes();for(b=0,_=l.length;b<_;++b){y=l[b],v=y.label;const t=a.setContext(this.getContext(b));S=this.getPixelForTick(b)+a.labelOffset,P=this._resolveTickFontOptions(b),D=P.lineHeight,C=n(v)?v.length:1;const e=C/2,i=t.color,o=t.textStrokeColor,h=t.textStrokeWidth;let d,f=k;if(r?(M=S,\"inner\"===k&&(f=b===_-1?this.options.reverse?\"left\":\"right\":0===b?this.options.reverse?\"right\":\"left\":\"center\"),O=\"top\"===s?\"near\"===c||0!==m?-C*D+D/2:\"center\"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:\"near\"===c||0!==m?D/2:\"center\"===c?T.highest.height/2-e*D:T.highest.height-C*D,u&&(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=ki(t.backdropPadding),i=T.heights[b],s=T.widths[b];let n=O-e.top,o=0-e.left;switch(A){case\"middle\":n-=i/2;break;case\"bottom\":n-=i}switch(k){case\"center\":o-=s/2;break;case\"right\":o-=s;break;case\"inner\":b===_-1?o-=s:b>0&&(o-=s/2)}d={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}x.push({label:v,font:P,textOffset:O,options:{rotation:m,color:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,translation:[M,w],backdrop:d}})}return x}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-$(this.labelRotation))return\"top\"===t?\"left\":\"right\";let i=\"center\";return\"start\"===e.align?i=\"left\":\"end\"===e.align?i=\"right\":\"inner\"===e.align&&(i=\"inner\"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=this.options,o=t+n,a=this._getLabelSizes().widest.width;let r,l;return\"left\"===e?s?(l=this.right+n,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l+=a)):(l=this.right-o,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l=this.left)):\"right\"===e?s?(l=this.left+n,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l-=a)):(l=this.left+o,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l=this.right)):r=\"right\",{textAlign:r,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return\"left\"===e||\"right\"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:\"top\"===e||\"bottom\"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const i=this.ticks.findIndex((e=>e.value===t));if(i>=0){return e.setContext(this.getContext(i)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const a=(t,e,s)=>{s.width&&s.color&&(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())};if(e.display)for(n=0,o=s.length;n<o;++n){const t=s[n];e.drawOnChartArea&&a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=this,n=i.setContext(this.getContext()),o=i.display?n.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,r=this._borderValue;let l,h,c,d;this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,i=this._computeLabelArea();i&&Ie(e,i);const s=this.getLabelItems(t);for(const t of s){const i=t.options,s=t.font;Ne(e,t.label,0,t.textOffset,s,i)}i&&ze(e)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;if(!i.display)return;const a=Si(i.font),r=ki(i.padding),l=i.align;let h=a.lineHeight/2;\"bottom\"===e||\"center\"===e||o(e)?(h+=r.bottom,n(i.text)&&(h+=a.lineHeight*(i.text.length-1))):h+=r.top;const{titleX:c,titleY:d,maxWidth:u,rotation:f}=function(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=t,{chartArea:c,scales:d}=h;let u,f,g,p=0;const m=r-n,x=l-a;if(t.isHorizontal()){if(f=ft(s,a,l),o(i)){const t=Object.keys(i)[0],s=i[t];g=d[t].getPixelForValue(s)+m-e}else g=\"center\"===i?(c.bottom+c.top)/2+m-e:Ys(t,i,e);u=l-a}else{if(o(i)){const t=Object.keys(i)[0],s=i[t];f=d[t].getPixelForValue(s)-x+e}else f=\"center\"===i?(c.left+c.right)/2-x+e:Ys(t,i,e);g=ft(s,r,n),p=\"left\"===i?-E:E}return{titleX:f,titleY:g,maxWidth:u,rotation:p}}(this,h,e,l);Ne(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Zs(l,e,s),textBaseline:\"middle\",translation:[c,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=l(t.grid&&t.grid.z,-1),s=l(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Js.prototype.draw?[{z:i,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+\"AxisID\",s=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[i]!==this.id||t&&o.type!==t||s.push(o)}return s}_resolveTickFontOptions(t){return Si(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Qs{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(function(t){return\"id\"in t&&\"defaults\"in t})(e)&&(i=this.register(e));const s=this.items,n=t.id,o=this.scope+\".\"+n;if(!n)throw new Error(\"class does not have id: \"+t);return n in s||(s[n]=t,function(t,e,i){const s=x(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);ue.set(e,s),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((i=>{const s=i.split(\".\"),n=s.pop(),o=[t].concat(s).join(\".\"),a=e[i].split(\".\"),r=a.pop(),l=a.join(\".\");ue.route(o,n,l,r)}))}(e,t.defaultRoutes);t.descriptors&&ue.describe(e,t.descriptors)}(t,o,i),this.override&&ue.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i in e&&delete e[i],s&&i in ue[s]&&(delete ue[s][i],this.override&&delete re[i])}}class tn{constructor(){this.controllers=new Qs(Ns,\"datasets\",!0),this.elements=new Qs(Hs,\"elements\"),this.plugins=new Qs(Object,\"plugins\"),this.scales=new Qs(Js,\"scales\"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each(\"register\",t)}remove(...t){this._each(\"unregister\",t)}addControllers(...t){this._each(\"register\",t,this.controllers)}addElements(...t){this._each(\"register\",t,this.elements)}addPlugins(...t){this._each(\"register\",t,this.plugins)}addScales(...t){this._each(\"register\",t,this.scales)}getController(t){return this._get(t,this.controllers,\"controller\")}getElement(t){return this._get(t,this.elements,\"element\")}getPlugin(t){return this._get(t,this.plugins,\"plugin\")}getScale(t){return this._get(t,this.scales,\"scale\")}removeControllers(...t){this._each(\"unregister\",t,this.controllers)}removeElements(...t){this._each(\"unregister\",t,this.elements)}removePlugins(...t){this._each(\"unregister\",t,this.plugins)}removeScales(...t){this._each(\"unregister\",t,this.scales)}_each(t,e,i){[...e].forEach((e=>{const s=i||this._getRegistryForType(e);i||s.isForType(e)||s===this.plugins&&e.id?this._exec(t,s,e):u(e,(e=>{const s=i||this._getRegistryForType(e);this._exec(t,s,e)}))}))}_exec(t,e,i){const s=w(t);d(i[\"before\"+s],[],i),e[t](i),d(i[\"after\"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(void 0===s)throw new Error('\"'+t+'\" is not a registered '+i+\".\");return s}}var en=new tn;class sn{constructor(){this._init=[]}notify(t,e,i,s){\"beforeInit\"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,\"install\"));const n=s?this._descriptors(t).filter(s):this._descriptors(t),o=this._notify(n,t,e,i);return\"afterDestroy\"===e&&(this._notify(n,t,\"stop\"),this._notify(this._init,t,\"uninstall\")),o}_notify(t,e,i,s){s=s||{};for(const n of t){const t=n.plugin;if(!1===d(t[i],[e,s,n.options],t)&&s.cancelable)return!1}return!0}invalidate(){s(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,s=l(i.options&&i.options.plugins,{}),n=function(t){const e={},i=[],s=Object.keys(en.plugins.items);for(let t=0;t<s.length;t++)i.push(en.getPlugin(s[t]));const n=t.plugins||[];for(let t=0;t<n.length;t++){const s=n[t];-1===i.indexOf(s)&&(i.push(s),e[s.id]=!0)}return{plugins:i,localIds:e}}(i);return!1!==s||e?function(t,{plugins:e,localIds:i},s,n){const o=[],a=t.getContext();for(const r of e){const e=r.id,l=nn(s[e],n);null!==l&&o.push({plugin:r,options:on(t.config,{plugin:r,local:i[e]},l,a)})}return o}(t,n,s,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,s=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(s(e,i),t,\"stop\"),this._notify(s(i,e),t,\"start\")}}function nn(t,e){return e||!1!==t?!0===t?{}:t:null}function on(t,{plugin:e,local:i},s,n){const o=t.pluginScopeKeys(e),a=t.getOptionScopes(s,o);return i&&e.defaults&&a.push(e.defaults),t.createResolver(a,n,[\"\"],{scriptable:!1,indexable:!1,allKeys:!0})}function an(t,e){const i=ue.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||\"x\"}function rn(t){if(\"x\"===t||\"y\"===t||\"r\"===t)return t}function ln(t,...e){if(rn(t))return t;for(const s of e){const e=s.axis||(\"top\"===(i=s.position)||\"bottom\"===i?\"x\":\"left\"===i||\"right\"===i?\"y\":void 0)||t.length>1&&rn(t[0].toLowerCase());if(e)return e}var i;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function hn(t,e,i){if(i[e+\"AxisID\"]===t)return{axis:e}}function cn(t,e){const i=re[t.type]||{scales:{}},s=e.scales||{},n=an(t.type,e),a=Object.create(null);return Object.keys(s).forEach((e=>{const r=s[e];if(!o(r))return console.error(`Invalid scale configuration for scale: ${e}`);if(r._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const l=ln(e,r,function(t,e){if(e.data&&e.data.datasets){const i=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(i.length)return hn(t,\"x\",i[0])||hn(t,\"y\",i[0])}return{}}(e,t),ue.scales[r.type]),h=function(t,e){return t===e?\"_index_\":\"_value_\"}(l,n),c=i.scales||{};a[e]=b(Object.create(null),[{axis:l},r,c[l],c[h]])})),t.data.datasets.forEach((i=>{const n=i.type||t.type,o=i.indexAxis||an(n,e),r=(re[n]||{}).scales||{};Object.keys(r).forEach((t=>{const e=function(t,e){let i=t;return\"_index_\"===t?i=e:\"_value_\"===t&&(i=\"x\"===e?\"y\":\"x\"),i}(t,o),n=i[e+\"AxisID\"]||e;a[n]=a[n]||Object.create(null),b(a[n],[{axis:e},s[n],r[t]])}))})),Object.keys(a).forEach((t=>{const e=a[t];b(e,[ue.scales[e.type],ue.scale])})),a}function dn(t){const e=t.options||(t.options={});e.plugins=l(e.plugins,{}),e.scales=cn(t,e)}function un(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const fn=new Map,gn=new Set;function pn(t,e){let i=fn.get(t);return i||(i=e(),fn.set(t,i),gn.add(i)),i}const mn=(t,e,i)=>{const s=M(e,i);void 0!==s&&t.add(s)};class xn{constructor(t){this._config=function(t){return(t=t||{}).data=un(t.data),dn(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=un(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),dn(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return pn(t,(()=>[[`datasets.${t}`,\"\"]]))}datasetAnimationScopeKeys(t,e){return pn(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,\"\"]]))}datasetElementScopeKeys(t,e){return pn(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,\"\"]]))}pluginScopeKeys(t){const e=t.id;return pn(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const i=this._scopeCache;let s=i.get(t);return s&&!e||(s=new Map,i.set(t,s)),s}getOptionScopes(t,e,i){const{options:s,type:n}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const r=new Set;e.forEach((e=>{t&&(r.add(t),e.forEach((e=>mn(r,t,e)))),e.forEach((t=>mn(r,s,t))),e.forEach((t=>mn(r,re[n]||{},t))),e.forEach((t=>mn(r,ue,t))),e.forEach((t=>mn(r,le,t)))}));const l=Array.from(r);return 0===l.length&&l.push(Object.create(null)),gn.has(e)&&o.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,re[e]||{},ue.datasets[e]||{},{type:e},ue,le]}resolveNamedOptions(t,e,i,s=[\"\"]){const o={$shared:!0},{resolver:a,subPrefixes:r}=bn(this._resolverCache,t,s);let l=a;if(function(t,e){const{isScriptable:i,isIndexable:s}=Ye(t);for(const o of e){const e=i(o),a=s(o),r=(a||e)&&t[o];if(e&&(S(r)||_n(r))||a&&n(r))return!0}return!1}(a,e)){o.$shared=!1;l=$e(a,i=S(i)?i():i,this.createResolver(t,i,r))}for(const t of e)o[t]=l[t];return o}createResolver(t,e,i=[\"\"],s){const{resolver:n}=bn(this._resolverCache,t,i);return o(e)?$e(n,e,void 0,s):n}}function bn(t,e,i){let s=t.get(e);s||(s=new Map,t.set(e,s));const n=i.join();let o=s.get(n);if(!o){o={resolver:je(e,i),subPrefixes:i.filter((t=>!t.toLowerCase().includes(\"hover\")))},s.set(n,o)}return o}const _n=t=>o(t)&&Object.getOwnPropertyNames(t).some((e=>S(t[e])));const yn=[\"top\",\"bottom\",\"left\",\"right\",\"chartArea\"];function vn(t,e){return\"top\"===t||\"bottom\"===t||-1===yn.indexOf(t)&&\"x\"===e}function Mn(t,e){return function(i,s){return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}}function wn(t){const e=t.chart,i=e.options.animation;e.notifyPlugins(\"afterRender\"),d(i&&i.onComplete,[t],e)}function kn(t){const e=t.chart,i=e.options.animation;d(i&&i.onProgress,[t],e)}function Sn(t){return fe()&&\"string\"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const Pn={},Dn=t=>{const e=Sn(t);return Object.values(Pn).filter((t=>t.canvas===e)).pop()};function Cn(t,e,i){const s=Object.keys(t);for(const n of s){const s=+n;if(s>=e){const o=t[n];delete t[n],(i>0||s>e)&&(t[s+i]=o)}}}function On(t,e,i){return t.options.clip?t[i]:e[i]}class An{static defaults=ue;static instances=Pn;static overrides=re;static registry=en;static version=\"4.4.8\";static getChart=Dn;static register(...t){en.add(...t),Tn()}static unregister(...t){en.remove(...t),Tn()}constructor(t,e){const s=this.config=new xn(e),n=Sn(t),o=Dn(n);if(o)throw new Error(\"Canvas is already in use. Chart with ID '\"+o.id+\"' must be destroyed before the canvas with ID '\"+o.canvas.id+\"' can be reused.\");const a=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||ks(n)),this.platform.updateConfig(s);const r=this.platform.acquireContext(n,a.aspectRatio),l=r&&r.canvas,h=l&&l.height,c=l&&l.width;this.id=i(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new sn,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=dt((t=>this.update(t)),a.resizeDelay||0),this._dataChanges=[],Pn[this.id]=this,r&&l?(bt.listen(this,\"complete\",wn),bt.listen(this,\"progress\",kn),this._initialize(),this.attached&&this.update()):console.error(\"Failed to create chart: can't acquire context from the given item\")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=this;return s(t)?e&&o?o:n?i/n:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return en}_initialize(){return this.notifyPlugins(\"beforeInit\"),this.options.responsive?this.resize():ke(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins(\"afterInit\"),this}clear(){return Te(this.canvas,this.ctx),this}stop(){return bt.stop(this),this}resize(t,e){bt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,s=this.canvas,n=i.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,t,e,n),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),r=this.width?\"resize\":\"attach\";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ke(this,a,!0)&&(this.notifyPlugins(\"resize\",{size:o}),d(i.onResize,[this,o],this),this.attached&&this._doResize(r)&&this.render())}ensureScalesHaveIDs(){u(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,s=Object.keys(i).reduce(((t,e)=>(t[e]=!1,t)),{});let n=[];e&&(n=n.concat(Object.keys(e).map((t=>{const i=e[t],s=ln(t,i),n=\"r\"===s,o=\"x\"===s;return{options:i,dposition:n?\"chartArea\":o?\"bottom\":\"left\",dtype:n?\"radialLinear\":o?\"category\":\"linear\"}})))),u(n,(e=>{const n=e.options,o=n.id,a=ln(o,n),r=l(n.type,e.dtype);void 0!==n.position&&vn(n.position,a)===vn(e.dposition)||(n.position=e.dposition),s[o]=!0;let h=null;if(o in i&&i[o].type===r)h=i[o];else{h=new(en.getScale(r))({id:o,type:r,ctx:this.ctx,chart:this}),i[h.id]=h}h.init(n,t)})),u(s,((t,e)=>{t||delete i[e]})),u(i,(t=>{as.configure(this,t,t.options),as.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort(((t,e)=>t.index-e.index)),i>e){for(let t=e;t<i;++t)this._destroyDatasetMeta(t);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Mn(\"order\",\"index\"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,i)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(i)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,s;for(this._removeUnreferencedMetasets(),i=0,s=e.length;i<s;i++){const s=e[i];let n=this.getDatasetMeta(i);const o=s.type||this.config.type;if(n.type&&n.type!==o&&(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||an(o,this.options),n.order=s.order||0,n.index=i,n.label=\"\"+s.label,n.visible=this.isDatasetVisible(i),n.controller)n.controller.updateIndex(i),n.controller.linkScales();else{const e=en.getController(o),{datasetElementType:s,dataElementType:a}=ue.datasets[o];Object.assign(e,{dataElementType:en.getElement(a),datasetElementType:s&&en.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}}return this._updateMetasets(),t}_resetElements(){u(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins(\"reset\")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins(\"beforeUpdate\",{mode:t,cancelable:!0}))return;const n=this.buildOrUpdateControllers();this.notifyPlugins(\"beforeElementsUpdate\");let o=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t),i=!s&&-1===n.indexOf(e);e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||u(n,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins(\"afterUpdate\",{mode:t}),this._layers.sort(Mn(\"z\",\"_idx\"));const{_active:a,_lastEvent:r}=this;r?this._eventHandler(r,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){u(this.scales,(t=>{as.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);P(e,i)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:s,count:n}of e){Cn(t,s,\"_removeElements\"===i?-n:n)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+\",\"+t.splice(1).join(\",\")))),s=i(0);for(let t=1;t<e;t++)if(!P(s,i(t)))return;return Array.from(s).map((t=>t.split(\",\"))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins(\"beforeLayout\",{cancelable:!0}))return;as.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],u(this.boxes,(t=>{i&&\"chartArea\"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins(\"afterLayout\")}_updateDatasets(t){if(!1!==this.notifyPlugins(\"beforeDatasetsUpdate\",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,S(t)?t({datasetIndex:e}):t);this.notifyPlugins(\"afterDatasetsUpdate\",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),s={meta:i,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetUpdate\",s)&&(i.controller._update(e),s.cancelable=!1,this.notifyPlugins(\"afterDatasetUpdate\",s))}render(){!1!==this.notifyPlugins(\"beforeRender\",{cancelable:!0})&&(bt.has(this)?this.attached&&!bt.running(this)&&bt.start(this):(this.draw(),wn({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(t,e)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins(\"beforeDraw\",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins(\"afterDraw\")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let s,n;for(s=0,n=e.length;s<n;++s){const n=e[s];t&&!n.visible||i.push(n)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins(\"beforeDatasetsDraw\",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins(\"afterDatasetsDraw\")}_drawDataset(t){const e=this.ctx,i=t._clip,s=!i.disabled,n=function(t,e){const{xScale:i,yScale:s}=t;return i&&s?{left:On(i,e,\"left\"),right:On(i,e,\"right\"),top:On(s,e,\"top\"),bottom:On(s,e,\"bottom\")}:e}(t,this.chartArea),o={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetDraw\",o)&&(s&&Ie(e,{left:!1===i.left?0:n.left-i.left,right:!1===i.right?this.width:n.right+i.right,top:!1===i.top?0:n.top-i.top,bottom:!1===i.bottom?this.height:n.bottom+i.bottom}),t.controller.draw(),s&&ze(e),o.cancelable=!1,this.notifyPlugins(\"afterDatasetDraw\",o))}isPointInArea(t){return Re(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,i,s){const n=Xi.modes[e];return\"function\"==typeof n?n(this,t,i,s):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let s=i.filter((t=>t&&t._dataset===e)).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}getContext(){return this.$context||(this.$context=Ci(null,{chart:this,type:\"chart\"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return\"boolean\"==typeof i.hidden?!i.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const s=i?\"show\":\"hide\",n=this.getDatasetMeta(t),o=n.controller._resolveAnimations(void 0,s);k(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((e=>e.datasetIndex===t?s:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),bt.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins(\"beforeDestroy\");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Te(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Pn[this.id],this.notifyPlugins(\"afterDestroy\")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(t,e,i)=>{t.offsetX=e,t.offsetY=i,this._eventHandler(t)};u(this.options.events,(t=>i(t,s)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(i,s)=>{t[i]&&(e.removeEventListener(this,i,s),delete t[i])},n=(t,e)=>{this.canvas&&this.resize(t,e)};let o;const a=()=>{s(\"attach\",a),this.attached=!0,this.resize(),i(\"resize\",n),i(\"detach\",o)};o=()=>{this.attached=!1,s(\"resize\",n),this._stop(),this._resize(0,0),i(\"attach\",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){u(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},u(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const s=i?\"set\":\"remove\";let n,o,a,r;for(\"dataset\"===e&&(n=this.getDatasetMeta(t[0].datasetIndex),n.controller[\"_\"+s+\"DatasetHoverStyle\"]()),a=0,r=t.length;a<r;++a){o=t[a];const e=o&&this.getDatasetMeta(o.datasetIndex).controller;e&&e[s+\"HoverStyle\"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map((({datasetIndex:t,index:e})=>{const i=this.getDatasetMeta(t);if(!i)throw new Error(\"No dataset found at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}}));!f(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,i){const s=this.options.hover,n=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),o=n(e,t),a=i?t:n(t,e);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},s=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins(\"beforeEvent\",i,s))return;const n=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins(\"afterEvent\",i,s),(n||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:s=[],options:n}=this,o=e,a=this._getActiveElements(t,s,i,o),r=D(t),l=function(t,e,i,s){return i&&\"mouseout\"!==t.type?s?e:t:null}(t,this._lastEvent,i,r);i&&(this._lastEvent=null,d(n.onHover,[t,a,this],this),r&&d(n.onClick,[t,a,this],this));const h=!f(a,s);return(h||e)&&(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}_getActiveElements(t,e,i,s){if(\"mouseout\"===t.type)return[];if(!i)return e;const n=this.options.hover;return this.getElementsAtEventForMode(t,n.mode,n,s)}}function Tn(){return u(An.instances,(t=>t._plugins.invalidate()))}function Ln(){throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\")}class En{static override(t){Object.assign(En.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Ln()}parse(){return Ln()}format(){return Ln()}add(){return Ln()}diff(){return Ln()}startOf(){return Ln()}endOf(){return Ln()}}var Rn={_date:En};function In(t){const e=t.iScale,i=function(t,e){if(!t._cache.$bar){const i=t.getMatchingVisibleMetas(e);let s=[];for(let e=0,n=i.length;e<n;e++)s=s.concat(i[e].controller.getAllParsedValues(t));t._cache.$bar=lt(s.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let s,n,o,a,r=e._length;const l=()=>{32767!==o&&-32768!==o&&(k(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,n=i.length;s<n;++s)o=e.getPixelForValue(i[s]),l();for(a=void 0,s=0,n=e.ticks.length;s<n;++s)o=e.getPixelForTick(s),l();return r}function zn(t,e,i,s){return n(t)?function(t,e,i,s){const n=i.parse(t[0],s),o=i.parse(t[1],s),a=Math.min(n,o),r=Math.max(n,o);let l=a,h=r;Math.abs(a)>Math.abs(r)&&(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}(t,e,i,s):e[i.axis]=i.parse(t,s),e}function Fn(t,e,i,s){const n=t.iScale,o=t.vScale,a=n.getLabels(),r=n===o,l=[];let h,c,d,u;for(h=i,c=i+s;h<c;++h)u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(zn(u,d,o,h));return l}function Vn(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function Bn(t,e,i,s){let n=e.borderSkipped;const o={};if(!n)return void(t.borderSkipped=o);if(!0===n)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:a,end:r,reverse:l,top:h,bottom:c}=function(t){let e,i,s,n,o;return t.horizontal?(e=t.base>t.x,i=\"left\",s=\"right\"):(e=t.base<t.y,i=\"bottom\",s=\"top\"),e?(n=\"end\",o=\"start\"):(n=\"start\",o=\"end\"),{start:i,end:s,reverse:e,top:n,bottom:o}}(t);\"middle\"===n&&i&&(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[Wn(c,a,r,l)]=!0,n=h)),o[Wn(n,a,r,l)]=!0,t.borderSkipped=o}function Wn(t,e,i,s){var n,o,a;return s?(a=i,t=Nn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Nn(t,e,i),t}function Nn(t,e,i){return\"start\"===t?e:\"end\"===t?i:t}function Hn(t,{inflateAmount:e},i){t.inflateAmount=\"auto\"===e?1===i?.33:0:e}class jn extends Ns{static id=\"doughnut\";static defaults={datasetElementType:!1,dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:\"number\",properties:[\"circumference\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"startAngle\",\"x\",\"y\",\"offset\",\"borderWidth\",\"spacing\"]}},cutout:\"50%\",rotation:0,circumference:360,radius:\"100%\",spacing:0,indexAxis:\"r\"};static descriptors={_scriptable:t=>\"spacing\"!==t,_indexable:t=>\"spacing\"!==t&&!t.startsWith(\"borderDash\")&&!t.startsWith(\"hoverBorderDash\")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const i=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=i;else{let n,a,r=t=>+i[t];if(o(i[t])){const{key:t=\"value\"}=this._parsing;r=e=>+M(i[e],t)}for(n=t,a=t+e;n<a;++n)s._parsed[n]=r(n)}}_getRotation(){return $(this.options.rotation-90)}_getCircumference(){return $(this.options.circumference)}_getRotationExtents(){let t=O,e=-O;for(let i=0;i<this.chart.data.datasets.length;++i)if(this.chart.isDatasetVisible(i)&&this.chart.getDatasetMeta(i).type===this._type){const s=this.chart.getDatasetMeta(i).controller,n=s._getRotation(),o=s._getCircumference();t=Math.min(t,n),e=Math.max(e,n+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:i}=e,s=this._cachedMeta,n=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,a=Math.max((Math.min(i.width,i.height)-o)/2,0),r=Math.min(h(this.options.cutout,a),1),l=this._getRingWeight(this.index),{circumference:d,rotation:u}=this._getRotationExtents(),{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=function(t,e,i){let s=1,n=1,o=0,a=0;if(e<O){const r=t,l=r+e,h=Math.cos(r),c=Math.sin(r),d=Math.cos(l),u=Math.sin(l),f=(t,e,s)=>Z(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),g=(t,e,s)=>Z(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),p=f(0,h,d),m=f(E,c,u),x=g(C,h,d),b=g(C+E,c,u);s=(p-x)/2,n=(m-b)/2,o=-(p+x)/2,a=-(m+b)/2}return{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}(u,d,r),x=(i.width-o)/f,b=(i.height-o)/g,_=Math.max(Math.min(x,b)/2,0),y=c(this.options.radius,_),v=(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(n,0,n.length,t)}_circumference(t,e){const i=this.options,s=this._cachedMeta,n=this._getCircumference();return e&&i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.chartArea,r=o.options.animation,l=(a.left+a.right)/2,h=(a.top+a.bottom)/2,c=n&&r.animateScale,d=c?0:this.innerRadius,u=c?0:this.outerRadius,{sharedOptions:f,includeOptions:g}=this._getSharedOptions(e,s);let p,m=this._getRotation();for(p=0;p<e;++p)m+=this._circumference(p,n);for(p=e;p<e+i;++p){const e=this._circumference(p,n),i=t[p],o={x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};g&&(o.options=f||this.resolveDataElementOptions(p,i.active?\"active\":s)),m+=e,this.updateElement(i,p,o,s)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let i,s=0;for(i=0;i<e.length;i++){const n=t._parsed[i];null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?O*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t],i.options.locale);return{label:s[t]||\"\",value:n}}getMaxBorderWidth(t){let e=0;const i=this.chart;let s,n,o,a,r;if(!t)for(s=0,n=i.data.datasets.length;s<n;++s)if(i.isDatasetVisible(s)){o=i.getDatasetMeta(s),t=o.data,a=o.controller;break}if(!t)return 0;for(s=0,n=t.length;s<n;++s)r=a.resolveDataElementOptions(s),\"inner\"!==r.borderAlign&&(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let i=0,s=t.length;i<s;++i){const t=this.resolveDataElementOptions(i);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e}_getRingWeight(t){return Math.max(l(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class $n extends Ns{static id=\"polarArea\";static defaults={dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"]}},indexAxis:\"r\",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}},scales:{r:{type:\"radialLinear\",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t].r,i.options.locale);return{label:s[t]||\"\",value:n}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,i)=>{const s=this.getParsed(i).r;!isNaN(s)&&this.chart.getDataVisibility(i)&&(s<e.min&&(e.min=s),s>e.max&&(e.max=s))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,i=t.options,s=Math.min(e.right-e.left,e.bottom-e.top),n=Math.max(s/2,0),o=(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.options.animation,r=this._cachedMeta.rScale,l=r.xCenter,h=r.yCenter,c=r.getIndexAngle(0)-.5*C;let d,u=c;const f=360/this.countVisibleElements();for(d=0;d<e;++d)u+=this._computeAngle(d,s,f);for(d=e;d<e+i;d++){const e=t[d];let i=u,g=u+this._computeAngle(d,s,f),p=o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;u=g,n&&(a.animateScale&&(p=0),a.animateRotate&&(i=g=c));const m={x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?\"active\":s)};this.updateElement(e,d,m,s)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&e++})),e}_computeAngle(t,e,i){return this.chart.getDataVisibility(t)?$(this.resolveDataElementOptions(t,e).angle||i):0}}var Yn=Object.freeze({__proto__:null,BarController:class extends Ns{static id=\"bar\";static defaults={datasetElementType:!1,dataElementType:\"bar\",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"base\",\"width\",\"height\"]}}};static overrides={scales:{_index_:{type:\"category\",offset:!0,grid:{offset:!0}},_value_:{type:\"linear\",beginAtZero:!0}}};parsePrimitiveData(t,e,i,s){return Fn(t,e,i,s)}parseArrayData(t,e,i,s){return Fn(t,e,i,s)}parseObjectData(t,e,i,s){const{iScale:n,vScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=\"x\"===n.axis?a:r,h=\"x\"===o.axis?a:r,c=[];let d,u,f,g;for(d=i,u=i+s;d<u;++d)g=e[d],f={},f[n.axis]=n.parse(M(g,l),d),c.push(zn(M(g,h),f,o,d));return c}updateRangeFromParsed(t,e,i,s){super.updateRangeFromParsed(t,e,i,s);const n=i._custom;n&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:i,vScale:s}=e,n=this.getParsed(t),o=n._custom,a=Vn(o)?\"[\"+o.start+\", \"+o.end+\"]\":\"\"+s.getLabelForValue(n[s.axis]);return{label:\"\"+i.getLabelForValue(n[i.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{index:a,_cachedMeta:{vScale:r}}=this,l=r.getBasePixel(),h=r.isHorizontal(),c=this._getRuler(),{sharedOptions:d,includeOptions:u}=this._getSharedOptions(e,n);for(let f=e;f<e+i;f++){const e=this.getParsed(f),i=o||s(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),g=this._calculateBarIndexPixels(f,c),p=(e._stacks||{})[r.axis],m={horizontal:h,base:i.base,enableBorderRadius:!p||Vn(e._custom)||a===p._top||a===p._bottom,x:h?i.head:g.center,y:h?g.center:i.head,height:h?g.size:Math.abs(i.size),width:h?Math.abs(i.size):g.size};u&&(m.options=d||this.resolveDataElementOptions(f,t[f].active?\"active\":n));const x=m.options||t[f].options;Bn(m,x,p,a),Hn(m,x,c.ratio),this.updateElement(t[f],f,m,n)}}_getStacks(t,e){const{iScale:i}=this._cachedMeta,n=i.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),o=i.options.stacked,a=[],r=this._cachedMeta.controller.getParsed(e),l=r&&r[i.axis],h=t=>{const e=t._parsed.find((t=>t[i.axis]===l)),n=e&&e[t.vScale.axis];if(s(n)||isNaN(n))return!0};for(const i of n)if((void 0===e||!h(i))&&((!1===o||-1===a.indexOf(i.stack)||void 0===o&&void 0===i.stack)&&a.push(i.stack),i.index===t))break;return a.length||a.push(void 0),a}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,i){const s=this._getStacks(t,i),n=void 0!==e?s.indexOf(e):-1;return-1===n?s.length-1:n}_getRuler(){const t=this.options,e=this._cachedMeta,i=e.iScale,s=[];let n,o;for(n=0,o=e.data.length;n<o;++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));const a=t.barThickness;return{min:a||In(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=this,r=o||0,l=this.getParsed(t),h=l._custom,c=Vn(h);let d,u,f=l[e.axis],g=0,p=i?this.applyStack(e,l,i):f;p!==f&&(g=p-f,p=f),c&&(f=h.barStart,p=h.barEnd-h.barStart,0!==f&&F(f)!==F(h.barEnd)&&(g=0),g+=f);const m=s(o)||c?g:o;let x=e.getPixelForValue(m);if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(g+p):x,u=d-x,Math.abs(u)<a){u=function(t,e,i){return 0!==t?F(t):(e.isHorizontal()?1:-1)*(e.min>=i?1:-1)}(u,e,r)*a,f===r&&(x-=u/2);const t=e.getPixelForDecimal(0),s=e.getPixelForDecimal(1),o=Math.min(t,s),h=Math.max(t,s);x=Math.max(Math.min(x,h),o),d=x+u,i&&!c&&(l._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(x))}if(x===e.getPixelForValue(r)){const t=F(u)*e.getLineWidthForValue(r)/2;x+=t,u-=t}return{size:u,base:x,head:d,center:d+u/2}}_calculateBarIndexPixels(t,e){const i=e.scale,n=this.options,o=n.skipNull,a=l(n.maxBarThickness,1/0);let r,h;if(e.grouped){const i=o?this._getStackCount(t):e.stackCount,l=\"flex\"===n.barThickness?function(t,e,i,s){const n=e.pixels,o=n[t];let a=t>0?n[t-1]:null,r=t<n.length-1?n[t+1]:null;const l=i.categoryPercentage;null===a&&(a=o-(null===r?e.end-e.start:r-o)),null===r&&(r=o+o-a);const h=o-(o-Math.min(a,r))/2*l;return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}(t,e,n,i):function(t,e,i,n){const o=i.barThickness;let a,r;return s(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}(t,e,n,i),c=this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);r=l.start+l.chunk*c+l.chunk/2,h=Math.min(a,l.chunk*l.ratio)}else r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);return{base:r-h/2,head:r+h/2,center:r,size:h}}draw(){const t=this._cachedMeta,e=t.vScale,i=t.data,s=i.length;let n=0;for(;n<s;++n)null===this.getParsed(n)[e.axis]||i[n].hidden||i[n].draw(this._ctx)}},BubbleController:class extends Ns{static id=\"bubble\";static defaults={datasetElementType:!1,dataElementType:\"point\",animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"borderWidth\",\"radius\"]}}};static overrides={scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,i,s){const n=super.parsePrimitiveData(t,e,i,s);for(let t=0;t<n.length;t++)n[t]._custom=this.resolveDataElementOptions(t+i).radius;return n}parseArrayData(t,e,i,s){const n=super.parseArrayData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s[2],this.resolveDataElementOptions(t+i).radius)}return n}parseObjectData(t,e,i,s){const n=super.parseObjectData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s&&s.r&&+s.r,this.resolveDataElementOptions(t+i).radius)}return n}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let i=t.length-1;i>=0;--i)e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y),l=o._custom;return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+(l?\", \"+l:\"\")+\")\"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,i,s){const n=\"reset\"===s,{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:r,includeOptions:l}=this._getSharedOptions(e,s),h=o.axis,c=a.axis;for(let d=e;d<e+i;d++){const e=t[d],i=!n&&this.getParsed(d),u={},f=u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),g=u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);u.skip=isNaN(f)||isNaN(g),l&&(u.options=r||this.resolveDataElementOptions(d,e.active?\"active\":s),n&&(u.options.radius=0)),this.updateElement(e,d,u,s)}}resolveDataElementOptions(t,e){const i=this.getParsed(t);let s=super.resolveDataElementOptions(t,e);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const n=s.radius;return\"active\"!==e&&(s.radius=0),s.radius+=l(i&&i._custom,n),s}},DoughnutController:jn,LineController:class extends Ns{static id=\"line\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:\"category\"},_value_:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:i,data:s=[],_dataset:n}=e,o=this.chart._animationsDisabled;let{start:a,count:r}=pt(e,s,o);this._drawStart=a,this._drawCount=r,mt(e)&&(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,{sharedOptions:c,includeOptions:d}=this._getSharedOptions(e,n),u=a.axis,f=r.axis,{spanGaps:g,segment:p}=this.options,m=N(g)?g:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||o||\"none\"===n,b=e+i,_=t.length;let y=e>0&&this.getParsed(e-1);for(let i=0;i<_;++i){const g=t[i],_=x?g:{};if(i<e||i>=b){_.skip=!0;continue}const v=this.getParsed(i),M=s(v[f]),w=_[u]=a.getPixelForValue(v[u],i),k=_[f]=o||M?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,v,l):v[f],i);_.skip=isNaN(w)||isNaN(k)||M,_.stop=i>0&&Math.abs(v[u]-y[u])>m,p&&(_.parsed=v,_.raw=h.data[i]),d&&(_.options=c||this.resolveDataElementOptions(i,g.active?\"active\":n)),x||this.updateElement(g,i,_,n),y=v}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,i=e.options&&e.options.borderWidth||0,s=t.data||[];if(!s.length)return i;const n=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(i,n,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}},PieController:class extends jn{static id=\"pie\";static defaults={cutout:0,rotation:0,circumference:360,radius:\"100%\"}},PolarAreaController:$n,RadarController:class extends Ns{static id=\"radar\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",indexAxis:\"r\",showLine:!0,elements:{line:{fill:\"start\"}}};static overrides={aspectRatio:1,scales:{r:{type:\"radialLinear\"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,i=this.getParsed(t);return{label:e.getLabels()[t],value:\"\"+e.getLabelForValue(i[e.axis])}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta,i=e.dataset,s=e.data||[],n=e.iScale.getLabels();if(i.points=s,\"resize\"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const o={_loop:!0,_fullLoop:n.length===s.length,options:e};this.updateElement(i,void 0,o,t)}this.updateElements(s,0,s.length,t)}updateElements(t,e,i,s){const n=this._cachedMeta.rScale,o=\"reset\"===s;for(let a=e;a<e+i;a++){const e=t[a],i=this.resolveDataElementOptions(a,e.active?\"active\":s),r=n.getPointPositionForValue(a,this.getParsed(a).r),l=o?n.xCenter:r.x,h=o?n.yCenter:r.y,c={x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};this.updateElement(e,a,c,s)}}},ScatterController:class extends Ns{static id=\"scatter\";static defaults={datasetElementType:!1,dataElementType:\"point\",showLine:!1,fill:!1};static overrides={interaction:{mode:\"point\"},scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y);return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+\")\"}}update(t){const e=this._cachedMeta,{data:i=[]}=e,s=this.chart._animationsDisabled;let{start:n,count:o}=pt(e,i,s);if(this._drawStart=n,this._drawCount=o,mt(e)&&(n=0,o=i.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:n,_dataset:o}=e;n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;const a=this.resolveDatasetElementOptions(t);a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(i,n,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement(\"line\")),super.addElements()}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,c=this.resolveDataElementOptions(e,n),d=this.getSharedOptions(c),u=this.includeOptions(n,d),f=a.axis,g=r.axis,{spanGaps:p,segment:m}=this.options,x=N(p)?p:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||o||\"none\"===n;let _=e>0&&this.getParsed(e-1);for(let c=e;c<e+i;++c){const e=t[c],i=this.getParsed(c),p=b?e:{},y=s(i[g]),v=p[f]=a.getPixelForValue(i[f],c),M=p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,i,l):i[g],c);p.skip=isNaN(v)||isNaN(M)||y,p.stop=c>0&&Math.abs(i[f]-_[f])>x,m&&(p.parsed=i,p.raw=h.data[c]),u&&(p.options=d||this.resolveDataElementOptions(c,e.active?\"active\":n)),b||this.updateElement(e,c,p,n),_=i}this.updateSharedOptions(d,n,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let i=e.length-1;i>=0;--i)t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);return t>0&&t}const i=t.dataset,s=i.options&&i.options.borderWidth||0;if(!e.length)return s;const n=e[0].size(this.resolveDataElementOptions(0)),o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(s,n,o)/2}}});function Un(t,e,i,s){const n=vi(t.options.borderRadius,[\"outerStart\",\"outerEnd\",\"innerStart\",\"innerEnd\"]);const o=(i-e)/2,a=Math.min(o,s*e/2),r=t=>{const e=(i-Math.min(o,t))*s/2;return J(t,0,Math.min(o,e))};return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:J(n.innerStart,0,a),innerEnd:J(n.innerEnd,0,a)}}function Xn(t,e,i,s){return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}function qn(t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=e,d=Math.max(e.outerRadius+s+i-h,0),u=c>0?c+s+i+h:0;let f=0;const g=n-l;if(s){const t=((c>0?c-s:0)+(d>0?d-s:0))/2;f=(g-(0!==t?g*t/(t+s):g))/2}const p=(g-Math.max(.001,g*d-i/C)/d)/2,m=l+p+f,x=n-p-f,{outerStart:b,outerEnd:_,innerStart:y,innerEnd:v}=Un(e,u,d,x-m),M=d-b,w=d-_,k=m+b/M,S=x-_/w,P=u+y,D=u+v,O=m+y/P,A=x-v/D;if(t.beginPath(),o){const e=(k+S)/2;if(t.arc(a,r,d,k,e),t.arc(a,r,d,e,S),_>0){const e=Xn(w,S,a,r);t.arc(e.x,e.y,_,S,x+E)}const i=Xn(D,x,a,r);if(t.lineTo(i.x,i.y),v>0){const e=Xn(D,A,a,r);t.arc(e.x,e.y,v,x+E,A+Math.PI)}const s=(x-v/u+(m+y/u))/2;if(t.arc(a,r,u,x-v/u,s,!0),t.arc(a,r,u,s,m+y/u,!0),y>0){const e=Xn(P,O,a,r);t.arc(e.x,e.y,y,O+Math.PI,m-E)}const n=Xn(M,m,a,r);if(t.lineTo(n.x,n.y),b>0){const e=Xn(M,k,a,r);t.arc(e.x,e.y,b,m-E,k)}}else{t.moveTo(a,r);const e=Math.cos(k)*d+a,i=Math.sin(k)*d+r;t.lineTo(e,i);const s=Math.cos(S)*d+a,n=Math.sin(S)*d+r;t.lineTo(s,n)}t.closePath()}function Kn(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r,options:l}=e,{borderWidth:h,borderJoinStyle:c,borderDash:d,borderDashOffset:u}=l,f=\"inner\"===l.borderAlign;if(!h)return;t.setLineDash(d||[]),t.lineDashOffset=u,f?(t.lineWidth=2*h,t.lineJoin=c||\"round\"):(t.lineWidth=h,t.lineJoin=c||\"bevel\");let g=e.endAngle;if(o){qn(t,e,i,s,g,n);for(let e=0;e<o;++e)t.stroke();isNaN(r)||(g=a+(r%O||O))}f&&function(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=e;let h=n/r;t.beginPath(),t.arc(o,a,r,s-h,i+h),l>n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+E,s-E),t.closePath(),t.clip()}(t,e,g),o||(qn(t,e,i,s,g,n),t.stroke())}function Gn(t,e,i=e){t.lineCap=l(i.borderCapStyle,e.borderCapStyle),t.setLineDash(l(i.borderDash,e.borderDash)),t.lineDashOffset=l(i.borderDashOffset,e.borderDashOffset),t.lineJoin=l(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=l(i.borderWidth,e.borderWidth),t.strokeStyle=l(i.borderColor,e.borderColor)}function Zn(t,e,i){t.lineTo(i.x,i.y)}function Jn(t,e,i={}){const s=t.length,{start:n=0,end:o=s-1}=i,{start:a,end:r}=e,l=Math.max(n,a),h=Math.min(o,r),c=n<a&&o<a||n>r&&o>r;return{count:s,start:l,loop:e.loop,ilen:h<l&&!c?s+h-l:h-l}}function Qn(t,e,i,s){const{points:n,options:o}=e,{count:a,start:r,loop:l,ilen:h}=Jn(n,i,s),c=function(t){return t.stepped?Fe:t.tension||\"monotone\"===t.cubicInterpolationMode?Ve:Zn}(o);let d,u,f,{move:g=!0,reverse:p}=s||{};for(d=0;d<=h;++d)u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);return l&&(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}function to(t,e,i,s){const n=e.points,{count:o,start:a,ilen:r}=Jn(n,i,s),{move:l=!0,reverse:h}=s||{};let c,d,u,f,g,p,m=0,x=0;const b=t=>(a+(h?r-t:t))%o,_=()=>{f!==g&&(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))};for(l&&(d=n[b(0)],t.moveTo(d.x,d.y)),c=0;c<=r;++c){if(d=n[b(c)],d.skip)continue;const e=d.x,i=d.y,s=0|e;s===u?(i<f?f=i:i>g&&(g=i),m=(x*m+e)/++x):(_(),t.lineTo(e,i),u=s,x=0,f=g=i),p=i}_()}function eo(t){const e=t.options,i=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||\"monotone\"===e.cubicInterpolationMode||e.stepped||i)?to:Qn}const io=\"function\"==typeof Path2D;function so(t,e,i,s){io&&!e.options.segment?function(t,e,i,s){let n=e._path;n||(n=e._path=new Path2D,e.path(n,i,s)&&n.closePath()),Gn(t,e.options),t.stroke(n)}(t,e,i,s):function(t,e,i,s){const{segments:n,options:o}=e,a=eo(e);for(const r of n)Gn(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&&t.closePath(),t.stroke()}(t,e,i,s)}class no extends Hs{static id=\"line\";static defaults={borderCapStyle:\"butt\",borderDash:[],borderDashOffset:0,borderJoinStyle:\"miter\",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:\"default\",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t&&\"fill\"!==t};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const i=this.options;if((i.tension||\"monotone\"===i.cubicInterpolationMode)&&!i.stepped&&!this._pointsUpdated){const s=i.spanGaps?this._loop:this._fullLoop;hi(this._points,i,t,s,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=zi(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,i=t.length;return i&&e[t[i-1].end]}interpolate(t,e){const i=this.options,s=t[e],n=this.points,o=Ii(this,{property:e,start:s,end:s});if(!o.length)return;const a=[],r=function(t){return t.stepped?pi:t.tension||\"monotone\"===t.cubicInterpolationMode?mi:gi}(i);let l,h;for(l=0,h=o.length;l<h;++l){const{start:h,end:c}=o[l],d=n[h],u=n[c];if(d===u){a.push(d);continue}const f=r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);f[e]=t[e],a.push(f)}return 1===a.length?a[0]:a}pathSegment(t,e,i){return eo(this)(t,this,e,i)}path(t,e,i){const s=this.segments,n=eo(this);let o=this._loop;e=e||0,i=i||this.points.length-e;for(const a of s)o&=n(t,this,a,{start:e,end:e+i-1});return!!o}draw(t,e,i,s){const n=this.options||{};(this.points||[]).length&&n.borderWidth&&(t.save(),so(t,this,i,s),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function oo(t,e,i,s){const n=t.options,{[i]:o}=t.getProps([i],s);return Math.abs(e-o)<n.radius+n.hitRadius}function ao(t,e){const{x:i,y:s,base:n,width:o,height:a}=t.getProps([\"x\",\"y\",\"base\",\"width\",\"height\"],e);let r,l,h,c,d;return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}function ro(t,e,i,s){return t?0:J(e,i,s)}function lo(t){const e=ao(t),i=e.right-e.left,s=e.bottom-e.top,n=function(t,e,i){const s=t.options.borderWidth,n=t.borderSkipped,o=Mi(s);return{t:ro(n.top,o.top,0,i),r:ro(n.right,o.right,0,e),b:ro(n.bottom,o.bottom,0,i),l:ro(n.left,o.left,0,e)}}(t,i/2,s/2),a=function(t,e,i){const{enableBorderRadius:s}=t.getProps([\"enableBorderRadius\"]),n=t.options.borderRadius,a=wi(n),r=Math.min(e,i),l=t.borderSkipped,h=s||o(n);return{topLeft:ro(!h||l.top||l.left,a.topLeft,0,r),topRight:ro(!h||l.top||l.right,a.topRight,0,r),bottomLeft:ro(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:ro(!h||l.bottom||l.right,a.bottomRight,0,r)}}(t,i/2,s/2);return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,a.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(n.b,n.r))}}}}function ho(t,e,i,s){const n=null===e,o=null===i,a=t&&!(n&&o)&&ao(t,s);return a&&(n||tt(e,a.left,a.right))&&(o||tt(i,a.top,a.bottom))}function co(t,e){t.rect(e.x,e.y,e.w,e.h)}function uo(t,e,i={}){const s=t.x!==i.x?-e:0,n=t.y!==i.y?-e:0,o=(t.x+t.w!==i.x+i.w?e:0)-s,a=(t.y+t.h!==i.y+i.h?e:0)-n;return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}var fo=Object.freeze({__proto__:null,ArcElement:class extends Hs{static id=\"arc\";static defaults={borderAlign:\"center\",borderColor:\"#fff\",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:\"backgroundColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.getProps([\"x\",\"y\"],i),{angle:n,distance:o}=X(s,{x:t,y:e}),{startAngle:a,endAngle:r,innerRadius:h,outerRadius:c,circumference:d}=this.getProps([\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],i),u=(this.options.spacing+this.options.borderWidth)/2,f=l(d,r-a),g=Z(n,a,r)&&a!==r,p=f>=O||g,m=tt(o,h+u,c+u);return p&&m}getCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=this.getProps([\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"],t),{offset:r,spacing:l}=this.options,h=(s+n)/2,c=(o+a+l+r)/2;return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,s=(e.offset||0)/4,n=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin=\"inner\"===e.borderAlign?.33:0,this.fullCircles=i>O?Math.floor(i/O):0,0===i||this.innerRadius<0||this.outerRadius<0)return;t.save();const a=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(a)*s,Math.sin(a)*s);const r=s*(1-Math.sin(Math.min(C,i||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=e;let l=e.endAngle;if(o){qn(t,e,i,s,l,n);for(let e=0;e<o;++e)t.fill();isNaN(r)||(l=a+(r%O||O))}qn(t,e,i,s,l,n),t.fill()}(t,this,r,n,o),Kn(t,this,r,n,o),t.restore()}},BarElement:class extends Hs{static id=\"bar\";static defaults={borderSkipped:\"start\",borderWidth:0,borderRadius:0,inflateAmount:\"auto\",pointStyle:void 0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=this,{inner:n,outer:o}=lo(this),a=(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?He:co;var r;t.save(),o.w===n.w&&o.h===n.h||(t.beginPath(),a(t,uo(o,e,n)),t.clip(),a(t,uo(n,-e,o)),t.fillStyle=i,t.fill(\"evenodd\")),t.beginPath(),a(t,uo(n,e)),t.fillStyle=s,t.fill(),t.restore()}inRange(t,e,i){return ho(this,t,e,i)}inXRange(t,e){return ho(this,t,null,e)}inYRange(t,e){return ho(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=this.getProps([\"x\",\"y\",\"base\",\"horizontal\"],t);return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}getRange(t){return\"x\"===t?this.width/2:this.height/2}},LineElement:no,PointElement:class extends Hs{static id=\"point\";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:\"circle\",radius:3,rotation:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.options,{x:n,y:o}=this.getProps([\"x\",\"y\"],i);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(t,e){return oo(this,t,\"x\",e)}inYRange(t,e){return oo(this,t,\"y\",e)}getCenterPoint(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const i=this.options;this.skip||i.radius<.1||!Re(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Le(t,i,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}});function go(t,e,i,s){const n=t.indexOf(e);if(-1===n)return((t,e,i,s)=>(\"string\"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&&(i=null),i))(t,e,i,s);return n!==t.lastIndexOf(e)?i:n}function po(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}function mo(t,e,{horizontal:i,minRotation:s}){const n=$(s),o=(i?Math.sin(n):Math.cos(n))||.001,a=.75*e*(\"\"+t).length;return Math.min(e/o,a)}class xo extends Js{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return s(t)||(\"number\"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:s,max:n}=this;const o=t=>s=e?s:t,a=t=>n=i?n:t;if(t){const t=F(s),e=F(n);t<0&&e<0?a(0):t>0&&e>0&&o(0)}if(s===n){let e=0===n?1:Math.abs(.05*n);a(n+e),t||o(s-e)}this.min=s,this.max=n}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:i,stepSize:s}=t;return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&&(e=Math.min(i,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const n=function(t,e){const i=[],{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=t,f=o||1,g=c-1,{min:p,max:m}=e,x=!s(a),b=!s(r),_=!s(h),y=(m-p)/(d+1);let v,M,w,k,S=B((m-p)/g/f)*f;if(S<1e-14&&!x&&!b)return[{value:p},{value:m}];k=Math.ceil(m/S)-Math.floor(p/S),k>g&&(S=B(k*S/g/f)*f),s(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),\"ticks\"===n?(M=Math.floor(p/S)*S,w=Math.ceil(m/S)*S):(M=p,w=m),x&&b&&o&&H((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=x?a:M,w=b?r:w,k=h-1,S=(w-M)/k):(k=(w-M)/S,k=V(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));const P=Math.max(U(S),U(M));v=Math.pow(10,s(l)?P:l),M=Math.round(M*v)/v,w=Math.round(w*v)/v;let D=0;for(x&&(u&&M!==a?(i.push({value:a}),M<a&&D++,V(Math.round((M+D*S)*v)/v,a,mo(a,y,t))&&D++):M<a&&D++);D<k;++D){const t=Math.round((M+D*S)*v)/v;if(b&&t>r)break;i.push({value:t})}return b&&u&&w!==r?i.length&&V(i[i.length-1].value,r,mo(r,y,t))?i[i.length-1].value=r:i.push({value:r}):b&&w!==r||i.push({value:w}),i}({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return\"ticks\"===t.bounds&&j(n,this,\"value\"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const s=(i-e)/Math.max(t.length-1,1)/2;e-=s,i+=s}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return ne(t,this.chart.options.locale,this.options.ticks.format)}}class bo extends xo{static id=\"linear\";static defaults={ticks:{callback:ae.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?t:0,this.max=a(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=$(this.options.ticks.minRotation),s=(t?Math.sin(i):Math.cos(i))||.001,n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/s))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const _o=t=>Math.floor(z(t)),yo=(t,e)=>Math.pow(10,_o(t)+e);function vo(t){return 1===t/Math.pow(10,_o(t))}function Mo(t,e,i){const s=Math.pow(10,i),n=Math.floor(t/s);return Math.ceil(e/s)-n}function wo(t,{min:e,max:i}){e=r(t.min,e);const s=[],n=_o(e);let o=function(t,e){let i=_o(e-t);for(;Mo(t,e,i)>10;)i++;for(;Mo(t,e,i)<10;)i--;return Math.min(i,_o(t))}(e,i),a=o<0?Math.pow(10,Math.abs(o)):1;const l=Math.pow(10,o),h=n>o?Math.pow(10,n):0,c=Math.round((e-h)*a)/a,d=Math.floor((e-h)/l/10)*l*10;let u=Math.floor((c-d)/Math.pow(10,o)),f=r(t.min,Math.round((h+d+u*Math.pow(10,o))*a)/a);for(;f<i;)s.push({value:f,major:vo(f),significand:u}),u>=10?u=u<15?15:20:u++,u>=20&&(o++,u=2,a=o>=0?1:a),f=Math.round((h+d+u*Math.pow(10,o))*a)/a;const g=r(t.max,f);return s.push({value:g,major:vo(g),significand:u}),s}class ko extends Js{static id=\"logarithmic\";static defaults={ticks:{callback:ae.formatters.logarithmic,major:{enabled:!0}}};constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=xo.prototype.parse.apply(this,[t,e]);if(0!==i)return a(i)&&i>0?i:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?Math.max(0,t):null,this.max=a(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!a(this._userMin)&&(this.min=t===yo(this.min,0)?yo(this.min,-1):yo(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,s=this.max;const n=e=>i=t?i:e,o=t=>s=e?s:t;i===s&&(i<=0?(n(1),o(10)):(n(yo(i,-1)),o(yo(s,1)))),i<=0&&n(yo(s,-1)),s<=0&&o(yo(i,1)),this.min=i,this.max=s}buildTicks(){const t=this.options,e=wo({min:this._userMin,max:this._userMax},this);return\"ticks\"===t.bounds&&j(e,this,\"value\"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?\"0\":ne(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=z(t),this._valueRange=z(this.max)-z(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(z(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function So(t){const e=t.ticks;if(e.display&&t.display){const t=ki(e.backdropPadding);return l(e.font&&e.font.size,ue.font.size)+t.height}return 0}function Po(t,e,i,s,n){return t===s||t===n?{start:e-i/2,end:e+i/2}:t<s||t>n?{start:e-i,end:e}:{start:e,end:e+i}}function Do(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},i=Object.assign({},e),s=[],o=[],a=t._pointLabels.length,r=t.options.pointLabels,l=r.centerPointLabels?C/a:0;for(let u=0;u<a;u++){const a=r.setContext(t.getPointLabelContext(u));o[u]=a.padding;const f=t.getPointPosition(u,t.drawingArea+o[u],l),g=Si(a.font),p=(h=t.ctx,c=g,d=n(d=t._pointLabels[u])?d:[d],{w:Oe(h,c.string,d),h:d.length*c.lineHeight});s[u]=p;const m=G(t.getIndexAngle(u)+l),x=Math.round(Y(m));Co(i,e,m,Po(x,f.x,p.w,0,180),Po(x,f.y,p.h,90,270))}var h,c,d;t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=function(t,e,i){const s=[],n=t._pointLabels.length,o=t.options,{centerPointLabels:a,display:r}=o.pointLabels,l={extra:So(o)/2,additionalAngle:a?C/n:0};let h;for(let o=0;o<n;o++){l.padding=i[o],l.size=e[o];const n=Oo(t,o,l);s.push(n),\"auto\"===r&&(n.visible=Ao(n,h),n.visible&&(h=n))}return s}(t,s,o)}function Co(t,e,i,s,n){const o=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));let r=0,l=0;s.start<e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end>e.r&&(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start<e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end>e.b&&(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}function Oo(t,e,i){const s=t.drawingArea,{extra:n,additionalAngle:o,padding:a,size:r}=i,l=t.getPointPosition(e,s+n+a,o),h=Math.round(Y(G(l.angle+E))),c=function(t,e,i){90===i||270===i?t-=e/2:(i>270||i<90)&&(t-=e);return t}(l.y,r.h,h),d=function(t){if(0===t||180===t)return\"center\";if(t<180)return\"left\";return\"right\"}(h),u=function(t,e,i){\"right\"===i?t-=e:\"center\"===i&&(t-=e/2);return t}(l.x,r.w,d);return{visible:!0,x:l.x,y:c,textAlign:d,left:u,top:c,right:u+r.w,bottom:c+r.h}}function Ao(t,e){if(!e)return!0;const{left:i,top:s,right:n,bottom:o}=t;return!(Re({x:i,y:s},e)||Re({x:i,y:o},e)||Re({x:n,y:s},e)||Re({x:n,y:o},e))}function To(t,e,i){const{left:n,top:o,right:a,bottom:r}=i,{backdropColor:l}=e;if(!s(l)){const i=wi(e.borderRadius),s=ki(e.backdropPadding);t.fillStyle=l;const h=n-s.left,c=o-s.top,d=a-n+s.width,u=r-o+s.height;Object.values(i).some((t=>0!==t))?(t.beginPath(),He(t,{x:h,y:c,w:d,h:u,radius:i}),t.fill()):t.fillRect(h,c,d,u)}}function Lo(t,e,i,s){const{ctx:n}=t;if(i)n.arc(t.xCenter,t.yCenter,e,0,O);else{let i=t.getPointPosition(0,e);n.moveTo(i.x,i.y);for(let o=1;o<s;o++)i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}}class Eo extends xo{static id=\"radialLinear\";static defaults={display:!0,animate:!0,position:\"chartArea\",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ae.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}};static defaultRoutes={\"angleLines.color\":\"borderColor\",\"pointLabels.color\":\"color\",\"ticks.color\":\"color\"};static descriptors={angleLines:{_fallback:\"grid\"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=ki(So(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=a(t)&&!isNaN(t)?t:0,this.max=a(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/So(this.options))}generateTickLabels(t){xo.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const i=d(this.options.pointLabels.callback,[t,e],this);return i||0===i?i:\"\"})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?Do(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,s){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}getIndexAngle(t){return G(t*(O/(this._pointLabels.length||1))+$(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(s(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(s(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return function(t,e,i){return Ci(t,{label:i,index:e,type:\"pointLabel\"})}(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const s=this.getIndexAngle(t)-E+i;return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=this._pointLabelItems[t];return{left:e,top:i,right:s,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),Lo(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:s,border:n}=e,o=this._pointLabels.length;let a,r,l;if(e.pointLabels.display&&function(t,e){const{ctx:i,options:{pointLabels:s}}=t;for(let n=e-1;n>=0;n--){const e=t._pointLabelItems[n];if(!e.visible)continue;const o=s.setContext(t.getPointLabelContext(n));To(i,o,e);const a=Si(o.font),{x:r,y:l,textAlign:h}=e;Ne(i,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:\"middle\"})}}(this,o),s.display&&this.ticks.forEach(((t,e)=>{if(0!==e||0===e&&this.min<0){r=this.getDistanceFromCenterForValue(t.value);const i=this.getContext(e),a=s.setContext(i),l=n.setContext(i);!function(t,e,i,s,n){const o=t.ctx,a=e.circular,{color:r,lineWidth:l}=e;!a&&!s||!r||!l||i<0||(o.save(),o.strokeStyle=r,o.lineWidth=l,o.setLineDash(n.dash||[]),o.lineDashOffset=n.dashOffset,o.beginPath(),Lo(t,i,a,s),o.closePath(),o.stroke(),o.restore())}(this,a,r,o,l)}})),i.display){for(t.save(),a=o-1;a>=0;a--){const s=i.setContext(this.getPointLabelContext(a)),{color:n,lineWidth:o}=s;o&&n&&(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(s.borderDash),t.lineDashOffset=s.borderDashOffset,r=this.getDistanceFromCenterForValue(e.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const s=this.getIndexAngle(0);let n,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign=\"center\",t.textBaseline=\"middle\",this.ticks.forEach(((s,a)=>{if(0===a&&this.min>=0&&!e.reverse)return;const r=i.setContext(this.getContext(a)),l=Si(r.font);if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;const e=ki(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}Ne(t,s.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})})),t.restore()}drawTitle(){}}const Ro={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Io=Object.keys(Ro);function zo(t,e){return t-e}function Fo(t,e){if(s(e))return null;const i=t._adapter,{parser:n,round:o,isoWeekday:r}=t._parseOpts;let l=e;return\"function\"==typeof n&&(l=n(l)),a(l)||(l=\"string\"==typeof n?i.parse(l,n):i.parse(l)),null===l?null:(o&&(l=\"week\"!==o||!N(r)&&!0!==r?i.startOf(l,o):i.startOf(l,\"isoWeek\",r)),+l)}function Vo(t,e,i,s){const n=Io.length;for(let o=Io.indexOf(t);o<n-1;++o){const t=Ro[Io[o]],n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((i-e)/(n*t.size))<=s)return Io[o]}return Io[n-1]}function Bo(t,e,i){if(i){if(i.length){const{lo:s,hi:n}=et(i,e);t[i[s]>=e?i[s]:i[n]]=!0}}else t[e]=!0}function Wo(t,e,i){const s=[],n={},o=e.length;let a,r;for(a=0;a<o;++a)r=e[a],n[r]=a,s.push({value:r,major:!1});return 0!==o&&i?function(t,e,i,s){const n=t._adapter,o=+n.startOf(e[0].value,s),a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,s))l=i[r],l>=0&&(e[l].major=!0);return e}(t,s,n,i):s}class No extends Js{static id=\"time\";static defaults={bounds:\"data\",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:\"millisecond\",displayFormats:{}},ticks:{source:\"auto\",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit=\"day\",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const i=t.time||(t.time={}),s=this._adapter=new Rn._date(t.adapters.date);s.init(e),b(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:Fo(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,i=t.time.unit||\"day\";let{min:s,max:n,minDefined:o,maxDefined:r}=this.getUserBounds();function l(t){o||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}o&&r||(l(this._getLabelBounds()),\"ticks\"===t.bounds&&\"labels\"===t.ticks.source||l(this.getMinMax(!1))),s=a(s)&&!isNaN(s)?s:+e.startOf(Date.now(),i),n=a(n)&&!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],i=t[t.length-1]),{min:e,max:i}}buildTicks(){const t=this.options,e=t.time,i=t.ticks,s=\"labels\"===i.source?this.getLabelTimestamps():this._generate();\"ticks\"===t.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const n=this.min,o=nt(s,n,this.max);return this._unit=e.unit||(i.autoSkip?Vo(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):function(t,e,i,s,n){for(let o=Io.length-1;o>=Io.indexOf(i);o--){const i=Io[o];if(Ro[i].common&&t._adapter.diff(n,s,i)>=e-1)return i}return Io[i?Io.indexOf(i):0]}(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&&\"year\"!==this._unit?function(t){for(let e=Io.indexOf(t)+1,i=Io.length;e<i;++e)if(Ro[Io[e]].common)return Io[e]}(this._unit):void 0,this.initOffsets(s),t.reverse&&o.reverse(),Wo(this,o,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,i,s=0,n=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;s=J(s,0,o),n=J(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}_generate(){const t=this._adapter,e=this.min,i=this.max,s=this.options,n=s.time,o=n.unit||Vo(n.minUnit,e,i,this._getLabelCapacity(e)),a=l(s.ticks.stepSize,1),r=\"week\"===o&&n.isoWeekday,h=N(r)||!0===r,c={};let d,u,f=e;if(h&&(f=+t.startOf(f,\"isoWeek\",r)),f=+t.startOf(f,h?\"day\":o),t.diff(i,e,o)>1e5*a)throw new Error(e+\" and \"+i+\" are too far apart with stepSize of \"+a+\" \"+o);const g=\"data\"===s.ticks.source&&this.getDataTimestamps();for(d=f,u=0;d<i;d=+t.add(d,a,o),u++)Bo(c,d,g);return d!==i&&\"ticks\"!==s.bounds&&1!==u||Bo(c,d,g),Object.keys(c).sort(zo).map((t=>+t))}getLabelForValue(t){const e=this._adapter,i=this.options.time;return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}format(t,e){const i=this.options.time.displayFormats,s=this._unit,n=e||i[s];return this._adapter.format(t,n)}_tickFormatFunction(t,e,i,s){const n=this.options,o=n.ticks.callback;if(o)return d(o,[t,e,i],this);const a=n.time.displayFormats,r=this._unit,l=this._majorUnit,h=r&&a[r],c=l&&a[l],u=i[e],f=l&&c&&u&&u.major;return this._adapter.format(t,s||(f?c:h))}generateTickLabels(t){let e,i,s;for(e=0,i=t.length;e<i;++e)s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,i=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+i)*e.factor)}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+i*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,i=this.ctx.measureText(t).width,s=$(this.isHorizontal()?e.maxRotation:e.minRotation),n=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:i*n+a*o,h:i*o+a*n}}_getLabelCapacity(t){const e=this.options.time,i=e.displayFormats,s=i[e.unit]||i.millisecond,n=this._tickFormatFunction(t,0,Wo(this,[t],this._majorUnit),s),o=this._getLabelSize(n),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t,e,i=this._cache.data||[];if(i.length)return i;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,e=s.length;t<e;++t)i=i.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(i)}getLabelTimestamps(){const t=this._cache.labels||[];let e,i;if(t.length)return t;const s=this.getLabels();for(e=0,i=s.length;e<i;++e)t.push(Fo(this,s[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return lt(t.sort(zo))}}function Ho(t,e,i){let s,n,o,a,r=0,l=t.length-1;i?(e>=t[r].pos&&e<=t[l].pos&&({lo:r,hi:l}=it(t,\"pos\",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e>=t[r].time&&e<=t[l].time&&({lo:r,hi:l}=it(t,\"time\",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));const h=n-s;return h?o+(a-o)*(e-s)/h:o}var jo=Object.freeze({__proto__:null,CategoryScale:class extends Js{static id=\"category\";static defaults={ticks:{callback:po}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:i,label:s}of e)t[i]===s&&t.splice(i,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(s(t))return null;const i=this.getLabels();return((t,e)=>null===t?null:J(Math.round(t),0,e))(e=isFinite(e)&&i[e]===t?e:go(i,t,l(e,t),this._addedLabels),i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:s}=this.getMinMax(!0);\"ticks\"===this.options.bounds&&(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,s=[];let n=this.getLabels();n=0===t&&e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let i=t;i<=e;i++)s.push({value:i});return s}getLabelForValue(t){return po.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return\"number\"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}},LinearScale:bo,LogarithmicScale:ko,RadialLinearScale:Eo,TimeScale:No,TimeSeriesScale:class extends No{static id=\"timeseries\";static defaults=No.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Ho(e,this.min),this._tableRange=Ho(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,s=[],n=[];let o,a,r,l,h;for(o=0,a=t.length;o<a;++o)l=t[o],l>=e&&l<=i&&s.push(l);if(s.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=s.length;o<a;++o)h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&&n.push({time:l,pos:o/(a-1)});return n}_generate(){const t=this.min,e=this.max;let i=super.getDataTimestamps();return i.includes(t)&&i.length||i.splice(0,0,t),i.includes(e)&&1!==i.length||i.push(e),i.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return t=e.length&&i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(Ho(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return Ho(this._table,i*this._tableRange+this._minPos,!0)}}});const $o=[\"rgb(54, 162, 235)\",\"rgb(255, 99, 132)\",\"rgb(255, 159, 64)\",\"rgb(255, 205, 86)\",\"rgb(75, 192, 192)\",\"rgb(153, 102, 255)\",\"rgb(201, 203, 207)\"],Yo=$o.map((t=>t.replace(\"rgb(\",\"rgba(\").replace(\")\",\", 0.5)\")));function Uo(t){return $o[t%$o.length]}function Xo(t){return Yo[t%Yo.length]}function qo(t){let e=0;return(i,s)=>{const n=t.getDatasetMeta(s).controller;n instanceof jn?e=function(t,e){return t.backgroundColor=t.data.map((()=>Uo(e++))),e}(i,e):n instanceof $n?e=function(t,e){return t.backgroundColor=t.data.map((()=>Xo(e++))),e}(i,e):n&&(e=function(t,e){return t.borderColor=Uo(e),t.backgroundColor=Xo(e),++e}(i,e))}}function Ko(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return!0;return!1}var Go={id:\"colors\",defaults:{enabled:!0,forceOverride:!1},beforeLayout(t,e,i){if(!i.enabled)return;const{data:{datasets:s},options:n}=t.config,{elements:o}=n,a=Ko(s)||(r=n)&&(r.borderColor||r.backgroundColor)||o&&Ko(o)||\"rgba(0,0,0,0.1)\"!==ue.borderColor||\"rgba(0,0,0,0.1)\"!==ue.backgroundColor;var r;if(!i.forceOverride&&a)return;const l=qo(t);s.forEach(l)}};function Zo(t){if(t._decimated){const e=t._data;delete t._decimated,delete t._data,Object.defineProperty(t,\"data\",{configurable:!0,enumerable:!0,writable:!0,value:e})}}function Jo(t){t.data.datasets.forEach((t=>{Zo(t)}))}var Qo={id:\"decimation\",defaults:{algorithm:\"min-max\",enabled:!1},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled)return void Jo(t);const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e,l=t.getDatasetMeta(o),h=a||e.data;if(\"y\"===Pi([r,t.options.indexAxis]))return;if(!l.controller.supportsDecimation)return;const c=t.scales[l.xAxisID];if(\"linear\"!==c.type&&\"time\"!==c.type)return;if(t.options.parsing)return;let{start:d,count:u}=function(t,e){const i=e.length;let s,n=0;const{iScale:o}=t,{min:a,max:r,minDefined:l,maxDefined:h}=o.getUserBounds();return l&&(n=J(it(e,o.axis,a).lo,0,i-1)),s=h?J(it(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}(l,h);if(u<=(i.threshold||4*n))return void Zo(e);let f;switch(s(a)&&(e._data=h,delete e.data,Object.defineProperty(e,\"data\",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(t){this._data=t}})),i.algorithm){case\"lttb\":f=function(t,e,i,s,n){const o=n.samples||s;if(o>=i)return t.slice(e,e+i);const a=[],r=(i-2)/(o-2);let l=0;const h=e+i-1;let c,d,u,f,g,p=e;for(a[l++]=t[p],c=0;c<o-2;c++){let s,n=0,o=0;const h=Math.floor((c+1)*r)+1+e,m=Math.min(Math.floor((c+2)*r)+1,i)+e,x=m-h;for(s=h;s<m;s++)n+=t[s].x,o+=t[s].y;n/=x,o/=x;const b=Math.floor(c*r)+1+e,_=Math.min(Math.floor((c+1)*r)+1,i)+e,{x:y,y:v}=t[p];for(u=f=-1,s=b;s<_;s++)f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f>u&&(u=f,d=t[s],g=s);a[l++]=d,p=g}return a[l++]=t[h],a}(h,d,u,n,i);break;case\"min-max\":f=function(t,e,i,n){let o,a,r,l,h,c,d,u,f,g,p=0,m=0;const x=[],b=e+i-1,_=t[e].x,y=t[b].x-_;for(o=e;o<e+i;++o){a=t[o],r=(a.x-_)/y*n,l=a.y;const e=0|r;if(e===h)l<f?(f=l,c=o):l>g&&(g=l,d=o),p=(m*p+a.x)/++m;else{const i=o-1;if(!s(c)&&!s(d)){const e=Math.min(c,d),s=Math.max(c,d);e!==u&&e!==i&&x.push({...t[e],x:p}),s!==u&&s!==i&&x.push({...t[s],x:p})}o>0&&i!==u&&x.push(t[i]),x.push(a),h=e,m=0,f=g=l,c=d=u=o}}return x}(h,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){Jo(t)}};function ta(t,e,i,s){if(s)return;let n=e[t],o=i[t];return\"angle\"===t&&(n=G(n),o=G(o)),{property:t,start:n,end:o}}function ea(t,e,i){for(;e>t;e--){const t=i[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function ia(t,e,i,s){return t&&e?s(t[i],e[i]):t?t[i]:e?e[i]:0}function sa(t,e){let i=[],s=!1;return n(t)?(s=!0,i=t):i=function(t,e){const{x:i=null,y:s=null}=t||{},n=e.points,o=[];return e.segments.forEach((({start:t,end:e})=>{e=ea(t,e,n);const a=n[t],r=n[e];null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&&(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))})),o}(t,e),i.length?new no({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}function na(t){return t&&!1!==t.fill}function oa(t,e,i){let s=t[e].fill;const n=[e];let o;if(!i)return s;for(;!1!==s&&-1===n.indexOf(s);){if(!a(s))return s;if(o=t[s],!o)return!1;if(o.visible)return s;n.push(s),s=o.fill}return!1}function aa(t,e,i){const s=function(t){const e=t.options,i=e.fill;let s=l(i&&i.target,i);void 0===s&&(s=!!e.backgroundColor);if(!1===s||null===s)return!1;if(!0===s)return\"origin\";return s}(t);if(o(s))return!isNaN(s.value)&&s;let n=parseFloat(s);return a(n)&&Math.floor(n)===n?function(t,e,i,s){\"-\"!==t&&\"+\"!==t||(i=e+i);if(i===e||i<0||i>=s)return!1;return i}(s[0],e,n,i):[\"origin\",\"start\",\"end\",\"stack\",\"shape\"].indexOf(s)>=0&&s}function ra(t,e,i){const s=[];for(let n=0;n<i.length;n++){const o=i[n],{first:a,last:r,point:l}=la(o,e,\"x\");if(!(!l||a&&r))if(a)s.unshift(l);else if(t.push(l),!r)break}t.push(...s)}function la(t,e,i){const s=t.interpolate(e,i);if(!s)return{};const n=s[i],o=t.segments,a=t.points;let r=!1,l=!1;for(let t=0;t<o.length;t++){const e=o[t],s=a[e.start][i],h=a[e.end][i];if(tt(n,s,h)){r=n===s,l=n===h;break}}return{first:r,last:l,point:s}}class ha{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,i){const{x:s,y:n,radius:o}=this;return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}interpolate(t){const{x:e,y:i,radius:s}=this,n=t.angle;return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}}function ca(t){const{chart:e,fill:i,line:s}=t;if(a(i))return function(t,e){const i=t.getDatasetMeta(e),s=i&&t.isDatasetVisible(e);return s?i.dataset:null}(e,i);if(\"stack\"===i)return function(t){const{scale:e,index:i,line:s}=t,n=[],o=s.segments,a=s.points,r=function(t,e){const i=[],s=t.getMatchingVisibleMetas(\"line\");for(let t=0;t<s.length;t++){const n=s[t];if(n.index===e)break;n.hidden||i.unshift(n.dataset)}return i}(e,i);r.push(sa({x:null,y:e.bottom},s));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)ra(n,a[t],r)}return new no({points:n,options:{}})}(t);if(\"shape\"===i)return!0;const n=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:i}=t,s=e.options,n=e.getLabels().length,a=s.reverse?e.max:e.min,r=function(t,e,i){let s;return s=\"start\"===t?i:\"end\"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue(),s}(i,e,a),l=[];if(s.grid.circular){const t=e.getPointPositionForValue(0,a);return new ha({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}for(let t=0;t<n;++t)l.push(e.getPointPositionForValue(t,r));return l}(t);return function(t){const{scale:e={},fill:i}=t,s=function(t,e){let i=null;return\"start\"===t?i=e.bottom:\"end\"===t?i=e.top:o(t)?i=e.getPixelForValue(t.value):e.getBasePixel&&(i=e.getBasePixel()),i}(i,e);if(a(s)){const t=e.isHorizontal();return{x:t?s:null,y:t?null:s}}return null}(t)}(t);return n instanceof ha?n:sa(n,s)}function da(t,e,i){const s=ca(e),{line:n,scale:o,axis:a}=e,r=n.options,l=r.fill,h=r.backgroundColor,{above:c=h,below:d=h}=l||{};s&&n.points.length&&(Ie(t,i),function(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r}=e,l=i._loop?\"angle\":e.axis;t.save(),\"x\"===l&&o!==n&&(ua(t,s,a.top),fa(t,{line:i,target:s,color:n,scale:r,property:l}),t.restore(),t.save(),ua(t,s,a.bottom));fa(t,{line:i,target:s,color:o,scale:r,property:l}),t.restore()}(t,{line:n,target:s,above:c,below:d,area:i,scale:o,axis:a}),ze(t))}function ua(t,e,i){const{segments:s,points:n}=e;let o=!0,a=!1;t.beginPath();for(const r of s){const{start:s,end:l}=r,h=n[s],c=n[ea(s,l,n)];o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}t.lineTo(e.first().x,i),t.closePath(),t.clip()}function fa(t,e){const{line:i,target:s,property:n,color:o,scale:a}=e,r=function(t,e,i){const s=t.segments,n=t.points,o=e.points,a=[];for(const t of s){let{start:s,end:r}=t;r=ea(s,r,n);const l=ta(i,n[s],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[s],end:n[r]});continue}const h=Ii(e,l);for(const e of h){const s=ta(i,o[e.start],o[e.end],e.loop),r=Ri(t,n,s);for(const t of r)a.push({source:t,target:e,start:{[i]:ia(l,s,\"start\",Math.max)},end:{[i]:ia(l,s,\"end\",Math.min)}})}}return a}(i,s,n);for(const{source:e,target:l,start:h,end:c}of r){const{style:{backgroundColor:r=o}={}}=e,d=!0!==s;t.save(),t.fillStyle=r,ga(t,a,d&&ta(n,h,c)),t.beginPath();const u=!!i.pathSegment(t,e);let f;if(d){u?t.closePath():pa(t,s,c,n);const e=!!s.pathSegment(t,l,{move:u,reverse:!0});f=u&&e,f||pa(t,s,h,n)}t.closePath(),t.fill(f?\"evenodd\":\"nonzero\"),t.restore()}}function ga(t,e,i){const{top:s,bottom:n}=e.chart.chartArea,{property:o,start:a,end:r}=i||{};\"x\"===o&&(t.beginPath(),t.rect(a,s,r-a,n-s),t.clip())}function pa(t,e,i,s){const n=e.interpolate(i,s);n&&t.lineTo(n.x,n.y)}var ma={id:\"filler\",afterDatasetsUpdate(t,e,i){const s=(t.data.datasets||[]).length,n=[];let o,a,r,l;for(a=0;a<s;++a)o=t.getDatasetMeta(a),r=o.dataset,l=null,r&&r.options&&r instanceof no&&(l={visible:t.isDatasetVisible(a),index:a,fill:aa(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);for(a=0;a<s;++a)l=n[a],l&&!1!==l.fill&&(l.fill=oa(n,a,i.propagate))},beforeDraw(t,e,i){const s=\"beforeDraw\"===i.drawTime,n=t.getSortedVisibleDatasetMetas(),o=t.chartArea;for(let e=n.length-1;e>=0;--e){const i=n[e].$filler;i&&(i.line.updateControlPoints(o,i.axis),s&&i.fill&&da(t.ctx,i,o))}},beforeDatasetsDraw(t,e,i){if(\"beforeDatasetsDraw\"!==i.drawTime)return;const s=t.getSortedVisibleDatasetMetas();for(let e=s.length-1;e>=0;--e){const i=s[e].$filler;na(i)&&da(t.ctx,i,t.chartArea)}},beforeDatasetDraw(t,e,i){const s=e.meta.$filler;na(s)&&\"beforeDatasetDraw\"===i.drawTime&&da(t.ctx,s,t.chartArea)},defaults:{propagate:!0,drawTime:\"beforeDatasetDraw\"}};const xa=(t,e)=>{let{boxHeight:i=e,boxWidth:s=e}=t;return t.usePointStyle&&(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}};class ba extends Hs{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=d(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,i)=>t.sort(e,i,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const i=t.labels,s=Si(i.font),n=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:r}=xa(i,n);let l,h;e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,s,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.lineWidths=[0],h=s+a;let c=t;n.textAlign=\"left\",n.textBaseline=\"middle\";let d=-1,u=-h;return this.legendItems.forEach(((t,f)=>{const g=i+e/2+n.measureText(t.text).width;(0===f||l[l.length-1]+g+2*a>o)&&(c+=h,l[l.length-(f>0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a})),c}_fitCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.columnSizes=[],h=o-t;let c=a,d=0,u=0,f=0,g=0;return this.legendItems.forEach(((t,o)=>{const{itemWidth:p,itemHeight:m}=function(t,e,i,s,n){const o=function(t,e,i,s){let n=t.text;n&&\"string\"!=typeof n&&(n=n.reduce(((t,e)=>t.length>e.length?t:e)));return e+i.size/2+s.measureText(n).width}(s,t,e,i),a=function(t,e,i){let s=t;\"string\"!=typeof e.text&&(s=_a(e,i));return s}(n,s,e.lineHeight);return{itemWidth:o,itemHeight:a}}(i,e,n,t,s);o>0&&u+m+2*a>h&&(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:m},d=Math.max(d,p),u+=m+a})),c+=d,l.push({width:d,height:u}),c}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=this,o=Oi(n,this.left,this.width);if(this.isHorizontal()){let n=0,a=ft(i,this.left+s,this.right-this.lineWidths[n]);for(const r of e)n!==r.row&&(n=r.row,a=ft(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}else{let n=0,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height);for(const r of e)r.col!==n&&(n=r.col,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}}isHorizontal(){return\"top\"===this.options.position||\"bottom\"===this.options.position}draw(){if(this.options.display){const t=this.ctx;Ie(t,this),this._draw(),ze(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=this,{align:n,labels:o}=t,a=ue.color,r=Oi(t.rtl,this.left,this.width),h=Si(o.font),{padding:c}=o,d=h.size,u=d/2;let f;this.drawTitle(),s.textAlign=r.textAlign(\"left\"),s.textBaseline=\"middle\",s.lineWidth=.5,s.font=h.string;const{boxWidth:g,boxHeight:p,itemHeight:m}=xa(o,d),x=this.isHorizontal(),b=this._computeTitleHeight();f=x?{x:ft(n,this.left+c,this.right-i[0]),y:this.top+c+b,line:0}:{x:this.left+c,y:ft(n,this.top+b+c,this.bottom-e[0].height),line:0},Ai(this.ctx,t.textDirection);const _=m+c;this.legendItems.forEach(((y,v)=>{s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;const M=s.measureText(y.text).width,w=r.textAlign(y.textAlign||(y.textAlign=o.textAlign)),k=g+u+M;let S=f.x,P=f.y;r.setWidth(this.width),x?v>0&&S+k+c>this.right&&(P=f.y+=_,f.line++,S=f.x=ft(n,this.left+c,this.right-i[f.line])):v>0&&P+_>this.bottom&&(S=f.x=S+e[f.line].width+c,f.line++,P=f.y=ft(n,this.top+b+c,this.bottom-e[f.line].height));if(function(t,e,i){if(isNaN(g)||g<=0||isNaN(p)||p<0)return;s.save();const n=l(i.lineWidth,1);if(s.fillStyle=l(i.fillStyle,a),s.lineCap=l(i.lineCap,\"butt\"),s.lineDashOffset=l(i.lineDashOffset,0),s.lineJoin=l(i.lineJoin,\"miter\"),s.lineWidth=n,s.strokeStyle=l(i.strokeStyle,a),s.setLineDash(l(i.lineDash,[])),o.usePointStyle){const a={radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},l=r.xPlus(t,g/2);Ee(s,a,l,e+u,o.pointStyleWidth&&g)}else{const o=e+Math.max((d-p)/2,0),a=r.leftForLtr(t,g),l=wi(i.borderRadius);s.beginPath(),Object.values(l).some((t=>0!==t))?He(s,{x:a,y:o,w:g,h:p,radius:l}):s.rect(a,o,g,p),s.fill(),0!==n&&s.stroke()}s.restore()}(r.x(S),P,y),S=gt(w,S+g+u,x?S+k:this.right,t.rtl),function(t,e,i){Ne(s,i.text,t,e+m/2,h,{strikethrough:i.hidden,textAlign:r.textAlign(i.textAlign)})}(r.x(S),P,y),x)f.x+=k+c;else if(\"string\"!=typeof y.text){const t=h.lineHeight;f.y+=_a(y,t)+c}else f.y+=_})),Ti(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=Si(e.font),s=ki(e.padding);if(!e.display)return;const n=Oi(t.rtl,this.left,this.width),o=this.ctx,a=e.position,r=i.size/2,l=s.top+r;let h,c=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+l,c=ft(t.align,c,this.right-d);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);h=l+ft(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=ft(a,c,c+d);o.textAlign=n.textAlign(ut(a)),o.textBaseline=\"middle\",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ne(o,e.text,u,h,i)}_computeTitleHeight(){const t=this.options.title,e=Si(t.font),i=ki(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,s,n;if(tt(t,this.left,this.right)&&tt(e,this.top,this.bottom))for(n=this.legendHitBoxes,i=0;i<n.length;++i)if(s=n[i],tt(t,s.left,s.left+s.width)&&tt(e,s.top,s.top+s.height))return this.legendItems[i];return null}handleEvent(t){const e=this.options;if(!function(t,e){if((\"mousemove\"===t||\"mouseout\"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&(\"click\"===t||\"mouseup\"===t))return!0;return!1}(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if(\"mousemove\"===t.type||\"mouseout\"===t.type){const o=this._hoveredItem,a=(n=i,null!==(s=o)&&null!==n&&s.datasetIndex===n.datasetIndex&&s.index===n.index);o&&!a&&d(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&&!a&&d(e.onHover,[t,i,this],this)}else i&&d(e.onClick,[t,i,this],this);var s,n}}function _a(t,e){return e*(t.text?t.text.length:0)}var ya={id:\"legend\",_element:ba,start(t,e,i){const s=t.legend=new ba({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s)},stop(t){as.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,i){const s=t.legend;as.configure(t,s,i),s.options=i},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:\"top\",align:\"center\",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,i){const s=e.datasetIndex,n=i.chart;n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(i?0:void 0),h=ki(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&&(r||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:\"center\",text:\"\"}},descriptors:{_scriptable:t=>!t.startsWith(\"on\"),labels:{_scriptable:t=>![\"generateLabels\",\"filter\",\"sort\"].includes(t)}}};class va extends Hs{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const s=n(i.text)?i.text.length:1;this._padding=ki(i.padding);const o=s*Si(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=o:this.width=o}isHorizontal(){const t=this.options.position;return\"top\"===t||\"bottom\"===t}_drawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=this,a=o.align;let r,l,h,c=0;return this.isHorizontal()?(l=ft(a,i,n),h=e+t,r=n-i):(\"left\"===o.position?(l=i+t,h=ft(a,s,e),c=-.5*C):(l=n-t,h=ft(a,e,s),c=.5*C),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=Si(e.font),s=i.lineHeight/2+this._padding.top,{titleX:n,titleY:o,maxWidth:a,rotation:r}=this._drawArgs(s);Ne(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:ut(e.align),textBaseline:\"middle\",translation:[n,o]})}}var Ma={id:\"title\",_element:va,start(t,e,i){!function(t,e){const i=new va({ctx:t.ctx,options:e,chart:t});as.configure(t,i,e),as.addBox(t,i),t.titleBlock=i}(t,i)},stop(t){const e=t.titleBlock;as.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,i){const s=t.titleBlock;as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"bold\"},fullSize:!0,padding:10,position:\"top\",text:\"\",weight:2e3},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const wa=new WeakMap;var ka={id:\"subtitle\",start(t,e,i){const s=new va({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s),wa.set(t,s)},stop(t){as.removeBox(t,wa.get(t)),wa.delete(t)},beforeUpdate(t,e,i){const s=wa.get(t);as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"normal\"},fullSize:!0,padding:0,position:\"top\",text:\"\",weight:1500},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const Sa={average(t){if(!t.length)return!1;let e,i,s=new Set,n=0,o=0;for(e=0,i=t.length;e<i;++e){const i=t[e].element;if(i&&i.hasValue()){const t=i.tooltipPosition();s.add(t.x),n+=t.y,++o}}if(0===o||0===s.size)return!1;return{x:[...s].reduce(((t,e)=>t+e))/s.size,y:n/o}},nearest(t,e){if(!t.length)return!1;let i,s,n,o=e.x,a=e.y,r=Number.POSITIVE_INFINITY;for(i=0,s=t.length;i<s;++i){const s=t[i].element;if(s&&s.hasValue()){const t=q(e,s.getCenterPoint());t<r&&(r=t,n=s)}}if(n){const t=n.tooltipPosition();o=t.x,a=t.y}return{x:o,y:a}}};function Pa(t,e){return e&&(n(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Da(t){return(\"string\"==typeof t||t instanceof String)&&t.indexOf(\"\\n\")>-1?t.split(\"\\n\"):t}function Ca(t,e){const{element:i,datasetIndex:s,index:n}=e,o=t.getDatasetMeta(s).controller,{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}function Oa(t,e){const i=t.chart.ctx,{body:s,footer:n,title:o}=t,{boxWidth:a,boxHeight:r}=e,l=Si(e.bodyFont),h=Si(e.titleFont),c=Si(e.footerFont),d=o.length,f=n.length,g=s.length,p=ki(e.padding);let m=p.height,x=0,b=s.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(b+=t.beforeBody.length+t.afterBody.length,d&&(m+=d*h.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),b){m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(b-g)*l.lineHeight+(b-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);let _=0;const y=function(t){x=Math.max(x,i.measureText(t).width+_)};return i.save(),i.font=h.string,u(t.title,y),i.font=l.string,u(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,u(s,(t=>{u(t.before,y),u(t.lines,y),u(t.after,y)})),_=0,i.font=c.string,u(t.footer,y),i.restore(),x+=p.width,{width:x,height:m}}function Aa(t,e,i,s){const{x:n,width:o}=i,{width:a,chartArea:{left:r,right:l}}=t;let h=\"center\";return\"center\"===s?h=n<=(r+l)/2?\"left\":\"right\":n<=o/2?h=\"left\":n>=a-o/2&&(h=\"right\"),function(t,e,i,s){const{x:n,width:o}=s,a=i.caretSize+i.caretPadding;return\"left\"===t&&n+o+a>e.width||\"right\"===t&&n-o-a<0||void 0}(h,t,e,i)&&(h=\"center\"),h}function Ta(t,e,i){const s=i.yAlign||e.yAlign||function(t,e){const{y:i,height:s}=e;return i<s/2?\"top\":i>t.height-s/2?\"bottom\":\"center\"}(t,i);return{xAlign:i.xAlign||e.xAlign||Aa(t,e,i,s),yAlign:s}}function La(t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=t,{xAlign:r,yAlign:l}=i,h=n+o,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(a);let g=function(t,e){let{x:i,width:s}=t;return\"right\"===e?i-=s:\"center\"===e&&(i-=s/2),i}(e,r);const p=function(t,e,i){let{y:s,height:n}=t;return\"top\"===e?s+=i:s-=\"bottom\"===e?n+i:n/2,s}(e,l,h);return\"center\"===l?\"left\"===r?g+=h:\"right\"===r&&(g-=h):\"left\"===r?g-=Math.max(c,u)+n:\"right\"===r&&(g+=Math.max(d,f)+n),{x:J(g,0,s.width-e.width),y:J(p,0,s.height-e.height)}}function Ea(t,e,i){const s=ki(i.padding);return\"center\"===e?t.x+t.width/2:\"right\"===e?t.x+t.width-s.right:t.x+s.left}function Ra(t){return Pa([],Da(t))}function Ia(t,e){const i=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return i?t.override(i):t}const za={beforeTitle:e,title(t){if(t.length>0){const e=t[0],i=e.chart.data.labels,s=i?i.length:0;if(this&&this.options&&\"dataset\"===this.options.mode)return e.dataset.label||\"\";if(e.label)return e.label;if(s>0&&e.dataIndex<s)return i[e.dataIndex]}return\"\"},afterTitle:e,beforeBody:e,beforeLabel:e,label(t){if(this&&this.options&&\"dataset\"===this.options.mode)return t.label+\": \"+t.formattedValue||t.formattedValue;let e=t.dataset.label||\"\";e&&(e+=\": \");const i=t.formattedValue;return s(i)||(e+=i),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:e,afterBody:e,beforeFooter:e,footer:e,afterFooter:e};function Fa(t,e,i,s){const n=t[e].call(i,s);return void 0===n?za[e].call(i,s):n}class Va extends Hs{static positioners=Sa;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,i=this.options.setContext(this.getContext()),s=i.enabled&&e.options.animation&&i.animations,n=new Os(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(n)),n}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ci(t,{tooltip:e,tooltipItems:i,type:\"tooltip\"})));var t,e,i}getTitle(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeTitle\",this,t),n=Fa(i,\"title\",this,t),o=Fa(i,\"afterTitle\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}getBeforeBody(t,e){return Ra(Fa(e.callbacks,\"beforeBody\",this,t))}getBody(t,e){const{callbacks:i}=e,s=[];return u(t,(t=>{const e={before:[],lines:[],after:[]},n=Ia(i,t);Pa(e.before,Da(Fa(n,\"beforeLabel\",this,t))),Pa(e.lines,Fa(n,\"label\",this,t)),Pa(e.after,Da(Fa(n,\"afterLabel\",this,t))),s.push(e)})),s}getAfterBody(t,e){return Ra(Fa(e.callbacks,\"afterBody\",this,t))}getFooter(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeFooter\",this,t),n=Fa(i,\"footer\",this,t),o=Fa(i,\"afterFooter\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}_createItems(t){const e=this._active,i=this.chart.data,s=[],n=[],o=[];let a,r,l=[];for(a=0,r=e.length;a<r;++a)l.push(Ca(this.chart,e[a]));return t.filter&&(l=l.filter(((e,s,n)=>t.filter(e,s,n,i)))),t.itemSort&&(l=l.sort(((e,s)=>t.itemSort(e,s,i)))),u(l,(e=>{const i=Ia(t.callbacks,e);s.push(Fa(i,\"labelColor\",this,e)),n.push(Fa(i,\"labelPointStyle\",this,e)),o.push(Fa(i,\"labelTextColor\",this,e))})),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}update(t,e){const i=this.options.setContext(this.getContext()),s=this._active;let n,o=[];if(s.length){const t=Sa[i.position].call(this,s,this._eventPosition);o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);const e=this._size=Oa(this,i),a=Object.assign({},t,e),r=Ta(this.chart,i,a),l=La(i,a,r,this.chart);this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(n={opacity:0});this._tooltipItems=o,this.$context=void 0,n&&this._resolveAnimations().update(this,n),t&&i.external&&i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,i,s){const n=this.getCaretPosition(t,i,s);e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=this,{caretSize:o,cornerRadius:a}=i,{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=wi(a),{x:d,y:u}=t,{width:f,height:g}=e;let p,m,x,b,_,y;return\"center\"===n?(_=u+g/2,\"left\"===s?(p=d,m=p-o,b=_+o,y=_-o):(p=d+f,m=p+o,b=_-o,y=_+o),x=p):(m=\"left\"===s?d+Math.max(r,h)+o:\"right\"===s?d+f-Math.max(l,c)-o:this.caretX,\"top\"===n?(b=u,_=b-o,p=m-o,x=m+o):(b=u+g,_=b+o,p=m+o,x=m-o),y=b),{x1:p,x2:m,x3:x,y1:b,y2:_,y3:y}}drawTitle(t,e,i){const s=this.title,n=s.length;let o,a,r;if(n){const l=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline=\"middle\",o=Si(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r<n;++r)e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&&(t.y+=i.titleMarginBottom-a)}}_drawColorBox(t,e,i,s,n){const a=this.labelColors[i],r=this.labelPointStyles[i],{boxHeight:l,boxWidth:h}=n,c=Si(n.bodyFont),d=Ea(this,\"left\",n),u=s.x(d),f=l<c.lineHeight?(c.lineHeight-l)/2:0,g=e.y+f;if(n.usePointStyle){const e={radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},i=s.leftForLtr(u,h)+h/2,o=g+l/2;t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,Le(t,e,i,o),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Le(t,e,i,o)}else{t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const e=s.leftForLtr(u,h),i=s.leftForLtr(s.xPlus(u,1),h-2),r=wi(a.borderRadius);Object.values(r).some((t=>0!==t))?(t.beginPath(),t.fillStyle=n.multiKeyBackground,He(t,{x:e,y:g,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),He(t,{x:i,y:g+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,g,h,l),t.strokeRect(e,g,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,g+1,h-2,l-2))}t.fillStyle=this.labelTextColors[i]}drawBody(t,e,i){const{body:s}=this,{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=i,c=Si(i.bodyFont);let d=c.lineHeight,f=0;const g=Oi(i.rtl,this.x,this.width),p=function(i){e.fillText(i,g.x(t.x+f),t.y+d/2),t.y+=d+n},m=g.textAlign(o);let x,b,_,y,v,M,w;for(e.textAlign=o,e.textBaseline=\"middle\",e.font=c.string,t.x=Ea(this,m,i),e.fillStyle=i.bodyColor,u(this.beforeBody,p),f=a&&\"right\"!==m?\"center\"===o?l/2+h:l+2+h:0,y=0,M=s.length;y<M;++y){for(x=s[y],b=this.labelTextColors[y],e.fillStyle=b,u(x.before,p),_=x.lines,a&&_.length&&(this._drawColorBox(e,t,y,g,i),d=Math.max(c.lineHeight,r)),v=0,w=_.length;v<w;++v)p(_[v]),d=c.lineHeight;u(x.after,p)}f=0,d=c.lineHeight,u(this.afterBody,p),t.y-=n}drawFooter(t,e,i){const s=this.footer,n=s.length;let o,a;if(n){const r=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline=\"middle\",o=Si(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a<n;++a)e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}}drawBackground(t,e,i,s){const{xAlign:n,yAlign:o}=this,{x:a,y:r}=t,{width:l,height:h}=i,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(s.cornerRadius);e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),\"top\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),\"center\"===o&&\"right\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),\"bottom\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),\"center\"===o&&\"left\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,i=this.$animations,s=i&&i.x,n=i&&i.y;if(s||n){const i=Sa[t.position].call(this,this._active,this._eventPosition);if(!i)return;const o=this._size=Oa(this,t),a=Object.assign({},i,this._size),r=Ta(e,t,a),l=La(t,a,r,e);s._to===l.x&&n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let i=this.opacity;if(!i)return;this._updateAnimationTarget(e);const s={width:this.width,height:this.height},n={x:this.x,y:this.y};i=Math.abs(i)<.001?0:i;const o=ki(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),Ai(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),Ti(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const i=this._active,s=t.map((({datasetIndex:t,index:e})=>{const i=this.chart.getDatasetMeta(t);if(!i)throw new Error(\"Cannot find a dataset at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}})),n=!f(i,s),o=this._positionChanged(s,e);(n||o)&&(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,i=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,n=this._active||[],o=this._getActiveElements(t,n,e,i),a=this._positionChanged(o,t),r=e||!f(o,n)||a;return r&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}_getActiveElements(t,e,i,s){const n=this.options;if(\"mouseout\"===t.type)return[];if(!s)return e.filter((t=>this.chart.data.datasets[t.datasetIndex]&&void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));const o=this.chart.getElementsAtEventForMode(t,n.mode,n,i);return n.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:i,caretY:s,options:n}=this,o=Sa[n.position].call(this,t,e);return!1!==o&&(i!==o.x||s!==o.y)}}var Ba={id:\"tooltip\",_element:Va,positioners:Sa,afterInit(t,e,i){i&&(t.tooltip=new Va({chart:t,options:i}))},beforeUpdate(t,e,i){t.tooltip&&t.tooltip.initialize(i)},reset(t,e,i){t.tooltip&&t.tooltip.initialize(i)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const i={tooltip:e};if(!1===t.notifyPlugins(\"beforeTooltipDraw\",{...i,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins(\"afterTooltipDraw\",i)}},afterEvent(t,e){if(t.tooltip){const i=e.replay;t.tooltip.handleEvent(e.event,i,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:\"average\",backgroundColor:\"rgba(0,0,0,0.8)\",titleColor:\"#fff\",titleFont:{weight:\"bold\"},titleSpacing:2,titleMarginBottom:6,titleAlign:\"left\",bodyColor:\"#fff\",bodySpacing:2,bodyFont:{},bodyAlign:\"left\",footerColor:\"#fff\",footerSpacing:2,footerMarginTop:6,footerFont:{weight:\"bold\"},footerAlign:\"left\",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:\"#fff\",displayColors:!0,boxPadding:0,borderColor:\"rgba(0,0,0,0)\",borderWidth:0,animation:{duration:400,easing:\"easeOutQuart\"},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"width\",\"height\",\"caretX\",\"caretY\"]},opacity:{easing:\"linear\",duration:200}},callbacks:za},defaultRoutes:{bodyFont:\"font\",footerFont:\"font\",titleFont:\"font\"},descriptors:{_scriptable:t=>\"filter\"!==t&&\"itemSort\"!==t&&\"external\"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:\"animation\"}},additionalOptionScopes:[\"interaction\"]};return An.register(Yn,jo,fo,t),An.helpers={...Wi},An._adapters=Rn,An.Animation=Cs,An.Animations=Os,An.animator=bt,An.controllers=en.controllers.items,An.DatasetController=Ns,An.Element=Hs,An.elements=fo,An.Interaction=Xi,An.layouts=as,An.platforms=Ss,An.Scale=Js,An.Ticks=ae,Object.assign(An,Yn,jo,fo,t,Ss),An.Chart=An,\"undefined\"!=typeof window&&(window.Chart=An),An}));\n//# sourceMappingURL=chart.umd.js.map\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */\nfunction isNonPrimitive(n: unknown) {\n  return typeof n === 'symbol' || (typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n));\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\nimport {isNullOrUndef} from './helpers.core.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, vScale, _parsed} = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n      if (spanGaps) {\n        const distanceToDefinedLo = (_parsed\n          .slice(0, start + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n      if (spanGaps) {\n        const distanceToDefinedHi = (_parsed\n          .slice(end - 1)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type PrivateChart from '../core/core.controller.js';\nimport type {Chart, ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart | PrivateChart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart | PrivateChart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  (chart as PrivateChart).height = Math.floor(chart.height);\n  (chart as PrivateChart).width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    (chart as PrivateChart).currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea, isNullOrUndef} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {vScale} = controller._cachedMeta;\n        const {_parsed} = metaset;\n\n        const distanceToDefinedLo = (_parsed\n          .slice(0, result.lo + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n\n        const distanceToDefinedHi = (_parsed\n          .slice(result.hi)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta, chartArea) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<TimeUnit | 'datetime', string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: string): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: string): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number | boolean): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options?: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<TimeUnit | 'datetime', string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase as {\n    new (options?: AnyObject): DateAdapter;\n    override<T extends AnyObject = AnyObject>(\n      members: Partial<Omit<DateAdapter<T>, 'options'>>\n    ): void;\n  }\n};\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, 𝜃) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","import {DoughnutController, PolarAreaController, defaults} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nfunction containsDefaultColorsDefenitions() {\n  return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    const containsColorDefenition = (\n      containsColorsDefinitions(datasets) ||\n      containsColorsDefinition(chartOptions) ||\n      (elements && containsColorsDefinitions(elements)) ||\n      containsDefaultColorsDefenitions());\n\n    if (!options.forceOverride && containsColorDefenition) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of an segment -> need to add another point before this,\n      // from next line below.\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of an segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n/**\n * @namespace Chart\n */\nimport Chart from './core/core.controller.js';\n\nimport * as helpers from './helpers/index.js';\nimport _adapters from './core/core.adapters.js';\nimport Animation from './core/core.animation.js';\nimport animator from './core/core.animator.js';\nimport Animations from './core/core.animations.js';\nimport * as controllers from './controllers/index.js';\nimport DatasetController from './core/core.datasetController.js';\nimport Element from './core/core.element.js';\nimport * as elements from './elements/index.js';\nimport Interaction from './core/core.interaction.js';\nimport layouts from './core/core.layouts.js';\nimport * as platforms from './platform/index.js';\nimport * as plugins from './plugins/index.js';\nimport registry from './core/core.registry.js';\nimport Scale from './core/core.scale.js';\nimport * as scales from './scales/index.js';\nimport Ticks from './core/core.ticks.js';\n\n// Register built-ins\nChart.register(controllers, scales, elements, plugins);\n\nChart.helpers = {...helpers};\nChart._adapters = _adapters;\nChart.Animation = Animation;\nChart.Animations = Animations;\nChart.animator = animator;\nChart.controllers = registry.controllers.items;\nChart.DatasetController = DatasetController;\nChart.Element = Element;\nChart.elements = elements;\nChart.Interaction = Interaction;\nChart.layouts = layouts;\nChart.platforms = platforms;\nChart.Scale = Scale;\nChart.Ticks = Ticks;\n\n// Compatibility with ESM extensions\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\nChart.Chart = Chart;\n\nif (typeof window !== 'undefined') {\n  window.Chart = Chart;\n}\n\nexport default Chart;\n\n"],"names":["t","e","exports","module","define","amd","globalThis","self","Chart","Ht","Object","freeze","__proto__","Colors","Go","Decimation","Qo","Filler","ma","Legend","ya","SubTitle","ka","Title","Ma","Tooltip","Ba","i","s","n","Array","isArray","prototype","toString","call","slice","o","a","Number","isFinite","r","l","h","endsWith","parseFloat","c","d","apply","u","length","keys","f","datasetIndex","index","g","map","create","p","indexOf","m","x","merger","b","_","hasOwnProperty","y","v","split","push","M","w","charAt","toUpperCase","k","S","P","size","has","D","type","C","Math","PI","O","A","T","POSITIVE_INFINITY","L","E","R","I","z","log10","F","sign","V","abs","B","round","pow","floor","W","sqrt","sort","pop","N","Symbol","toPrimitive","isNaN","H","j","min","max","$","Y","U","X","atan2","angle","distance","q","K","G","Z","J","Q","tt","et","lo","hi","it","st","nt","ot","at","_chartjs","listeners","defineProperty","configurable","enumerable","value","forEach","rt","splice","lt","Set","from","ht","window","requestAnimationFrame","ct","dt","clearTimeout","setTimeout","ut","ft","gt","pt","_sorted","iScale","vScale","_parsed","dataset","options","spanGaps","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","reverse","findIndex","start","count","mt","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","assign","bt","constructor","_request","_charts","Map","_running","_lastDate","_notify","duration","chart","initial","numSteps","currentStep","_refresh","_update","Date","now","running","items","_active","_total","tick","draw","_getAnims","get","complete","progress","set","listen","add","reduce","_duration","stop","cancel","remove","delete","_t","yt","vt","Mt","wt","kt","St","Pt","Dt","Ct","Ot","Tt","Lt","Et","Rt","It","zt","Vt","Wt","Nt","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","$t","Yt","Ut","Xt","qt","Kt","Zt","jt","replace","parseInt","transparent","toLowerCase","exec","Bt","_rgb","_valid","valid","rgb","rgbString","hexString","hslString","mix","interpolate","clone","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","Jt","Qt","te","ee","ie","se","ne","JSON","stringify","Intl","NumberFormat","format","oe","values","numeric","locale","notation","minimumFractionDigits","maximumFractionDigits","ticks","logarithmic","includes","significand","ae","formatters","re","le","he","ce","ue","animation","backgroundColor","borderColor","color","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","defineProperties","writable","_scriptable","startsWith","_indexable","_fallback","delay","easing","fn","loop","to","colors","properties","numbers","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","callback","minor","major","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","fe","document","ge","parentNode","host","pe","me","ownerDocument","defaultView","getComputedStyle","xe","getPropertyValue","be","_e","height","ye","shadowRoot","ve","canvas","currentDevicePixelRatio","boxSizing","box","touches","offsetX","offsetY","target","getBoundingClientRect","clientX","clientY","Me","we","maxWidth","maxHeight","clientWidth","clientHeight","ke","ctx","setTransform","Se","passive","addEventListener","removeEventListener","Pe","match","De","Ce","measureText","Oe","data","garbageCollect","save","restore","Ae","Te","getContext","resetTransform","clearRect","Le","Ee","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","Re","Ie","ze","Fe","Ve","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Ne","strokeWidth","strokeColor","string","translation","fillStyle","textAlign","textBaseline","backdrop","We","fillRect","strokeStyle","strokeText","fillText","Be","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","He","topLeft","bottomLeft","bottomRight","topRight","je","ti","Proxy","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","deleteProperty","_keys","qe","Ue","Je","getOwnPropertyDescriptor","Reflect","getPrototypeOf","ei","ownKeys","_storage","$e","_proxy","_context","_subProxy","_stack","_descriptors","Ye","setContext","isScriptable","Error","join","filter","isIndexable","allKeys","scriptable","indexable","_allKeys","Ge","Ze","ii","key","_parsing","parse","si","EPSILON","ni","skip","oi","ai","previous","next","ri","li","cubicInterpolationMode","tension","capBezierPoints","ci","di","ui","fi","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","gi","pi","mi","xi","bi","_i","yi","vi","Mi","wi","ki","Si","console","warn","Pi","cacheable","Di","Ci","Oi","setWidth","xPlus","leftForLtr","Ai","getPropertyPriority","setProperty","prevTextDirection","Ti","Li","between","compare","normalize","Ei","end","Ri","property","Ii","segments","points","zi","_loop","Fi","_fullLoop","_chart","Vi","_datasetIndex","Bi","p0","p1","p0DataIndex","p1DataIndex","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Wi","HALF_PI","INFINITY","PITAU","QUARTER_PI","RAD_PER_DEG","TAU","TWO_THIRDS_PI","_addGrace","_alignPixel","_alignStartEnd","_angleBetween","_angleDiff","_arrayUnique","_attachContext","_bezierCurveTo","_bezierInterpolation","_boundSegment","_boundSegments","_capitalize","_computeSegments","_createResolver","_decimalPlaces","_deprecated","_elementsEqual","_factorize","_filterBetween","_getParentNode","_getStartAndCountOfVisiblePoints","_int16Range","_isBetween","_isClickEvent","_isDomSupported","_isPointInArea","_limitValue","_longestText","_lookup","_lookupByKey","_measureText","_merger","_mergerIf","_normalizeAngle","_parseObjectDataRadialScale","_pointInLine","_readValueToProps","_rlookupByKey","_scaleRangesChanged","_setMinAndMaxByKey","_splitKey","_steppedInterpolation","_steppedLineTo","_textX","_toLeftRightCenter","_updateBezierControlPoints","addRoundedRectPath","almostEquals","almostWhole","clearCanvas","clipArea","createContext","debounce","defined","distanceBetweenPoints","drawPoint","drawPointLegend","each","easingEffects","finiteOrDefault","fontString","formatNumber","getAngleFromPoint","getHoverColor","getMaximumSize","getRelativePosition","getRtlAdapter","getStyle","isFunction","isNullOrUndef","isNumber","isObject","isPatternOrGradient","listenArrayEvents","merge","mergeIf","niceNum","noop","overrideTextDirection","readUsedSize","renderText","requestAnimFrame","resolve","resolveObjectKey","restoreTextDirection","retinaScale","setsEqual","splineCurve","splineCurveMonotone","supportsEventListenerOptions","throttled","toDegrees","toDimension","toFont","toFontString","toLineHeight","toPadding","toPercentage","toRadians","toTRBL","toTRBLCorners","uid","unclipArea","unlistenArrayEvents","valueOrDefault","Hi","getSortedVisibleDatasetMetas","Ni","controller","_cachedMeta","_reversePixels","_sharedOptions","getRange","ji","isPointInArea","chartArea","inRange","element","Yi","$i","getCenterPoint","startAngle","endAngle","getProps","Ui","Xi","evaluateInteractionItems","modes","getDatasetMeta","point","nearest","qi","Ki","pos","Gi","Zi","Qi","ts","ss","update","is","maxPadding","horizontal","same","other","es","stack","getPadding","outerWidth","outerHeight","fullSize","ns","os","placed","stackWeight","as","addBox","boxes","position","_layers","removeBox","configure","layout","isHorizontal","leftAndTop","concat","rightAndBottom","vertical","beforeLayout","availableWidth","availableHeight","vBoxMaxWidth","hBoxMaxHeight","Ji","rs","acquireContext","releaseContext","isAttached","updateConfig","ls","hs","cs","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","ds","us","gs","contains","ps","MutationObserver","addedNodes","removedNodes","observe","childList","subtree","ms","xs","bs","_s","ys","ResizeObserver","contentRect","vs","disconnect","Ms","native","ws","getAttribute","removeAttribute","setAttribute","$proxies","attach","detach","isConnected","ks","OffscreenCanvas","Ss","BasePlatform","BasicPlatform","DomPlatform","_detectPlatform","Ps","Ds","boolean","number","Cs","_fn","_easing","_start","_target","_prop","_from","_to","_promises","wait","Promise","res","rej","Os","_properties","getOwnPropertyNames","_animateOptions","$shared","$animations","_createAnimations","all","then","As","Ts","_getSortedDatasetMetas","Ls","Es","stacked","Is","getMatchingVisibleMetas","zs","_stacks","id","Rs","_top","_bottom","_visualValues","Fs","shift","Vs","Bs","Ws","Ns","defaults","datasetElementType","dataElementType","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","_getOtherScale","reset","_destroy","_dataCheck","isExtensible","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","xAxisKey","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","hidden","NEGATIVE_INFINITY","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","parsed","raw","_resolveElementOptions","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_insertElements","_removeElements","updateElements","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","Hs","defaultRoutes","tooltipPosition","hasValue","$s","ceil","Ys","Us","Xs","Ks","Gs","Js","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_length","_maxLength","_longestTextCache","_startPixel","_endPixel","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","getTicks","labels","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","js","_tickSize","maxTicksLimit","enabled","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","first","last","_calculatePadding","_handleMargins","getPixelForTick","isFullSize","_computeLabelSizes","_resolveTickFontOptions","gc","widths","heights","getValueForPixel","getPixelForDecimal","getDecimalForPixel","getBasePixel","getBaseValue","_computeGridLineItems","tickBorderDash","tickBorderDashOffset","qs","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_getXAxisLabelAlignment","_getYAxisLabelAlignment","textOffset","_computeLabelArea","drawBackground","getLineWidthForValue","drawGrid","setLineDash","lineDashOffset","drawBorder","drawLabels","drawTitle","titleX","titleY","_maxDigits","Qs","scope","isForType","isPrototypeOf","register","descriptors","overrides","unregister","en","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","_getRegistryForType","_exec","sn","_init","notify","_createDescriptors","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","on","local","pluginScopeKeys","some","an","rn","ln","hn","dn","cn","error","un","gn","pn","mn","xn","_config","_scopeCache","_resolverCache","clearCache","clear","additionalOptionScopes","_cachedScopes","chartOptionScopes","resolver","subPrefixes","bn","_n","yn","vn","Mn","wn","onComplete","kn","onProgress","Sn","getElementById","Pn","Dn","On","An","instances","registry","version","getChart","Tn","aspectRatio","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","order","isDatasetVisible","_resetElements","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","method","_getUniformDataChanges","Cn","_idx","_updateDataset","meta","_drawDatasets","_drawDataset","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","updateHoverStyle","getActiveElements","setActiveElements","event","replay","inChartArea","_handleEvent","changed","_getActiveElements","Ln","En","formats","diff","startOf","endOf","Rn","_date","zn","_custom","barStart","barEnd","Fn","Vn","Wn","Nn","jn","animateRotate","animateScale","cutout","circumference","spacing","legend","generateLabels","fontColor","innerRadius","outerRadius","_getRotation","_getCircumference","_getRotationExtents","getMaxBorderWidth","getMaxOffset","_getRingWeight","ratioX","ratioY","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","borderAlign","hoverBorderWidth","hoverOffset","$n","angleLines","circular","pointLabels","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","Yn","BarController","categoryPercentage","barPercentage","grouped","_index_","_value_","_getRuler","base","head","_calculateBarValuePixels","_calculateBarIndexPixels","enableBorderRadius","center","Bn","borderSkipped","Hn","inflateAmount","ratio","_getStacks","find","_getStackCount","_getStackIndex","barThickness","In","$bar","pixels","stackCount","minBarLength","skipNull","maxBarThickness","chunk","BubbleController","DoughnutController","LineController","_decimated","segment","animated","updateControlPoints","PieController","PolarAreaController","RadarController","line","getPointPositionForValue","ScatterController","Xn","qn","pixelMargin","outerStart","outerEnd","innerStart","innerEnd","Un","borderRadius","Gn","lineCap","lineJoin","Zn","Jn","ilen","Qn","stepped","move","eo","io","Path2D","no","_path","_points","_segments","_pointsUpdated","pathSegment","path","oo","hitRadius","ao","ro","ho","co","uo","fo","ArcElement","fullCircles","Kn","BarElement","inner","outer","inXRange","inYRange","LineElement","PointElement","hoverRadius","po","mo","xo","_startValue","_endValue","_valueRange","handleTickRangeOptions","getTickLimit","stepSize","computeTickLimit","step","precision","maxTicks","maxDigits","includeBounds","bo","_o","yo","vo","Mo","ko","_zero","wo","So","Po","Lo","getPointPosition","Eo","animate","centerPointLabels","drawingArea","_pointLabels","_pointLabelItems","_padding","Do","getPointLabelContext","Co","setCenterPoint","extra","additionalAngle","Oo","Ao","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","To","Ro","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","Io","zo","Fo","_adapter","parser","isoWeekday","_parseOpts","Vo","MAX_SAFE_INTEGER","Bo","Wo","No","adapters","time","unit","minUnit","displayFormats","_unit","_majorUnit","_offsets","_normalized","date","normalized","_getLabelBounds","getLabelTimestamps","_generate","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","Ho","jo","CategoryScale","_addedLabels","go","unshift","lastIndexOf","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","$o","Yo","Uo","Xo","Ko","forceOverride","Zo","Jo","algorithm","beforeElementsUpdate","threshold","samples","ta","ea","ia","sa","na","ha","da","ca","ra","la","above","below","area","ua","fa","ga","pa","afterDatasetsUpdate","aa","$filler","oa","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","xa","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","ba","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_computeTitleHeight","_fitRows","_fitCols","row","itemWidth","_a","col","adjustHitBoxes","rtl","_draw","textDirection","lineDash","SQRT2","_getLegendItemAt","handleEvent","onLeave","_element","afterEvent","useBorderRadius","va","_drawArgs","titleBlock","wa","WeakMap","Sa","average","Pa","Da","String","Oa","body","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","Ta","yAlign","xAlign","Aa","caretSize","caretPadding","La","cornerRadius","Ea","Ia","tooltip","callbacks","za","beforeTitle","afterTitle","beforeLabel","formattedValue","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","Fa","Va","positioners","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","_createItems","Ca","itemSort","external","drawCaret","getCaretPosition","x3","y3","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","drawFooter","footerAlign","footerColor","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_positionChanged","_ignoreReplayEvents","afterInit","afterDraw","helpers","_adapters","Animation","Animations","animator","DatasetController","Element","Interaction","layouts","platforms","Scale","Ticks","isNumberFinite","defaultValue","dimension","args","thisArg","loopable","len","a0","a1","v0","v1","klen","isValidKey","tval","sval","sources","current","keyResolvers","parts","tmp","part","obj","_getKeyResolver","str","item","epsilon","range","roundedRange","niceRange","fraction","result","isNonPrimitive","rounded","array","degrees","radians","isFiniteNumber","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","pt1","pt2","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","table","cmp","mid","arrayEvents","listener","this","object","stub","argsToUse","ticking","timeout","animationsDisabled","pointCount","distanceToDefinedLo","distanceToDefinedHi","newRanges","Animator","undefined","anims","remaining","charts","cb","acc","cur","lim","p2b","n2b","b2n","n2p","map$1","hex","h1","h2","eq","isShort","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","p2","hwb2rgb","hsv2rgb","names$1","names","nameParse","unpacked","tkeys","ok","nk","unpack","RGB_RE","modHSL","proto","fromObject","input","functionParse","rgbParse","Color","ret","c1","c2","w2","w1","rgb1","rgb2","val","deg","intlCache","num","cacheKey","formatter","getNumberFormat","tickValue","delta","maxTick","calculateDelta","logDelta","numDecimal","remain","getScope","node","root","Defaults","_appliers","context","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","appliers","domNode","parent","parseMaxStyle","styleValue","parentProperty","valueInPixels","el","positions","getPositionedStyle","styles","suffix","useOffsetPos","borderBox","paddings","borders","getCanvasPosition","xOffset","yOffset","round1","bbWidth","bbHeight","margins","containerSize","container","containerStyle","containerBorder","containerPadding","getContainerSize","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","passiveSupported","matches","longest","textWidth","arrayOfThings","cache","jlen","thing","nestedThing","gcLen","pixel","halfWidth","xOffsetW","yOffsetW","rad","margin","flip","midpoint","decorateText","opts","metrics","yDecoration","drawBackdrop","oldColor","setRenderOpts","scopes","prefixes","rootScopes","fallback","getTarget","finalRootScopes","_resolve","prop","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getKeysFromAllScopes","storage","subProxy","descriptorDefaults","receiver","getValue","_resolveScriptable","arr","_resolveArray","_resolveWithContext","resolveFallback","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","getPoint","getValueAxis","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fb","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","controlPoints","prev","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","cp1","cp2","LINE_HEIGHT","FONT_STYLE","numberOrZero","props","objProps","read","inputs","info","minmax","change","keepZero","parentContext","rectX","getRightToLeftAdapter","_itemWidth","direction","original","propertyFn","normalizeSegment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","sub","segmentOptions","findStartAndEnd","splitByStyles","solidSegments","chartContext","baseStyle","readStyle","prevStyle","addStyle","dir","styleChanged","doSplitByStyles","replacer","pixelSize","fontStyle","fontFamily","binarySearch","metaset","lookupMethod","handler","metasets","getIntersectItems","useFinalPosition","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","params","stacks","wrap","buildStacks","getCombinedMax","updateMaxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","visibleVerticalBoxCount","updatePos","handleMaxPadding","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","createAttachObserver","observer","entries","trigger","entry","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","listenDevicePixelRatioChanges","releaseObserver","unlistenDevicePixelRatioChanges","createProxyAndListen","fromNativeEvent","addListener","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","proxies","interpolators","c0","helpersColor","cfg","currentValue","elapsed","promises","resolved","animationOptions","animatedProps","option","newOptions","resolveTargetOptions","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","dsIndex","singleMode","otherValue","found","isStacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","positive","updateStacks","iAxis","vAxis","indexScale","valueScale","getStackKey","getFirstScaleId","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","static","chooseId","xid","yid","rid","iid","vid","scaleID","iAxisKey","vAxisKey","adata","convertObjectDataToArray","resetNewElements","stackChanged","oldStacked","scopeKeys","sorted","isNotInOrderComparedToPrev","singleScale","parsedValue","canStack","otherScale","createStack","otherMin","otherMax","_skip","toClip","defaultClip","createDataContext","createDatasetContext","elementType","sharing","transition","firstOpts","previouslySharedOptions","arg1","arg2","numMeta","numData","removed","newCount","final","tickOpts","determinedMaxTicks","maxScale","maxChart","determineMaxTicks","ticksLimit","majorIndices","getMajorIndices","numMajorIndices","newTicks","skipMajors","evenMajorSpacing","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","edge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","reverseAlign","super","metas","samplingEnabled","startPixel","endPixel","reversePixels","numTicks","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetLeft","offsetRight","caches","tickFont","nestedLabel","widestLabelSize","highestLabelSize","valueAt","idx","decimal","createTickContext","optionTicks","rot","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","positionAxisID","limit","optsAtIndex","optsAtIndexBorder","lineColor","tickAndPadding","hTickAndPadding","lineCount","halfCount","tickTextAlign","labelPadding","drawLine","lastLineWidth","renderTextOptions","titleArgs","tz","gz","bz","axisID","fontSize","TypedRegistry","parentScope","isIChartComponent","itemDefaults","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","Registry","typedRegistry","arg","reg","itemReg","component","camelMethod","PluginService","hook","descriptor","callCallback","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","initConfig","datasetType","mainScope","resetCache","keyLists","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","moveNumericKeys","intKey","getSizeForArea","field","invalidatePlugins","userConfig","initialCanvas","existingChart","newSize","newRatio","axisOptions","scaleOpts","updated","isRadial","scaleType","hasUpdated","newControllers","ControllerClass","animsDisabled","existingEvents","newEvents","changes","datasetCount","makeSet","changeSet","noArea","layers","useClip","getDatasetArea","_add","_remove","detached","activeElements","lastActive","pluginId","hoverOptions","deactivated","activated","eventFilter","isClick","lastEvent","determineLastEvent","abstract","DateAdapterBase","members","computeMinSampleSize","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderProps","parseEdge","orig","v2","startEnd","setInflateAmount","legendItem","getter","arcs","maxSize","chartWeight","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","animationOpts","centerX","centerY","metaData","ringWeightOffset","datasetStartAngle","defaultAngle","bars","ruler","vpixels","ipixels","currentParsed","iScaleValue","baseValue","actualBase","floating","barSign","halfGrid","Infinity","percent","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","pointPosition","parseBorderRadius","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","rThetaToXY","theta","pathArc","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","angleMargin","clipArc","setStyle","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","lineMethod","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","strokePathWithCache","segmentMethod","strokePathDirect","_interpolate","_getInterpolationMethod","interpolated","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","addRectPath","mouseX","mouseY","findOrAddLabel","addedLabels","addIfString","_getLabelForValue","relativeLabelSize","minSpacing","LinearScaleBase","setMin","setMax","minSign","maxSign","generationOptions","dataRange","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks","log10Floor","changeExponent","isMajor","tickVal","rangeExp","rangeStep","minExp","exp","startExp","lastTick","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","plFont","textSize","updateLimits","itemOpts","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","labelCount","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","UNITS","sorter","adapter","determineUnitForAutoTicks","capacity","interval","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","_applyBounds","timeOpts","determineUnitForFormatting","determineMajorUnit","weekday","hasWeekday","fmt","minorFormat","majorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","added","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","plugin_colors","_args","chartOptions","containsColorDefenition","colorizer","cleanDecimatedDataset","cleanDecimatedData","plugin_decimation","xAxis","getStartAndCountOfVisiblePointsSimplified","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","getBoxSize","labelOpts","labelFont","hitboxes","totalHeight","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","rtlHelper","hitbox","defaultColor","halfFontSize","cursor","drawOptions","yBoxTop","xBoxLeft","drawLegendBox","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","hoveredItem","sameItem","plugin_legend","fontOpts","plugin_title","createTitle","plugin_subtitle","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","createTooltipItem","getTooltipSize","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","widthPadding","maxLineWidth","determineXAlign","chartWidth","caret","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","tooltipItem","invokeCallbackWithFallback","bodyItems","scoped","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","colorX","rtlColorX","yOffSet","colorY","outerX","innerX","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","hasTooltipContent","positionChanged","plugin_tooltip"],"version":3,"file":"walkthrough.6c82c9da.js.map"}