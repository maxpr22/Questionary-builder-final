{"mappings":"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","sources":["<anon>","node_modules/chart.js/dist/chart.umd.js","node_modules/chart.js/src/helpers/helpers.core.ts","node_modules/chart.js/src/helpers/helpers.math.ts","node_modules/chart.js/src/helpers/helpers.collection.ts","node_modules/chart.js/src/helpers/helpers.extras.ts","node_modules/chart.js/src/core/core.animator.js","node_modules/chart.js/node_modules/.pnpm/@kurkle+color@0.3.2/node_modules/@kurkle/color/dist/color.esm.js","node_modules/chart.js/src/helpers/helpers.color.ts","node_modules/chart.js/src/core/core.animations.defaults.js","node_modules/chart.js/src/helpers/helpers.intl.ts","node_modules/chart.js/src/core/core.ticks.js","node_modules/chart.js/src/core/core.defaults.js","node_modules/chart.js/src/core/core.layouts.defaults.js","node_modules/chart.js/src/core/core.scale.defaults.js","node_modules/chart.js/src/helpers/helpers.dom.ts","node_modules/chart.js/src/helpers/helpers.canvas.ts","node_modules/chart.js/src/helpers/helpers.config.ts","node_modules/chart.js/src/helpers/helpers.curve.ts","node_modules/chart.js/src/helpers/helpers.easing.ts","node_modules/chart.js/src/helpers/helpers.interpolation.ts","node_modules/chart.js/src/helpers/helpers.options.ts","node_modules/chart.js/src/helpers/helpers.rtl.ts","node_modules/chart.js/src/helpers/helpers.segment.js","node_modules/chart.js/src/core/core.interaction.js","node_modules/chart.js/src/core/core.layouts.js","node_modules/chart.js/src/platform/platform.base.js","node_modules/chart.js/src/platform/platform.basic.js","node_modules/chart.js/src/platform/platform.dom.js","node_modules/chart.js/src/platform/index.js","node_modules/chart.js/src/core/core.animation.js","node_modules/chart.js/src/core/core.animations.js","node_modules/chart.js/src/core/core.datasetController.js","node_modules/chart.js/src/core/core.element.ts","node_modules/chart.js/src/core/core.scale.autoskip.js","node_modules/chart.js/src/core/core.scale.js","node_modules/chart.js/src/core/core.typedRegistry.js","node_modules/chart.js/src/core/core.registry.js","node_modules/chart.js/src/core/core.plugins.js","node_modules/chart.js/src/core/core.config.js","node_modules/chart.js/src/core/core.controller.js","node_modules/chart.js/src/core/core.adapters.ts","node_modules/chart.js/src/controllers/controller.bar.js","node_modules/chart.js/src/controllers/controller.doughnut.js","node_modules/chart.js/src/controllers/controller.polarArea.js","node_modules/chart.js/src/controllers/controller.bubble.js","node_modules/chart.js/src/controllers/controller.line.js","node_modules/chart.js/src/controllers/controller.pie.js","node_modules/chart.js/src/controllers/controller.radar.js","node_modules/chart.js/src/controllers/controller.scatter.js","node_modules/chart.js/src/elements/element.arc.ts","node_modules/chart.js/src/elements/element.line.js","node_modules/chart.js/src/elements/element.point.ts","node_modules/chart.js/src/elements/element.bar.js","node_modules/chart.js/src/scales/scale.category.js","node_modules/chart.js/src/scales/scale.linearbase.js","node_modules/chart.js/src/scales/scale.linear.js","node_modules/chart.js/src/scales/scale.logarithmic.js","node_modules/chart.js/src/scales/scale.radialLinear.js","node_modules/chart.js/src/scales/scale.time.js","node_modules/chart.js/src/scales/scale.timeseries.js","node_modules/chart.js/src/plugins/plugin.colors.ts","node_modules/chart.js/src/plugins/plugin.decimation.js","node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","node_modules/chart.js/src/plugins/plugin.filler/index.js","node_modules/chart.js/src/plugins/plugin.legend.js","node_modules/chart.js/src/plugins/plugin.title.js","node_modules/chart.js/src/plugins/plugin.subtitle.js","node_modules/chart.js/src/plugins/plugin.tooltip.js","node_modules/chart.js/src/index.umd.ts"],"sourcesContent":["/*!\n * Chart.js v4.4.8\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */ !function(t, e) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Chart = e();\n}(this, function() {\n    \"use strict\";\n    var t = Object.freeze({\n        __proto__: null,\n        get Colors () {\n            return Go;\n        },\n        get Decimation () {\n            return Qo;\n        },\n        get Filler () {\n            return ma;\n        },\n        get Legend () {\n            return ya;\n        },\n        get SubTitle () {\n            return ka;\n        },\n        get Title () {\n            return Ma;\n        },\n        get Tooltip () {\n            return Ba;\n        }\n    });\n    function e() {}\n    const i = (()=>{\n        let t = 0;\n        return ()=>t++;\n    })();\n    function s(t) {\n        return null == t;\n    }\n    function n(t) {\n        if (Array.isArray && Array.isArray(t)) return !0;\n        const e = Object.prototype.toString.call(t);\n        return \"[object\" === e.slice(0, 7) && \"Array]\" === e.slice(-6);\n    }\n    function o(t) {\n        return null !== t && \"[object Object]\" === Object.prototype.toString.call(t);\n    }\n    function a(t) {\n        return (\"number\" == typeof t || t instanceof Number) && isFinite(+t);\n    }\n    function r(t, e) {\n        return a(t) ? t : e;\n    }\n    function l(t, e) {\n        return void 0 === t ? e : t;\n    }\n    const h = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 : +t / e, c = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 * e : +t;\n    function d(t, e, i) {\n        if (t && \"function\" == typeof t.call) return t.apply(i, e);\n    }\n    function u(t, e, i, s) {\n        let a, r, l;\n        if (n(t)) {\n            if (r = t.length, s) for(a = r - 1; a >= 0; a--)e.call(i, t[a], a);\n            else for(a = 0; a < r; a++)e.call(i, t[a], a);\n        } else if (o(t)) for(l = Object.keys(t), r = l.length, a = 0; a < r; a++)e.call(i, t[l[a]], l[a]);\n    }\n    function f(t, e) {\n        let i, s, n, o;\n        if (!t || !e || t.length !== e.length) return !1;\n        for(i = 0, s = t.length; i < s; ++i)if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n        return !0;\n    }\n    function g(t) {\n        if (n(t)) return t.map(g);\n        if (o(t)) {\n            const e = Object.create(null), i = Object.keys(t), s = i.length;\n            let n = 0;\n            for(; n < s; ++n)e[i[n]] = g(t[i[n]]);\n            return e;\n        }\n        return t;\n    }\n    function p(t) {\n        return -1 === [\n            \"__proto__\",\n            \"prototype\",\n            \"constructor\"\n        ].indexOf(t);\n    }\n    function m(t, e, i, s) {\n        if (!p(t)) return;\n        const n = e[t], a = i[t];\n        o(n) && o(a) ? x(n, a, s) : e[t] = g(a);\n    }\n    function x(t, e, i) {\n        const s = n(e) ? e : [\n            e\n        ], a = s.length;\n        if (!o(t)) return t;\n        const r = (i = i || {}).merger || m;\n        let l;\n        for(let e = 0; e < a; ++e){\n            if (l = s[e], !o(l)) continue;\n            const n = Object.keys(l);\n            for(let e = 0, s = n.length; e < s; ++e)r(n[e], t, l, i);\n        }\n        return t;\n    }\n    function b(t, e) {\n        return x(t, e, {\n            merger: _\n        });\n    }\n    function _(t, e, i) {\n        if (!p(t)) return;\n        const s = e[t], n = i[t];\n        o(s) && o(n) ? b(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n));\n    }\n    const y = {\n        \"\": (t)=>t,\n        x: (t)=>t.x,\n        y: (t)=>t.y\n    };\n    function v(t) {\n        const e = t.split(\".\"), i = [];\n        let s = \"\";\n        for (const t of e)s += t, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (i.push(s), s = \"\");\n        return i;\n    }\n    function M(t, e) {\n        const i = y[e] || (y[e] = function(t) {\n            const e = v(t);\n            return (t)=>{\n                for (const i of e){\n                    if (\"\" === i) break;\n                    t = t && t[i];\n                }\n                return t;\n            };\n        }(e));\n        return i(t);\n    }\n    function w(t) {\n        return t.charAt(0).toUpperCase() + t.slice(1);\n    }\n    const k = (t)=>void 0 !== t, S = (t)=>\"function\" == typeof t, P = (t, e)=>{\n        if (t.size !== e.size) return !1;\n        for (const i of t)if (!e.has(i)) return !1;\n        return !0;\n    };\n    function D(t) {\n        return \"mouseup\" === t.type || \"click\" === t.type || \"contextmenu\" === t.type;\n    }\n    const C = Math.PI, O = 2 * C, A = O + C, T = Number.POSITIVE_INFINITY, L = C / 180, E = C / 2, R = C / 4, I = 2 * C / 3, z = Math.log10, F = Math.sign;\n    function V(t, e, i) {\n        return Math.abs(t - e) < i;\n    }\n    function B(t) {\n        const e = Math.round(t);\n        t = V(t, e, t / 1e3) ? e : t;\n        const i = Math.pow(10, Math.floor(z(t))), s = t / i;\n        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;\n    }\n    function W(t) {\n        const e = [], i = Math.sqrt(t);\n        let s;\n        for(s = 1; s < i; s++)t % s == 0 && (e.push(s), e.push(t / s));\n        return i === (0 | i) && e.push(i), e.sort((t, e)=>t - e).pop(), e;\n    }\n    function N(t) {\n        return !function(t) {\n            return \"symbol\" == typeof t || \"object\" == typeof t && null !== t && !(Symbol.toPrimitive in t || \"toString\" in t || \"valueOf\" in t);\n        }(t) && !isNaN(parseFloat(t)) && isFinite(t);\n    }\n    function H(t, e) {\n        const i = Math.round(t);\n        return i - e <= t && i + e >= t;\n    }\n    function j(t, e, i) {\n        let s, n, o;\n        for(s = 0, n = t.length; s < n; s++)o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));\n    }\n    function $(t) {\n        return t * (C / 180);\n    }\n    function Y(t) {\n        return t * (180 / C);\n    }\n    function U(t) {\n        if (!a(t)) return;\n        let e = 1, i = 0;\n        for(; Math.round(t * e) / e !== t;)e *= 10, i++;\n        return i;\n    }\n    function X(t, e) {\n        const i = e.x - t.x, s = e.y - t.y, n = Math.sqrt(i * i + s * s);\n        let o = Math.atan2(s, i);\n        return o < -0.5 * C && (o += O), {\n            angle: o,\n            distance: n\n        };\n    }\n    function q(t, e) {\n        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }\n    function K(t, e) {\n        return (t - e + A) % O - C;\n    }\n    function G(t) {\n        return (t % O + O) % O;\n    }\n    function Z(t, e, i, s) {\n        const n = G(t), o = G(e), a = G(i), r = G(o - n), l = G(a - n), h = G(n - o), c = G(n - a);\n        return n === o || n === a || s && o === a || r > l && h < c;\n    }\n    function J(t, e, i) {\n        return Math.max(e, Math.min(i, t));\n    }\n    function Q(t) {\n        return J(t, -32768, 32767);\n    }\n    function tt(t, e, i, s = 1e-6) {\n        return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s;\n    }\n    function et(t, e, i) {\n        i = i || ((i)=>t[i] < e);\n        let s, n = t.length - 1, o = 0;\n        for(; n - o > 1;)s = o + n >> 1, i(s) ? o = s : n = s;\n        return {\n            lo: o,\n            hi: n\n        };\n    }\n    const it = (t, e, i, s)=>et(t, i, s ? (s)=>{\n            const n = t[s][e];\n            return n < i || n === i && t[s + 1][e] === i;\n        } : (s)=>t[s][e] < i), st = (t, e, i)=>et(t, i, (s)=>t[s][e] >= i);\n    function nt(t, e, i) {\n        let s = 0, n = t.length;\n        for(; s < n && t[s] < e;)s++;\n        for(; n > s && t[n - 1] > i;)n--;\n        return s > 0 || n < t.length ? t.slice(s, n) : t;\n    }\n    const ot = [\n        \"push\",\n        \"pop\",\n        \"shift\",\n        \"splice\",\n        \"unshift\"\n    ];\n    function at(t, e) {\n        t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, \"_chartjs\", {\n            configurable: !0,\n            enumerable: !1,\n            value: {\n                listeners: [\n                    e\n                ]\n            }\n        }), ot.forEach((e)=>{\n            const i = \"_onData\" + w(e), s = t[e];\n            Object.defineProperty(t, e, {\n                configurable: !0,\n                enumerable: !1,\n                value (...e) {\n                    const n = s.apply(this, e);\n                    return t._chartjs.listeners.forEach((t)=>{\n                        \"function\" == typeof t[i] && t[i](...e);\n                    }), n;\n                }\n            });\n        }));\n    }\n    function rt(t, e) {\n        const i = t._chartjs;\n        if (!i) return;\n        const s = i.listeners, n = s.indexOf(e);\n        -1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e)=>{\n            delete t[e];\n        }), delete t._chartjs);\n    }\n    function lt(t) {\n        const e = new Set(t);\n        return e.size === t.length ? t : Array.from(e);\n    }\n    const ht = \"undefined\" == typeof window ? function(t) {\n        return t();\n    } : window.requestAnimationFrame;\n    function ct(t, e) {\n        let i = [], s = !1;\n        return function(...n) {\n            i = n, s || (s = !0, ht.call(window, ()=>{\n                s = !1, t.apply(e, i);\n            }));\n        };\n    }\n    function dt(t, e) {\n        let i;\n        return function(...s) {\n            return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e;\n        };\n    }\n    const ut = (t)=>\"start\" === t ? \"left\" : \"end\" === t ? \"right\" : \"center\", ft = (t, e, i)=>\"start\" === t ? e : \"end\" === t ? i : (e + i) / 2, gt = (t, e, i, s)=>t === (s ? \"left\" : \"right\") ? i : \"center\" === t ? (e + i) / 2 : e;\n    function pt(t, e, i) {\n        const n = e.length;\n        let o = 0, a = n;\n        if (t._sorted) {\n            const { iScale: r, vScale: l, _parsed: h } = t, c = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null, d = r.axis, { min: u, max: f, minDefined: g, maxDefined: p } = r.getUserBounds();\n            if (g) {\n                if (o = Math.min(it(h, d, u).lo, i ? n : it(e, d, r.getPixelForValue(u)).lo), c) {\n                    const t = h.slice(0, o + 1).reverse().findIndex((t)=>!s(t[l.axis]));\n                    o -= Math.max(0, t);\n                }\n                o = J(o, 0, n - 1);\n            }\n            if (p) {\n                let t = Math.max(it(h, r.axis, f, !0).hi + 1, i ? 0 : it(e, d, r.getPixelForValue(f), !0).hi + 1);\n                if (c) {\n                    const e = h.slice(t - 1).findIndex((t)=>!s(t[l.axis]));\n                    t += Math.max(0, e);\n                }\n                a = J(t, o, n) - o;\n            } else a = n - o;\n        }\n        return {\n            start: o,\n            count: a\n        };\n    }\n    function mt(t) {\n        const { xScale: e, yScale: i, _scaleRanges: s } = t, n = {\n            xmin: e.min,\n            xmax: e.max,\n            ymin: i.min,\n            ymax: i.max\n        };\n        if (!s) return t._scaleRanges = n, !0;\n        const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\n        return Object.assign(s, n), o;\n    }\n    class xt {\n        constructor(){\n            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0;\n        }\n        _notify(t, e, i, s) {\n            const n = e.listeners[s], o = e.duration;\n            n.forEach((s)=>s({\n                    chart: t,\n                    initial: e.initial,\n                    numSteps: o,\n                    currentStep: Math.min(i - e.start, o)\n                }));\n        }\n        _refresh() {\n            this._request || (this._running = !0, this._request = ht.call(window, ()=>{\n                this._update(), this._request = null, this._running && this._refresh();\n            }));\n        }\n        _update(t = Date.now()) {\n            let e = 0;\n            this._charts.forEach((i, s)=>{\n                if (!i.running || !i.items.length) return;\n                const n = i.items;\n                let o, a = n.length - 1, r = !1;\n                for(; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\n                r && (s.draw(), this._notify(s, i, t, \"progress\")), n.length || (i.running = !1, this._notify(s, i, t, \"complete\"), i.initial = !1), e += n.length;\n            }), this._lastDate = t, 0 === e && (this._running = !1);\n        }\n        _getAnims(t) {\n            const e = this._charts;\n            let i = e.get(t);\n            return i || (i = {\n                running: !1,\n                initial: !0,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            }, e.set(t, i)), i;\n        }\n        listen(t, e, i) {\n            this._getAnims(t).listeners[e].push(i);\n        }\n        add(t, e) {\n            e && e.length && this._getAnims(t).items.push(...e);\n        }\n        has(t) {\n            return this._getAnims(t).items.length > 0;\n        }\n        start(t) {\n            const e = this._charts.get(t);\n            e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e)=>Math.max(t, e._duration), 0), this._refresh());\n        }\n        running(t) {\n            if (!this._running) return !1;\n            const e = this._charts.get(t);\n            return !!(e && e.running && e.items.length);\n        }\n        stop(t) {\n            const e = this._charts.get(t);\n            if (!e || !e.items.length) return;\n            const i = e.items;\n            let s = i.length - 1;\n            for(; s >= 0; --s)i[s].cancel();\n            e.items = [], this._notify(t, e, Date.now(), \"complete\");\n        }\n        remove(t) {\n            return this._charts.delete(t);\n        }\n    }\n    var bt = new xt;\n    /*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */ function _t(t) {\n        return t + .5 | 0;\n    }\n    const yt = (t, e, i)=>Math.max(Math.min(t, i), e);\n    function vt(t) {\n        return yt(_t(2.55 * t), 0, 255);\n    }\n    function Mt(t) {\n        return yt(_t(255 * t), 0, 255);\n    }\n    function wt(t) {\n        return yt(_t(t / 2.55) / 100, 0, 1);\n    }\n    function kt(t) {\n        return yt(_t(100 * t), 0, 100);\n    }\n    const St = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, Pt = [\n        ...\"0123456789ABCDEF\"\n    ], Dt = (t)=>Pt[15 & t], Ct = (t)=>Pt[(240 & t) >> 4] + Pt[15 & t], Ot = (t)=>(240 & t) >> 4 == (15 & t);\n    function At(t) {\n        var e = ((t)=>Ot(t.r) && Ot(t.g) && Ot(t.b) && Ot(t.a))(t) ? Dt : Ct;\n        return t ? \"#\" + e(t.r) + e(t.g) + e(t.b) + ((t, e)=>t < 255 ? e(t) : \"\")(t.a, e) : void 0;\n    }\n    const Tt = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function Lt(t, e, i) {\n        const s = e * Math.min(i, 1 - i), n = (e, n = (e + t / 30) % 12)=>i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\n        return [\n            n(0),\n            n(8),\n            n(4)\n        ];\n    }\n    function Et(t, e, i) {\n        const s = (s, n = (s + t / 60) % 6)=>i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\n        return [\n            s(5),\n            s(3),\n            s(1)\n        ];\n    }\n    function Rt(t, e, i) {\n        const s = Lt(t, 1, .5);\n        let n;\n        for(e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++)s[n] *= 1 - e - i, s[n] += e;\n        return s;\n    }\n    function It(t) {\n        const e = t.r / 255, i = t.g / 255, s = t.b / 255, n = Math.max(e, i, s), o = Math.min(e, i, s), a = (n + o) / 2;\n        let r, l, h;\n        return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function(t, e, i, s, n) {\n            return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4;\n        }(e, i, s, h, n), r = 60 * r + .5), [\n            0 | r,\n            l || 0,\n            a\n        ];\n    }\n    function zt(t, e, i, s) {\n        return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt);\n    }\n    function Ft(t, e, i) {\n        return zt(Lt, t, e, i);\n    }\n    function Vt(t) {\n        return (t % 360 + 360) % 360;\n    }\n    function Bt(t) {\n        const e = Tt.exec(t);\n        let i, s = 255;\n        if (!e) return;\n        e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5]));\n        const n = Vt(+e[2]), o = +e[3] / 100, a = +e[4] / 100;\n        return i = \"hwb\" === e[1] ? function(t, e, i) {\n            return zt(Rt, t, e, i);\n        }(n, o, a) : \"hsv\" === e[1] ? function(t, e, i) {\n            return zt(Et, t, e, i);\n        }(n, o, a) : Ft(n, o, a), {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: s\n        };\n    }\n    const Wt = {\n        x: \"dark\",\n        Z: \"light\",\n        Y: \"re\",\n        X: \"blu\",\n        W: \"gr\",\n        V: \"medium\",\n        U: \"slate\",\n        A: \"ee\",\n        T: \"ol\",\n        S: \"or\",\n        B: \"ra\",\n        C: \"lateg\",\n        D: \"ights\",\n        R: \"in\",\n        Q: \"turquois\",\n        E: \"hi\",\n        P: \"ro\",\n        O: \"al\",\n        N: \"le\",\n        M: \"de\",\n        L: \"yello\",\n        F: \"en\",\n        K: \"ch\",\n        G: \"arks\",\n        H: \"ea\",\n        I: \"ightg\",\n        J: \"wh\"\n    }, Nt = {\n        OiceXe: \"f0f8ff\",\n        antiquewEte: \"faebd7\",\n        aqua: \"ffff\",\n        aquamarRe: \"7fffd4\",\n        azuY: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"0\",\n        blanKedOmond: \"ffebcd\",\n        Xe: \"ff\",\n        XeviTet: \"8a2be2\",\n        bPwn: \"a52a2a\",\n        burlywood: \"deb887\",\n        caMtXe: \"5f9ea0\",\n        KartYuse: \"7fff00\",\n        KocTate: \"d2691e\",\n        cSO: \"ff7f50\",\n        cSnflowerXe: \"6495ed\",\n        cSnsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"ffff\",\n        xXe: \"8b\",\n        xcyan: \"8b8b\",\n        xgTMnPd: \"b8860b\",\n        xWay: \"a9a9a9\",\n        xgYF: \"6400\",\n        xgYy: \"a9a9a9\",\n        xkhaki: \"bdb76b\",\n        xmagFta: \"8b008b\",\n        xTivegYF: \"556b2f\",\n        xSange: \"ff8c00\",\n        xScEd: \"9932cc\",\n        xYd: \"8b0000\",\n        xsOmon: \"e9967a\",\n        xsHgYF: \"8fbc8f\",\n        xUXe: \"483d8b\",\n        xUWay: \"2f4f4f\",\n        xUgYy: \"2f4f4f\",\n        xQe: \"ced1\",\n        xviTet: \"9400d3\",\n        dAppRk: \"ff1493\",\n        dApskyXe: \"bfff\",\n        dimWay: \"696969\",\n        dimgYy: \"696969\",\n        dodgerXe: \"1e90ff\",\n        fiYbrick: \"b22222\",\n        flSOwEte: \"fffaf0\",\n        foYstWAn: \"228b22\",\n        fuKsia: \"ff00ff\",\n        gaRsbSo: \"dcdcdc\",\n        ghostwEte: \"f8f8ff\",\n        gTd: \"ffd700\",\n        gTMnPd: \"daa520\",\n        Way: \"808080\",\n        gYF: \"8000\",\n        gYFLw: \"adff2f\",\n        gYy: \"808080\",\n        honeyMw: \"f0fff0\",\n        hotpRk: \"ff69b4\",\n        RdianYd: \"cd5c5c\",\n        Rdigo: \"4b0082\",\n        ivSy: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavFMr: \"e6e6fa\",\n        lavFMrXsh: \"fff0f5\",\n        lawngYF: \"7cfc00\",\n        NmoncEffon: \"fffacd\",\n        ZXe: \"add8e6\",\n        ZcSO: \"f08080\",\n        Zcyan: \"e0ffff\",\n        ZgTMnPdLw: \"fafad2\",\n        ZWay: \"d3d3d3\",\n        ZgYF: \"90ee90\",\n        ZgYy: \"d3d3d3\",\n        ZpRk: \"ffb6c1\",\n        ZsOmon: \"ffa07a\",\n        ZsHgYF: \"20b2aa\",\n        ZskyXe: \"87cefa\",\n        ZUWay: \"778899\",\n        ZUgYy: \"778899\",\n        ZstAlXe: \"b0c4de\",\n        ZLw: \"ffffe0\",\n        lime: \"ff00\",\n        limegYF: \"32cd32\",\n        lRF: \"faf0e6\",\n        magFta: \"ff00ff\",\n        maPon: \"800000\",\n        VaquamarRe: \"66cdaa\",\n        VXe: \"cd\",\n        VScEd: \"ba55d3\",\n        VpurpN: \"9370db\",\n        VsHgYF: \"3cb371\",\n        VUXe: \"7b68ee\",\n        VsprRggYF: \"fa9a\",\n        VQe: \"48d1cc\",\n        VviTetYd: \"c71585\",\n        midnightXe: \"191970\",\n        mRtcYam: \"f5fffa\",\n        mistyPse: \"ffe4e1\",\n        moccasR: \"ffe4b5\",\n        navajowEte: \"ffdead\",\n        navy: \"80\",\n        Tdlace: \"fdf5e6\",\n        Tive: \"808000\",\n        TivedBb: \"6b8e23\",\n        Sange: \"ffa500\",\n        SangeYd: \"ff4500\",\n        ScEd: \"da70d6\",\n        pOegTMnPd: \"eee8aa\",\n        pOegYF: \"98fb98\",\n        pOeQe: \"afeeee\",\n        pOeviTetYd: \"db7093\",\n        papayawEp: \"ffefd5\",\n        pHKpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pRk: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powMrXe: \"b0e0e6\",\n        purpN: \"800080\",\n        YbeccapurpN: \"663399\",\n        Yd: \"ff0000\",\n        Psybrown: \"bc8f8f\",\n        PyOXe: \"4169e1\",\n        saddNbPwn: \"8b4513\",\n        sOmon: \"fa8072\",\n        sandybPwn: \"f4a460\",\n        sHgYF: \"2e8b57\",\n        sHshell: \"fff5ee\",\n        siFna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyXe: \"87ceeb\",\n        UXe: \"6a5acd\",\n        UWay: \"708090\",\n        UgYy: \"708090\",\n        snow: \"fffafa\",\n        sprRggYF: \"ff7f\",\n        stAlXe: \"4682b4\",\n        tan: \"d2b48c\",\n        teO: \"8080\",\n        tEstN: \"d8bfd8\",\n        tomato: \"ff6347\",\n        Qe: \"40e0d0\",\n        viTet: \"ee82ee\",\n        JHt: \"f5deb3\",\n        wEte: \"ffffff\",\n        wEtesmoke: \"f5f5f5\",\n        Lw: \"ffff00\",\n        LwgYF: \"9acd32\"\n    };\n    let Ht;\n    function jt(t) {\n        Ht || (Ht = function() {\n            const t = {}, e = Object.keys(Nt), i = Object.keys(Wt);\n            let s, n, o, a, r;\n            for(s = 0; s < e.length; s++){\n                for(a = r = e[s], n = 0; n < i.length; n++)o = i[n], r = r.replace(o, Wt[o]);\n                o = parseInt(Nt[a], 16), t[r] = [\n                    o >> 16 & 255,\n                    o >> 8 & 255,\n                    255 & o\n                ];\n            }\n            return t;\n        }(), Ht.transparent = [\n            0,\n            0,\n            0,\n            0\n        ]);\n        const e = Ht[t.toLowerCase()];\n        return e && {\n            r: e[0],\n            g: e[1],\n            b: e[2],\n            a: 4 === e.length ? e[3] : 255\n        };\n    }\n    const $t = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    const Yt = (t)=>t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, Ut = (t)=>t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    function Xt(t, e, i) {\n        if (t) {\n            let s = It(t);\n            s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2];\n        }\n    }\n    function qt(t, e) {\n        return t ? Object.assign(e || {}, t) : t;\n    }\n    function Kt(t) {\n        var e = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 255\n        };\n        return Array.isArray(t) ? t.length >= 3 && (e = {\n            r: t[0],\n            g: t[1],\n            b: t[2],\n            a: 255\n        }, t.length > 3 && (e.a = Mt(t[3]))) : (e = qt(t, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        })).a = Mt(e.a), e;\n    }\n    function Gt(t) {\n        return \"r\" === t.charAt(0) ? function(t) {\n            const e = $t.exec(t);\n            let i, s, n, o = 255;\n            if (e) {\n                if (e[7] !== i) {\n                    const t = +e[7];\n                    o = e[8] ? vt(t) : yt(255 * t, 0, 255);\n                }\n                return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 & (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 & (e[6] ? vt(n) : yt(n, 0, 255)), {\n                    r: i,\n                    g: s,\n                    b: n,\n                    a: o\n                };\n            }\n        }(t) : Bt(t);\n    }\n    class Zt {\n        constructor(t){\n            if (t instanceof Zt) return t;\n            const e = typeof t;\n            let i;\n            var s, n, o;\n            \"object\" === e ? i = Kt(t) : \"string\" === e && (o = (s = t).length, \"#\" === s[0] && (4 === o || 5 === o ? n = {\n                r: 255 & 17 * St[s[1]],\n                g: 255 & 17 * St[s[2]],\n                b: 255 & 17 * St[s[3]],\n                a: 5 === o ? 17 * St[s[4]] : 255\n            } : 7 !== o && 9 !== o || (n = {\n                r: St[s[1]] << 4 | St[s[2]],\n                g: St[s[3]] << 4 | St[s[4]],\n                b: St[s[5]] << 4 | St[s[6]],\n                a: 9 === o ? St[s[7]] << 4 | St[s[8]] : 255\n            })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i;\n        }\n        get valid() {\n            return this._valid;\n        }\n        get rgb() {\n            var t = qt(this._rgb);\n            return t && (t.a = wt(t.a)), t;\n        }\n        set rgb(t) {\n            this._rgb = Kt(t);\n        }\n        rgbString() {\n            var t;\n            return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;\n        }\n        hexString() {\n            return this._valid ? At(this._rgb) : void 0;\n        }\n        hslString() {\n            return this._valid ? function(t) {\n                if (!t) return;\n                const e = It(t), i = e[0], s = kt(e[1]), n = kt(e[2]);\n                return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`;\n            }(this._rgb) : void 0;\n        }\n        mix(t, e) {\n            if (t) {\n                const i = this.rgb, s = t.rgb;\n                let n;\n                const o = e === n ? .5 : e, a = 2 * o - 1, r = i.a - s.a, l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;\n                n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;\n            }\n            return this;\n        }\n        interpolate(t, e) {\n            return t && (this._rgb = function(t, e, i) {\n                const s = Ut(wt(t.r)), n = Ut(wt(t.g)), o = Ut(wt(t.b));\n                return {\n                    r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),\n                    g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),\n                    b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),\n                    a: t.a + i * (e.a - t.a)\n                };\n            }(this._rgb, t._rgb, e)), this;\n        }\n        clone() {\n            return new Zt(this.rgb);\n        }\n        alpha(t) {\n            return this._rgb.a = Mt(t), this;\n        }\n        clearer(t) {\n            return this._rgb.a *= 1 - t, this;\n        }\n        greyscale() {\n            const t = this._rgb, e = _t(.3 * t.r + .59 * t.g + .11 * t.b);\n            return t.r = t.g = t.b = e, this;\n        }\n        opaquer(t) {\n            return this._rgb.a *= 1 + t, this;\n        }\n        negate() {\n            const t = this._rgb;\n            return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n        }\n        lighten(t) {\n            return Xt(this._rgb, 2, t), this;\n        }\n        darken(t) {\n            return Xt(this._rgb, 2, -t), this;\n        }\n        saturate(t) {\n            return Xt(this._rgb, 1, t), this;\n        }\n        desaturate(t) {\n            return Xt(this._rgb, 1, -t), this;\n        }\n        rotate(t) {\n            return function(t, e) {\n                var i = It(t);\n                i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2];\n            }(this._rgb, t), this;\n        }\n    }\n    function Jt(t) {\n        if (t && \"object\" == typeof t) {\n            const e = t.toString();\n            return \"[object CanvasPattern]\" === e || \"[object CanvasGradient]\" === e;\n        }\n        return !1;\n    }\n    function Qt(t) {\n        return Jt(t) ? t : new Zt(t);\n    }\n    function te(t) {\n        return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString();\n    }\n    const ee = [\n        \"x\",\n        \"y\",\n        \"borderWidth\",\n        \"radius\",\n        \"tension\"\n    ], ie = [\n        \"color\",\n        \"borderColor\",\n        \"backgroundColor\"\n    ];\n    const se = new Map;\n    function ne(t, e, i) {\n        return (function(t, e) {\n            e = e || {};\n            const i = t + JSON.stringify(e);\n            let s = se.get(i);\n            return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s;\n        })(e, i).format(t);\n    }\n    const oe = {\n        values: (t)=>n(t) ? t : \"\" + t,\n        numeric (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = this.chart.options.locale;\n            let n, o = t;\n            if (i.length > 1) {\n                const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\n                (e < 1e-4 || e > 1e15) && (n = \"scientific\"), o = function(t, e) {\n                    let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\n                    Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));\n                    return i;\n                }(t, i);\n            }\n            const a = z(Math.abs(o)), r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {\n                notation: n,\n                minimumFractionDigits: r,\n                maximumFractionDigits: r\n            };\n            return Object.assign(l, this.options.ticks.format), ne(t, s, l);\n        },\n        logarithmic (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = i[e].significand || t / Math.pow(10, Math.floor(z(t)));\n            return [\n                1,\n                2,\n                3,\n                5,\n                10,\n                15\n            ].includes(s) || e > .8 * i.length ? oe.numeric.call(this, t, e, i) : \"\";\n        }\n    };\n    var ae = {\n        formatters: oe\n    };\n    const re = Object.create(null), le = Object.create(null);\n    function he(t, e) {\n        if (!e) return t;\n        const i = e.split(\".\");\n        for(let e = 0, s = i.length; e < s; ++e){\n            const s = i[e];\n            t = t[s] || (t[s] = Object.create(null));\n        }\n        return t;\n    }\n    function ce(t, e, i) {\n        return \"string\" == typeof e ? x(he(t, e), i) : x(he(t, \"\"), e);\n    }\n    class de {\n        constructor(t, e){\n            this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (t)=>t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n                \"mousemove\",\n                \"mouseout\",\n                \"click\",\n                \"touchstart\",\n                \"touchmove\"\n            ], this.font = {\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                size: 12,\n                style: \"normal\",\n                lineHeight: 1.2,\n                weight: null\n            }, this.hover = {}, this.hoverBackgroundColor = (t, e)=>te(e.backgroundColor), this.hoverBorderColor = (t, e)=>te(e.borderColor), this.hoverColor = (t, e)=>te(e.color), this.indexAxis = \"x\", this.interaction = {\n                mode: \"nearest\",\n                intersect: !0,\n                includeInvisible: !1\n            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n        }\n        set(t, e) {\n            return ce(this, t, e);\n        }\n        get(t) {\n            return he(this, t);\n        }\n        describe(t, e) {\n            return ce(le, t, e);\n        }\n        override(t, e) {\n            return ce(re, t, e);\n        }\n        route(t, e, i, s) {\n            const n = he(this, t), a = he(this, i), r = \"_\" + e;\n            Object.defineProperties(n, {\n                [r]: {\n                    value: n[e],\n                    writable: !0\n                },\n                [e]: {\n                    enumerable: !0,\n                    get () {\n                        const t = this[r], e = a[s];\n                        return o(t) ? Object.assign({}, e, t) : l(t, e);\n                    },\n                    set (t) {\n                        this[r] = t;\n                    }\n                }\n            });\n        }\n        apply(t) {\n            t.forEach((t)=>t(this));\n        }\n    }\n    var ue = new de({\n        _scriptable: (t)=>!t.startsWith(\"on\"),\n        _indexable: (t)=>\"events\" !== t,\n        hover: {\n            _fallback: \"interaction\"\n        },\n        interaction: {\n            _scriptable: !1,\n            _indexable: !1\n        }\n    }, [\n        function(t) {\n            t.set(\"animation\", {\n                delay: void 0,\n                duration: 1e3,\n                easing: \"easeOutQuart\",\n                fn: void 0,\n                from: void 0,\n                loop: void 0,\n                to: void 0,\n                type: void 0\n            }), t.describe(\"animation\", {\n                _fallback: !1,\n                _indexable: !1,\n                _scriptable: (t)=>\"onProgress\" !== t && \"onComplete\" !== t && \"fn\" !== t\n            }), t.set(\"animations\", {\n                colors: {\n                    type: \"color\",\n                    properties: ie\n                },\n                numbers: {\n                    type: \"number\",\n                    properties: ee\n                }\n            }), t.describe(\"animations\", {\n                _fallback: \"animation\"\n            }), t.set(\"transitions\", {\n                active: {\n                    animation: {\n                        duration: 400\n                    }\n                },\n                resize: {\n                    animation: {\n                        duration: 0\n                    }\n                },\n                show: {\n                    animations: {\n                        colors: {\n                            from: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            duration: 0\n                        }\n                    }\n                },\n                hide: {\n                    animations: {\n                        colors: {\n                            to: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            easing: \"linear\",\n                            fn: (t)=>0 | t\n                        }\n                    }\n                }\n            });\n        },\n        function(t) {\n            t.set(\"layout\", {\n                autoPadding: !0,\n                padding: {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                }\n            });\n        },\n        function(t) {\n            t.set(\"scale\", {\n                display: !0,\n                offset: !1,\n                reverse: !1,\n                beginAtZero: !1,\n                bounds: \"ticks\",\n                clip: !0,\n                grace: 0,\n                grid: {\n                    display: !0,\n                    lineWidth: 1,\n                    drawOnChartArea: !0,\n                    drawTicks: !0,\n                    tickLength: 8,\n                    tickWidth: (t, e)=>e.lineWidth,\n                    tickColor: (t, e)=>e.color,\n                    offset: !1\n                },\n                border: {\n                    display: !0,\n                    dash: [],\n                    dashOffset: 0,\n                    width: 1\n                },\n                title: {\n                    display: !1,\n                    text: \"\",\n                    padding: {\n                        top: 4,\n                        bottom: 4\n                    }\n                },\n                ticks: {\n                    minRotation: 0,\n                    maxRotation: 50,\n                    mirror: !1,\n                    textStrokeWidth: 0,\n                    textStrokeColor: \"\",\n                    padding: 3,\n                    display: !0,\n                    autoSkip: !0,\n                    autoSkipPadding: 3,\n                    labelOffset: 0,\n                    callback: ae.formatters.values,\n                    minor: {},\n                    major: {},\n                    align: \"center\",\n                    crossAlign: \"near\",\n                    showLabelBackdrop: !1,\n                    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n                    backdropPadding: 2\n                }\n            }), t.route(\"scale.ticks\", \"color\", \"\", \"color\"), t.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), t.route(\"scale.border\", \"color\", \"\", \"borderColor\"), t.route(\"scale.title\", \"color\", \"\", \"color\"), t.describe(\"scale\", {\n                _fallback: !1,\n                _scriptable: (t)=>!t.startsWith(\"before\") && !t.startsWith(\"after\") && \"callback\" !== t && \"parser\" !== t,\n                _indexable: (t)=>\"borderDash\" !== t && \"tickBorderDash\" !== t && \"dash\" !== t\n            }), t.describe(\"scales\", {\n                _fallback: \"scale\"\n            }), t.describe(\"scale.ticks\", {\n                _scriptable: (t)=>\"backdropPadding\" !== t && \"callback\" !== t,\n                _indexable: (t)=>\"backdropPadding\" !== t\n            });\n        }\n    ]);\n    function fe() {\n        return \"undefined\" != typeof window && \"undefined\" != typeof document;\n    }\n    function ge(t) {\n        let e = t.parentNode;\n        return e && \"[object ShadowRoot]\" === e.toString() && (e = e.host), e;\n    }\n    function pe(t, e, i) {\n        let s;\n        return \"string\" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(\"%\") && (s = s / 100 * e.parentNode[i])) : s = t, s;\n    }\n    const me = (t)=>t.ownerDocument.defaultView.getComputedStyle(t, null);\n    function xe(t, e) {\n        return me(t).getPropertyValue(e);\n    }\n    const be = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    function _e(t, e, i) {\n        const s = {};\n        i = i ? \"-\" + i : \"\";\n        for(let n = 0; n < 4; n++){\n            const o = be[n];\n            s[o] = parseFloat(t[e + \"-\" + o + i]) || 0;\n        }\n        return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n    }\n    const ye = (t, e, i)=>(t > 0 || e > 0) && (!i || !i.shadowRoot);\n    function ve(t, e) {\n        if (\"native\" in t) return t;\n        const { canvas: i, currentDevicePixelRatio: s } = e, n = me(i), o = \"border-box\" === n.boxSizing, a = _e(n, \"padding\"), r = _e(n, \"border\", \"width\"), { x: l, y: h, box: c } = function(t, e) {\n            const i = t.touches, s = i && i.length ? i[0] : t, { offsetX: n, offsetY: o } = s;\n            let a, r, l = !1;\n            if (ye(n, o, t.target)) a = n, r = o;\n            else {\n                const t = e.getBoundingClientRect();\n                a = s.clientX - t.left, r = s.clientY - t.top, l = !0;\n            }\n            return {\n                x: a,\n                y: r,\n                box: l\n            };\n        }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);\n        let { width: f, height: g } = e;\n        return o && (f -= a.width + r.width, g -= a.height + r.height), {\n            x: Math.round((l - d) / f * i.width / s),\n            y: Math.round((h - u) / g * i.height / s)\n        };\n    }\n    const Me = (t)=>Math.round(10 * t) / 10;\n    function we(t, e, i, s) {\n        const n = me(t), o = _e(n, \"margin\"), a = pe(n.maxWidth, t, \"clientWidth\") || T, r = pe(n.maxHeight, t, \"clientHeight\") || T, l = function(t, e, i) {\n            let s, n;\n            if (void 0 === e || void 0 === i) {\n                const o = t && ge(t);\n                if (o) {\n                    const t = o.getBoundingClientRect(), a = me(o), r = _e(a, \"border\", \"width\"), l = _e(a, \"padding\");\n                    e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, \"clientWidth\"), n = pe(a.maxHeight, o, \"clientHeight\");\n                } else e = t.clientWidth, i = t.clientHeight;\n            }\n            return {\n                width: e,\n                height: i,\n                maxWidth: s || T,\n                maxHeight: n || T\n            };\n        }(t, e, i);\n        let { width: h, height: c } = l;\n        if (\"content-box\" === n.boxSizing) {\n            const t = _e(n, \"border\", \"width\"), e = _e(n, \"padding\");\n            h -= e.width + t.width, c -= e.height + t.height;\n        }\n        h = Math.max(0, h - o.width), c = Math.max(0, s ? h / s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h && !c && (c = Me(h / 2));\n        return (void 0 !== e || void 0 !== i) && s && l.height && c > l.height && (c = l.height, h = Me(Math.floor(c * s))), {\n            width: h,\n            height: c\n        };\n    }\n    function ke(t, e, i) {\n        const s = e || 1, n = Math.floor(t.height * s), o = Math.floor(t.width * s);\n        t.height = Math.floor(t.height), t.width = Math.floor(t.width);\n        const a = t.canvas;\n        return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0);\n    }\n    const Se = function() {\n        let t = !1;\n        try {\n            const e = {\n                get passive () {\n                    return t = !0, !1;\n                }\n            };\n            fe() && (window.addEventListener(\"test\", null, e), window.removeEventListener(\"test\", null, e));\n        } catch (t) {}\n        return t;\n    }();\n    function Pe(t, e) {\n        const i = xe(t, e), s = i && i.match(/^(\\d+)(\\.\\d+)?px$/);\n        return s ? +s[1] : void 0;\n    }\n    function De(t) {\n        return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + \" \" : \"\") + (t.weight ? t.weight + \" \" : \"\") + t.size + \"px \" + t.family;\n    }\n    function Ce(t, e, i, s, n) {\n        let o = e[n];\n        return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s;\n    }\n    function Oe(t, e, i, s) {\n        let o = (s = s || {}).data = s.data || {}, a = s.garbageCollect = s.garbageCollect || [];\n        s.font !== e && (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;\n        let r = 0;\n        const l = i.length;\n        let h, c, d, u, f;\n        for(h = 0; h < l; h++)if (u = i[h], null == u || n(u)) {\n            if (n(u)) for(c = 0, d = u.length; c < d; c++)f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f));\n        } else r = Ce(t, o, a, r, u);\n        t.restore();\n        const g = a.length / 2;\n        if (g > i.length) {\n            for(h = 0; h < g; h++)delete o[a[h]];\n            a.splice(0, g);\n        }\n        return r;\n    }\n    function Ae(t, e, i) {\n        const s = t.currentDevicePixelRatio, n = 0 !== i ? Math.max(i / 2, .5) : 0;\n        return Math.round((e - n) * s) / s + n;\n    }\n    function Te(t, e) {\n        (e || t) && ((e = e || t.getContext(\"2d\")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore());\n    }\n    function Le(t, e, i, s) {\n        Ee(t, e, i, s, null);\n    }\n    function Ee(t, e, i, s, n) {\n        let o, a, r, l, h, c, d, u;\n        const f = e.pointStyle, g = e.rotation, p = e.radius;\n        let m = (g || 0) * L;\n        if (f && \"object\" == typeof f && (o = f.toString(), \"[object HTMLImageElement]\" === o || \"[object HTMLCanvasElement]\" === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();\n        if (!(isNaN(p) || p <= 0)) {\n            switch(t.beginPath(), f){\n                default:\n                    n ? t.ellipse(i, s, n / 2, p, 0, 0, O) : t.arc(i, s, p, 0, O), t.closePath();\n                    break;\n                case \"triangle\":\n                    c = n ? n / 2 : p, t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), t.closePath();\n                    break;\n                case \"rectRounded\":\n                    h = .516 * p, l = p - h, a = Math.cos(m + R) * l, d = Math.cos(m + R) * (n ? n / 2 - h : l), r = Math.sin(m + R) * l, u = Math.sin(m + R) * (n ? n / 2 - h : l), t.arc(i - d, s - r, h, m - C, m - E), t.arc(i + u, s - a, h, m - E, m), t.arc(i + d, s + r, h, m, m + E), t.arc(i - u, s + a, h, m + E, m + C), t.closePath();\n                    break;\n                case \"rect\":\n                    if (!g) {\n                        l = Math.SQRT1_2 * p, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\n                        break;\n                    }\n                    m += R;\n                case \"rectRot\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + u, s - a), t.lineTo(i + d, s + r), t.lineTo(i - u, s + a), t.closePath();\n                    break;\n                case \"crossRot\":\n                    m += R;\n                case \"cross\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"star\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a), m += R, d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"line\":\n                    a = n ? n / 2 : Math.cos(m) * p, r = Math.sin(m) * p, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\n                    break;\n                case \"dash\":\n                    t.moveTo(i, s), t.lineTo(i + Math.cos(m) * (n ? n / 2 : p), s + Math.sin(m) * p);\n                    break;\n                case !1:\n                    t.closePath();\n            }\n            t.fill(), e.borderWidth > 0 && t.stroke();\n        }\n    }\n    function Re(t, e, i) {\n        return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;\n    }\n    function Ie(t, e) {\n        t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();\n    }\n    function ze(t) {\n        t.restore();\n    }\n    function Fe(t, e, i, s, n) {\n        if (!e) return t.lineTo(i.x, i.y);\n        if (\"middle\" === n) {\n            const s = (e.x + i.x) / 2;\n            t.lineTo(s, e.y), t.lineTo(s, i.y);\n        } else \"after\" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\n        t.lineTo(i.x, i.y);\n    }\n    function Ve(t, e, i, s) {\n        if (!e) return t.lineTo(i.x, i.y);\n        t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);\n    }\n    function Be(t, e, i, s, n) {\n        if (n.strikethrough || n.underline) {\n            const o = t.measureText(s), a = e - o.actualBoundingBoxLeft, r = e + o.actualBoundingBoxRight, l = i - o.actualBoundingBoxAscent, h = i + o.actualBoundingBoxDescent, c = n.strikethrough ? (l + h) / 2 : h;\n            t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke();\n        }\n    }\n    function We(t, e) {\n        const i = t.fillStyle;\n        t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;\n    }\n    function Ne(t, e, i, o, a, r = {}) {\n        const l = n(e) ? e : [\n            e\n        ], h = r.strokeWidth > 0 && \"\" !== r.strokeColor;\n        let c, d;\n        for(t.save(), t.font = a.string, function(t, e) {\n            e.translation && t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);\n        }(t, r), c = 0; c < l.length; ++c)d = l[c], r.backdrop && We(t, r.backdrop), h && (r.strokeColor && (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);\n        t.restore();\n    }\n    function He(t, e) {\n        const { x: i, y: s, w: n, h: o, radius: a } = e;\n        t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * C, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s);\n    }\n    function je(t, e = [\n        \"\"\n    ], i, s, n = ()=>t[0]) {\n        const o = i || t;\n        void 0 === s && (s = ti(\"_fallback\", t));\n        const a = {\n            [Symbol.toStringTag]: \"Object\",\n            _cacheable: !0,\n            _scopes: t,\n            _rootScopes: o,\n            _fallback: s,\n            _getTarget: n,\n            override: (i)=>je([\n                    i,\n                    ...t\n                ], e, o, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete e._keys, delete t[0][i], !0),\n            get: (i, s)=>qe(i, s, ()=>(function(t, e, i, s) {\n                        let n;\n                        for (const o of e)if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n;\n                    })(s, e, t, i)),\n            getOwnPropertyDescriptor: (t, e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t[0]),\n            has: (t, e)=>ei(t).includes(e),\n            ownKeys: (t)=>ei(t),\n            set (t, e, i) {\n                const s = t._storage || (t._storage = n());\n                return t[e] = s[e] = i, delete t._keys, !0;\n            }\n        });\n    }\n    function $e(t, e, i, s) {\n        const a = {\n            _cacheable: !1,\n            _proxy: t,\n            _context: e,\n            _subProxy: i,\n            _stack: new Set,\n            _descriptors: Ye(t, s),\n            setContext: (e)=>$e(t, e, i, s),\n            override: (n)=>$e(t.override(n), e, i, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete t[i], !0),\n            get: (t, e, i)=>qe(t, e, ()=>(function(t, e, i) {\n                        const { _proxy: s, _context: a, _subProxy: r, _descriptors: l } = t;\n                        let h = s[e];\n                        S(h) && l.isScriptable(e) && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: o, _subProxy: a, _stack: r } = i;\n                            if (r.has(t)) throw new Error(\"Recursion detected: \" + Array.from(r).join(\"->\") + \"->\" + t);\n                            r.add(t);\n                            let l = e(o, a || s);\n                            r.delete(t), Xe(t, l) && (l = Je(n._scopes, n, t, l));\n                            return l;\n                        }(e, h, t, i));\n                        n(h) && h.length && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: a, _subProxy: r, _descriptors: l } = i;\n                            if (void 0 !== a.index && s(t)) return e[a.index % e.length];\n                            if (o(e[0])) {\n                                const i = e, s = n._scopes.filter((t)=>t !== i);\n                                e = [];\n                                for (const o of i){\n                                    const i = Je(s, n, t, o);\n                                    e.push($e(i, a, r && r[t], l));\n                                }\n                            }\n                            return e;\n                        }(e, h, t, l.isIndexable));\n                        Xe(e, h) && (h = $e(h, a, r && r[e], l));\n                        return h;\n                    })(t, e, i)),\n            getOwnPropertyDescriptor: (e, i)=>e._descriptors.allKeys ? Reflect.has(t, i) ? {\n                    enumerable: !0,\n                    configurable: !0\n                } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t),\n            has: (e, i)=>Reflect.has(t, i),\n            ownKeys: ()=>Reflect.ownKeys(t),\n            set: (e, i, s)=>(t[i] = s, delete e[i], !0)\n        });\n    }\n    function Ye(t, e = {\n        scriptable: !0,\n        indexable: !0\n    }) {\n        const { _scriptable: i = e.scriptable, _indexable: s = e.indexable, _allKeys: n = e.allKeys } = t;\n        return {\n            allKeys: n,\n            scriptable: i,\n            indexable: s,\n            isScriptable: S(i) ? i : ()=>i,\n            isIndexable: S(s) ? s : ()=>s\n        };\n    }\n    const Ue = (t, e)=>t ? t + w(e) : e, Xe = (t, e)=>o(e) && \"adapters\" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);\n    function qe(t, e, i) {\n        if (Object.prototype.hasOwnProperty.call(t, e) || \"constructor\" === e) return t[e];\n        const s = i();\n        return t[e] = s, s;\n    }\n    function Ke(t, e, i) {\n        return S(t) ? t(e, i) : t;\n    }\n    const Ge = (t, e)=>!0 === t ? e : \"string\" == typeof t ? M(e, t) : void 0;\n    function Ze(t, e, i, s, n) {\n        for (const o of e){\n            const e = Ge(i, o);\n            if (e) {\n                t.add(e);\n                const o = Ke(e._fallback, i, n);\n                if (void 0 !== o && o !== i && o !== s) return o;\n            } else if (!1 === e && void 0 !== s && i !== s) return null;\n        }\n        return !1;\n    }\n    function Je(t, e, i, s) {\n        const a = e._rootScopes, r = Ke(e._fallback, i, s), l = [\n            ...t,\n            ...a\n        ], h = new Set;\n        h.add(s);\n        let c = Qe(h, l, i, r || i, s);\n        return null !== c && (void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) && je(Array.from(h), [\n            \"\"\n        ], a, r, ()=>(function(t, e, i) {\n                const s = t._getTarget();\n                e in s || (s[e] = {});\n                const a = s[e];\n                if (n(a) && o(i)) return i;\n                return a || {};\n            })(e, i, s));\n    }\n    function Qe(t, e, i, s, n) {\n        for(; i;)i = Ze(t, e, i, s, n);\n        return i;\n    }\n    function ti(t, e) {\n        for (const i of e){\n            if (!i) continue;\n            const e = i[t];\n            if (void 0 !== e) return e;\n        }\n    }\n    function ei(t) {\n        let e = t._keys;\n        return e || (e = t._keys = function(t) {\n            const e = new Set;\n            for (const i of t)for (const t of Object.keys(i).filter((t)=>!t.startsWith(\"_\")))e.add(t);\n            return Array.from(e);\n        }(t._scopes)), e;\n    }\n    function ii(t, e, i, s) {\n        const { iScale: n } = t, { key: o = \"r\" } = this._parsing, a = new Array(s);\n        let r, l, h, c;\n        for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n            r: n.parse(M(c, o), h)\n        };\n        return a;\n    }\n    const si = Number.EPSILON || 1e-14, ni = (t, e)=>e < t.length && !t[e].skip && t[e], oi = (t)=>\"x\" === t ? \"y\" : \"x\";\n    function ai(t, e, i, s) {\n        const n = t.skip ? e : t, o = e, a = i.skip ? e : i, r = q(o, n), l = q(a, o);\n        let h = r / (r + l), c = l / (r + l);\n        h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\n        const d = s * h, u = s * c;\n        return {\n            previous: {\n                x: o.x - d * (a.x - n.x),\n                y: o.y - d * (a.y - n.y)\n            },\n            next: {\n                x: o.x + u * (a.x - n.x),\n                y: o.y + u * (a.y - n.y)\n            }\n        };\n    }\n    function ri(t, e = \"x\") {\n        const i = oi(e), s = t.length, n = Array(s).fill(0), o = Array(s);\n        let a, r, l, h = ni(t, 0);\n        for(a = 0; a < s; ++a)if (r = l, l = h, h = ni(t, a + 1), l) {\n            if (h) {\n                const t = h[e] - l[e];\n                n[a] = 0 !== t ? (h[i] - l[i]) / t : 0;\n            }\n            o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a];\n        }\n        !function(t, e, i) {\n            const s = t.length;\n            let n, o, a, r, l, h = ni(t, 0);\n            for(let c = 0; c < s - 1; ++c)l = h, h = ni(t, c + 1), l && h && (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])));\n        }(t, n, o), function(t, e, i = \"x\") {\n            const s = oi(i), n = t.length;\n            let o, a, r, l = ni(t, 0);\n            for(let h = 0; h < n; ++h){\n                if (a = r, r = l, l = ni(t, h + 1), !r) continue;\n                const n = r[i], c = r[s];\n                a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h]);\n            }\n        }(t, o, e);\n    }\n    function li(t, e, i) {\n        return Math.max(Math.min(t, i), e);\n    }\n    function hi(t, e, i, s, n) {\n        let o, a, r, l;\n        if (e.spanGaps && (t = t.filter((t)=>!t.skip)), \"monotone\" === e.cubicInterpolationMode) ri(t, n);\n        else {\n            let i = s ? t[t.length - 1] : t[0];\n            for(o = 0, a = t.length; o < a; ++o)r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r;\n        }\n        e.capBezierPoints && function(t, e) {\n            let i, s, n, o, a, r = Re(t[0], e);\n            for(i = 0, s = t.length; i < s; ++i)a = o, o = r, r = i < s - 1 && Re(t[i + 1], e), o && (n = t[i], a && (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r && (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)));\n        }(t, i);\n    }\n    const ci = (t)=>0 === t || 1 === t, di = (t, e, i)=>-Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i), ui = (t, e, i)=>Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1, fi = {\n        linear: (t)=>t,\n        easeInQuad: (t)=>t * t,\n        easeOutQuad: (t)=>-t * (t - 2),\n        easeInOutQuad: (t)=>(t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1),\n        easeInCubic: (t)=>t * t * t,\n        easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n        easeInOutCubic: (t)=>(t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\n        easeInQuart: (t)=>t * t * t * t,\n        easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n        easeInOutQuart: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n        easeInQuint: (t)=>t * t * t * t * t,\n        easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n        easeInOutQuint: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\n        easeInSine: (t)=>1 - Math.cos(t * E),\n        easeOutSine: (t)=>Math.sin(t * E),\n        easeInOutSine: (t)=>-0.5 * (Math.cos(C * t) - 1),\n        easeInExpo: (t)=>0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\n        easeOutExpo: (t)=>1 === t ? 1 : 1 - Math.pow(2, -10 * t),\n        easeInOutExpo: (t)=>ci(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\n        easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n        easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n        easeInOutCirc: (t)=>(t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n        easeInElastic: (t)=>ci(t) ? t : di(t, .075, .3),\n        easeOutElastic: (t)=>ci(t) ? t : ui(t, .075, .3),\n        easeInOutElastic (t) {\n            const e = .1125;\n            return ci(t) ? t : t < .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45);\n        },\n        easeInBack (t) {\n            const e = 1.70158;\n            return t * t * ((e + 1) * t - e);\n        },\n        easeOutBack (t) {\n            const e = 1.70158;\n            return (t -= 1) * t * ((e + 1) * t + e) + 1;\n        },\n        easeInOutBack (t) {\n            let e = 1.70158;\n            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);\n        },\n        easeInBounce: (t)=>1 - fi.easeOutBounce(1 - t),\n        easeOutBounce (t) {\n            const e = 7.5625, i = 2.75;\n            return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375;\n        },\n        easeInOutBounce: (t)=>t < .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5\n    };\n    function gi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: t.y + i * (e.y - t.y)\n        };\n    }\n    function pi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: \"middle\" === s ? i < .5 ? t.y : e.y : \"after\" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y\n        };\n    }\n    function mi(t, e, i, s) {\n        const n = {\n            x: t.cp2x,\n            y: t.cp2y\n        }, o = {\n            x: e.cp1x,\n            y: e.cp1y\n        }, a = gi(t, n, i), r = gi(n, o, i), l = gi(o, e, i), h = gi(a, r, i), c = gi(r, l, i);\n        return gi(h, c, i);\n    }\n    const xi = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/, bi = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n    function _i(t, e) {\n        const i = (\"\" + t).match(xi);\n        if (!i || \"normal\" === i[1]) return 1.2 * e;\n        switch(t = +i[2], i[3]){\n            case \"px\":\n                return t;\n            case \"%\":\n                t /= 100;\n        }\n        return e * t;\n    }\n    const yi = (t)=>+t || 0;\n    function vi(t, e) {\n        const i = {}, s = o(e), n = s ? Object.keys(e) : e, a = o(t) ? s ? (i)=>l(t[i], t[e[i]]) : (e)=>t[e] : ()=>t;\n        for (const t of n)i[t] = yi(a(t));\n        return i;\n    }\n    function Mi(t) {\n        return vi(t, {\n            top: \"y\",\n            right: \"x\",\n            bottom: \"y\",\n            left: \"x\"\n        });\n    }\n    function wi(t) {\n        return vi(t, [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]);\n    }\n    function ki(t) {\n        const e = Mi(t);\n        return e.width = e.left + e.right, e.height = e.top + e.bottom, e;\n    }\n    function Si(t, e) {\n        t = t || {}, e = e || ue.font;\n        let i = l(t.size, e.size);\n        \"string\" == typeof i && (i = parseInt(i, 10));\n        let s = l(t.style, e.style);\n        s && !(\"\" + s).match(bi) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n        const n = {\n            family: l(t.family, e.family),\n            lineHeight: _i(l(t.lineHeight, e.lineHeight), i),\n            size: i,\n            style: s,\n            weight: l(t.weight, e.weight),\n            string: \"\"\n        };\n        return n.string = De(n), n;\n    }\n    function Pi(t, e, i, s) {\n        let o, a, r, l = !0;\n        for(o = 0, a = t.length; o < a; ++o)if (r = t[o], void 0 !== r && (void 0 !== e && \"function\" == typeof r && (r = r(e), l = !1), void 0 !== i && n(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return s && !l && (s.cacheable = !1), r;\n    }\n    function Di(t, e, i) {\n        const { min: s, max: n } = t, o = c(e, (n - s) / 2), a = (t, e)=>i && 0 === t ? 0 : t + e;\n        return {\n            min: a(s, -Math.abs(o)),\n            max: a(n, o)\n        };\n    }\n    function Ci(t, e) {\n        return Object.assign(Object.create(t), e);\n    }\n    function Oi(t, e, i) {\n        return t ? function(t, e) {\n            return {\n                x: (i)=>t + t + e - i,\n                setWidth (t) {\n                    e = t;\n                },\n                textAlign: (t)=>\"center\" === t ? t : \"right\" === t ? \"left\" : \"right\",\n                xPlus: (t, e)=>t - e,\n                leftForLtr: (t, e)=>t - e\n            };\n        }(e, i) : {\n            x: (t)=>t,\n            setWidth (t) {},\n            textAlign: (t)=>t,\n            xPlus: (t, e)=>t + e,\n            leftForLtr: (t, e)=>t\n        };\n    }\n    function Ai(t, e) {\n        let i, s;\n        \"ltr\" !== e && \"rtl\" !== e || (i = t.canvas.style, s = [\n            i.getPropertyValue(\"direction\"),\n            i.getPropertyPriority(\"direction\")\n        ], i.setProperty(\"direction\", e, \"important\"), t.prevTextDirection = s);\n    }\n    function Ti(t, e) {\n        void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty(\"direction\", e[0], e[1]));\n    }\n    function Li(t) {\n        return \"angle\" === t ? {\n            between: Z,\n            compare: K,\n            normalize: G\n        } : {\n            between: tt,\n            compare: (t, e)=>t - e,\n            normalize: (t)=>t\n        };\n    }\n    function Ei({ start: t, end: e, count: i, loop: s, style: n }) {\n        return {\n            start: t % i,\n            end: e % i,\n            loop: s && (e - t + 1) % i == 0,\n            style: n\n        };\n    }\n    function Ri(t, e, i) {\n        if (!i) return [\n            t\n        ];\n        const { property: s, start: n, end: o } = i, a = e.length, { compare: r, between: l, normalize: h } = Li(s), { start: c, end: d, loop: u, style: f } = function(t, e, i) {\n            const { property: s, start: n, end: o } = i, { between: a, normalize: r } = Li(s), l = e.length;\n            let h, c, { start: d, end: u, loop: f } = t;\n            if (f) {\n                for(d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h)d--, u--;\n                d %= l, u %= l;\n            }\n            return u < d && (u += l), {\n                start: d,\n                end: u,\n                loop: f,\n                style: t.style\n            };\n        }(t, e, i), g = [];\n        let p, m, x, b = !1, _ = null;\n        const y = ()=>b || l(n, x, p) && 0 !== r(n, x), v = ()=>!b || 0 === r(o, p) || l(o, x, p);\n        for(let t = c, i = c; t <= d; ++t)m = e[t % a], m.skip || (p = h(m[s]), p !== x && (b = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(Ei({\n            start: _,\n            end: t,\n            loop: u,\n            count: a,\n            style: f\n        })), _ = null), i = t, x = p));\n        return null !== _ && g.push(Ei({\n            start: _,\n            end: d,\n            loop: u,\n            count: a,\n            style: f\n        })), g;\n    }\n    function Ii(t, e) {\n        const i = [], s = t.segments;\n        for(let n = 0; n < s.length; n++){\n            const o = Ri(s[n], t.points, e);\n            o.length && i.push(...o);\n        }\n        return i;\n    }\n    function zi(t, e) {\n        const i = t.points, s = t.options.spanGaps, n = i.length;\n        if (!n) return [];\n        const o = !!t._loop, { start: a, end: r } = function(t, e, i, s) {\n            let n = 0, o = e - 1;\n            if (i && !s) for(; n < e && !t[n].skip;)n++;\n            for(; n < e && t[n].skip;)n++;\n            for(n %= e, i && (o += n); o > n && t[o % e].skip;)o--;\n            return o %= e, {\n                start: n,\n                end: o\n            };\n        }(i, n, o, s);\n        if (!0 === s) return Fi(t, [\n            {\n                start: a,\n                end: r,\n                loop: o\n            }\n        ], i, e);\n        return Fi(t, function(t, e, i, s) {\n            const n = t.length, o = [];\n            let a, r = e, l = t[e];\n            for(a = e + 1; a <= i; ++a){\n                const i = t[a % n];\n                i.skip || i.stop ? l.skip || (s = !1, o.push({\n                    start: e % n,\n                    end: (a - 1) % n,\n                    loop: s\n                }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i;\n            }\n            return null !== r && o.push({\n                start: e % n,\n                end: r % n,\n                loop: s\n            }), o;\n        }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e);\n    }\n    function Fi(t, e, i, s) {\n        return s && s.setContext && i ? function(t, e, i, s) {\n            const n = t._chart.getContext(), o = Vi(t.options), { _datasetIndex: a, options: { spanGaps: r } } = t, l = i.length, h = [];\n            let c = o, d = e[0].start, u = d;\n            function f(t, e, s, n) {\n                const o = r ? -1 : 1;\n                if (t !== e) {\n                    for(t += l; i[t % l].skip;)t -= o;\n                    for(; i[e % l].skip;)e += o;\n                    t % l != e % l && (h.push({\n                        start: t % l,\n                        end: e % l,\n                        loop: s,\n                        style: n\n                    }), c = n, d = e % l);\n                }\n            }\n            for (const t of e){\n                d = r ? d : t.start;\n                let e, o = i[d % l];\n                for(u = d + 1; u <= t.end; u++){\n                    const r = i[u % l];\n                    e = Vi(s.setContext(Ci(n, {\n                        type: \"segment\",\n                        p0: o,\n                        p1: r,\n                        p0DataIndex: (u - 1) % l,\n                        p1DataIndex: u % l,\n                        datasetIndex: a\n                    }))), Bi(e, c) && f(d, u - 1, t.loop, c), o = r, c = e;\n                }\n                d < u - 1 && f(d, u - 1, t.loop, c);\n            }\n            return h;\n        }(t, e, i, s) : e;\n    }\n    function Vi(t) {\n        return {\n            backgroundColor: t.backgroundColor,\n            borderCapStyle: t.borderCapStyle,\n            borderDash: t.borderDash,\n            borderDashOffset: t.borderDashOffset,\n            borderJoinStyle: t.borderJoinStyle,\n            borderWidth: t.borderWidth,\n            borderColor: t.borderColor\n        };\n    }\n    function Bi(t, e) {\n        if (!e) return !1;\n        const i = [], s = function(t, e) {\n            return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e;\n        };\n        return JSON.stringify(t, s) !== JSON.stringify(e, s);\n    }\n    var Wi = Object.freeze({\n        __proto__: null,\n        HALF_PI: E,\n        INFINITY: T,\n        PI: C,\n        PITAU: A,\n        QUARTER_PI: R,\n        RAD_PER_DEG: L,\n        TAU: O,\n        TWO_THIRDS_PI: I,\n        _addGrace: Di,\n        _alignPixel: Ae,\n        _alignStartEnd: ft,\n        _angleBetween: Z,\n        _angleDiff: K,\n        _arrayUnique: lt,\n        _attachContext: $e,\n        _bezierCurveTo: Ve,\n        _bezierInterpolation: mi,\n        _boundSegment: Ri,\n        _boundSegments: Ii,\n        _capitalize: w,\n        _computeSegments: zi,\n        _createResolver: je,\n        _decimalPlaces: U,\n        _deprecated: function(t, e, i, s) {\n            void 0 !== e && console.warn(t + ': \"' + i + '\" is deprecated. Please use \"' + s + '\" instead');\n        },\n        _descriptors: Ye,\n        _elementsEqual: f,\n        _factorize: W,\n        _filterBetween: nt,\n        _getParentNode: ge,\n        _getStartAndCountOfVisiblePoints: pt,\n        _int16Range: Q,\n        _isBetween: tt,\n        _isClickEvent: D,\n        _isDomSupported: fe,\n        _isPointInArea: Re,\n        _limitValue: J,\n        _longestText: Oe,\n        _lookup: et,\n        _lookupByKey: it,\n        _measureText: Ce,\n        _merger: m,\n        _mergerIf: _,\n        _normalizeAngle: G,\n        _parseObjectDataRadialScale: ii,\n        _pointInLine: gi,\n        _readValueToProps: vi,\n        _rlookupByKey: st,\n        _scaleRangesChanged: mt,\n        _setMinAndMaxByKey: j,\n        _splitKey: v,\n        _steppedInterpolation: pi,\n        _steppedLineTo: Fe,\n        _textX: gt,\n        _toLeftRightCenter: ut,\n        _updateBezierControlPoints: hi,\n        addRoundedRectPath: He,\n        almostEquals: V,\n        almostWhole: H,\n        callback: d,\n        clearCanvas: Te,\n        clipArea: Ie,\n        clone: g,\n        color: Qt,\n        createContext: Ci,\n        debounce: dt,\n        defined: k,\n        distanceBetweenPoints: q,\n        drawPoint: Le,\n        drawPointLegend: Ee,\n        each: u,\n        easingEffects: fi,\n        finiteOrDefault: r,\n        fontString: function(t, e, i) {\n            return e + \" \" + t + \"px \" + i;\n        },\n        formatNumber: ne,\n        getAngleFromPoint: X,\n        getHoverColor: te,\n        getMaximumSize: we,\n        getRelativePosition: ve,\n        getRtlAdapter: Oi,\n        getStyle: xe,\n        isArray: n,\n        isFinite: a,\n        isFunction: S,\n        isNullOrUndef: s,\n        isNumber: N,\n        isObject: o,\n        isPatternOrGradient: Jt,\n        listenArrayEvents: at,\n        log10: z,\n        merge: x,\n        mergeIf: b,\n        niceNum: B,\n        noop: e,\n        overrideTextDirection: Ai,\n        readUsedSize: Pe,\n        renderText: Ne,\n        requestAnimFrame: ht,\n        resolve: Pi,\n        resolveObjectKey: M,\n        restoreTextDirection: Ti,\n        retinaScale: ke,\n        setsEqual: P,\n        sign: F,\n        splineCurve: ai,\n        splineCurveMonotone: ri,\n        supportsEventListenerOptions: Se,\n        throttled: ct,\n        toDegrees: Y,\n        toDimension: c,\n        toFont: Si,\n        toFontString: De,\n        toLineHeight: _i,\n        toPadding: ki,\n        toPercentage: h,\n        toRadians: $,\n        toTRBL: Mi,\n        toTRBLCorners: wi,\n        uid: i,\n        unclipArea: ze,\n        unlistenArrayEvents: rt,\n        valueOrDefault: l\n    });\n    function Ni(t, e, i, n) {\n        const { controller: o, data: a, _sorted: r } = t, l = o._cachedMeta.iScale, h = t.dataset && t.dataset.options ? t.dataset.options.spanGaps : null;\n        if (l && e === l.axis && \"r\" !== e && r && a.length) {\n            const r = l._reversePixels ? st : it;\n            if (!n) {\n                const n = r(a, e, i);\n                if (h) {\n                    const { vScale: e } = o._cachedMeta, { _parsed: i } = t, a = i.slice(0, n.lo + 1).reverse().findIndex((t)=>!s(t[e.axis]));\n                    n.lo -= Math.max(0, a);\n                    const r = i.slice(n.hi).findIndex((t)=>!s(t[e.axis]));\n                    n.hi += Math.max(0, r);\n                }\n                return n;\n            }\n            if (o._sharedOptions) {\n                const t = a[0], s = \"function\" == typeof t.getRange && t.getRange(e);\n                if (s) {\n                    const t = r(a, e, i - s), n = r(a, e, i + s);\n                    return {\n                        lo: t.lo,\n                        hi: n.hi\n                    };\n                }\n            }\n        }\n        return {\n            lo: 0,\n            hi: a.length - 1\n        };\n    }\n    function Hi(t, e, i, s, n) {\n        const o = t.getSortedVisibleDatasetMetas(), a = i[e];\n        for(let t = 0, i = o.length; t < i; ++t){\n            const { index: i, data: r } = o[t], { lo: l, hi: h } = Ni(o[t], e, a, n);\n            for(let t = l; t <= h; ++t){\n                const e = r[t];\n                e.skip || s(e, i, t);\n            }\n        }\n    }\n    function ji(t, e, i, s, n) {\n        const o = [];\n        if (!n && !t.isPointInArea(e)) return o;\n        return Hi(t, i, e, function(i, a, r) {\n            (n || Re(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({\n                element: i,\n                datasetIndex: a,\n                index: r\n            });\n        }, !0), o;\n    }\n    function $i(t, e, i, s, n, o) {\n        let a = [];\n        const r = function(t) {\n            const e = -1 !== t.indexOf(\"x\"), i = -1 !== t.indexOf(\"y\");\n            return function(t, s) {\n                const n = e ? Math.abs(t.x - s.x) : 0, o = i ? Math.abs(t.y - s.y) : 0;\n                return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n            };\n        }(i);\n        let l = Number.POSITIVE_INFINITY;\n        return Hi(t, i, e, function(i, h, c) {\n            const d = i.inRange(e.x, e.y, n);\n            if (s && !d) return;\n            const u = i.getCenterPoint(n);\n            if (!(!!o || t.isPointInArea(u)) && !d) return;\n            const f = r(e, u);\n            f < l ? (a = [\n                {\n                    element: i,\n                    datasetIndex: h,\n                    index: c\n                }\n            ], l = f) : f === l && a.push({\n                element: i,\n                datasetIndex: h,\n                index: c\n            });\n        }), a;\n    }\n    function Yi(t, e, i, s, n, o) {\n        return o || t.isPointInArea(e) ? \"r\" !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {\n            let n = [];\n            return Hi(t, i, e, function(t, i, o) {\n                const { startAngle: a, endAngle: r } = t.getProps([\n                    \"startAngle\",\n                    \"endAngle\"\n                ], s), { angle: l } = X(t, {\n                    x: e.x,\n                    y: e.y\n                });\n                Z(l, a, r) && n.push({\n                    element: t,\n                    datasetIndex: i,\n                    index: o\n                });\n            }), n;\n        }(t, e, i, n) : [];\n    }\n    function Ui(t, e, i, s, n) {\n        const o = [], a = \"x\" === i ? \"inXRange\" : \"inYRange\";\n        let r = !1;\n        return Hi(t, i, e, (t, s, l)=>{\n            t[a] && t[a](e[i], n) && (o.push({\n                element: t,\n                datasetIndex: s,\n                index: l\n            }), r = r || t.inRange(e.x, e.y, n));\n        }), s && !r ? [] : o;\n    }\n    var Xi = {\n        evaluateInteractionItems: Hi,\n        modes: {\n            index (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"x\", a = i.includeInvisible || !1, r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a), l = [];\n                return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t)=>{\n                    const e = r[0].index, i = t.data[e];\n                    i && !i.skip && l.push({\n                        element: i,\n                        datasetIndex: t.index,\n                        index: e\n                    });\n                }), l) : [];\n            },\n            dataset (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);\n                if (r.length > 0) {\n                    const e = r[0].datasetIndex, i = t.getDatasetMeta(e).data;\n                    r = [];\n                    for(let t = 0; t < i.length; ++t)r.push({\n                        element: i[t],\n                        datasetIndex: e,\n                        index: t\n                    });\n                }\n                return r;\n            },\n            point: (t, e, i, s)=>ji(t, ve(e, t), i.axis || \"xy\", s, i.includeInvisible || !1),\n            nearest (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                return Yi(t, n, o, i.intersect, s, a);\n            },\n            x: (t, e, i, s)=>Ui(t, ve(e, t), \"x\", i.intersect, s),\n            y: (t, e, i, s)=>Ui(t, ve(e, t), \"y\", i.intersect, s)\n        }\n    };\n    const qi = [\n        \"left\",\n        \"top\",\n        \"right\",\n        \"bottom\"\n    ];\n    function Ki(t, e) {\n        return t.filter((t)=>t.pos === e);\n    }\n    function Gi(t, e) {\n        return t.filter((t)=>-1 === qi.indexOf(t.pos) && t.box.axis === e);\n    }\n    function Zi(t, e) {\n        return t.sort((t, i)=>{\n            const s = e ? i : t, n = e ? t : i;\n            return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;\n        });\n    }\n    function Ji(t, e) {\n        const i = function(t) {\n            const e = {};\n            for (const i of t){\n                const { stack: t, pos: s, stackWeight: n } = i;\n                if (!t || !qi.includes(s)) continue;\n                const o = e[t] || (e[t] = {\n                    count: 0,\n                    placed: 0,\n                    weight: 0,\n                    size: 0\n                });\n                o.count++, o.weight += n;\n            }\n            return e;\n        }(t), { vBoxMaxWidth: s, hBoxMaxHeight: n } = e;\n        let o, a, r;\n        for(o = 0, a = t.length; o < a; ++o){\n            r = t[o];\n            const { fullSize: a } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;\n            r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight);\n        }\n        return i;\n    }\n    function Qi(t, e, i, s) {\n        return Math.max(t[i], e[i]) + Math.max(t[s], e[s]);\n    }\n    function ts(t, e) {\n        t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);\n    }\n    function es(t, e, i, s) {\n        const { pos: n, box: a } = i, r = t.maxPadding;\n        if (!o(n)) {\n            i.size && (t[n] -= i.size);\n            const e = s[i.stack] || {\n                size: 0,\n                count: 1\n            };\n            e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[n] += i.size;\n        }\n        a.getPadding && ts(r, a.getPadding());\n        const l = Math.max(0, e.outerWidth - Qi(r, t, \"left\", \"right\")), h = Math.max(0, e.outerHeight - Qi(r, t, \"top\", \"bottom\")), c = l !== t.w, d = h !== t.h;\n        return t.w = l, t.h = h, i.horizontal ? {\n            same: c,\n            other: d\n        } : {\n            same: d,\n            other: c\n        };\n    }\n    function is(t, e) {\n        const i = e.maxPadding;\n        function s(t) {\n            const s = {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            };\n            return t.forEach((t)=>{\n                s[t] = Math.max(e[t], i[t]);\n            }), s;\n        }\n        return s(t ? [\n            \"left\",\n            \"right\"\n        ] : [\n            \"top\",\n            \"bottom\"\n        ]);\n    }\n    function ss(t, e, i, s) {\n        const n = [];\n        let o, a, r, l, h, c;\n        for(o = 0, a = t.length, h = 0; o < a; ++o){\n            r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));\n            const { same: a, other: d } = es(e, i, r, s);\n            h |= a && n.length, c = c || d, l.fullSize || n.push(r);\n        }\n        return h && ss(n, e, i, s) || c;\n    }\n    function ns(t, e, i, s, n) {\n        t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n;\n    }\n    function os(t, e, i, s) {\n        const n = i.padding;\n        let { x: o, y: a } = e;\n        for (const r of t){\n            const t = r.box, l = s[r.stack] || {\n                count: 1,\n                placed: 0,\n                weight: 1\n            }, h = r.stackWeight / l.weight || 1;\n            if (r.horizontal) {\n                const s = e.w * h, o = l.size || t.height;\n                k(l.start) && (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom;\n            } else {\n                const s = e.h * h, a = l.size || t.width;\n                k(l.start) && (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right;\n            }\n        }\n        e.x = o, e.y = a;\n    }\n    var as = {\n        addBox (t, e) {\n            t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || \"top\", e.weight = e.weight || 0, e._layers = e._layers || function() {\n                return [\n                    {\n                        z: 0,\n                        draw (t) {\n                            e.draw(t);\n                        }\n                    }\n                ];\n            }, t.boxes.push(e);\n        },\n        removeBox (t, e) {\n            const i = t.boxes ? t.boxes.indexOf(e) : -1;\n            -1 !== i && t.boxes.splice(i, 1);\n        },\n        configure (t, e, i) {\n            e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;\n        },\n        update (t, e, i, s) {\n            if (!t) return;\n            const n = ki(t.options.layout.padding), o = Math.max(e - n.width, 0), a = Math.max(i - n.height, 0), r = function(t) {\n                const e = function(t) {\n                    const e = [];\n                    let i, s, n, o, a, r;\n                    for(i = 0, s = (t || []).length; i < s; ++i)n = t[i], ({ position: o, options: { stack: a, stackWeight: r = 1 } } = n), e.push({\n                        index: i,\n                        box: n,\n                        pos: o,\n                        horizontal: n.isHorizontal(),\n                        weight: n.weight,\n                        stack: a && o + a,\n                        stackWeight: r\n                    });\n                    return e;\n                }(t), i = Zi(e.filter((t)=>t.box.fullSize), !0), s = Zi(Ki(e, \"left\"), !0), n = Zi(Ki(e, \"right\")), o = Zi(Ki(e, \"top\"), !0), a = Zi(Ki(e, \"bottom\")), r = Gi(e, \"x\"), l = Gi(e, \"y\");\n                return {\n                    fullSize: i,\n                    leftAndTop: s.concat(o),\n                    rightAndBottom: n.concat(l).concat(a).concat(r),\n                    chartArea: Ki(e, \"chartArea\"),\n                    vertical: s.concat(n).concat(l),\n                    horizontal: o.concat(a).concat(r)\n                };\n            }(t.boxes), l = r.vertical, h = r.horizontal;\n            u(t.boxes, (t)=>{\n                \"function\" == typeof t.beforeLayout && t.beforeLayout();\n            });\n            const c = l.reduce((t, e)=>e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1, d = Object.freeze({\n                outerWidth: e,\n                outerHeight: i,\n                padding: n,\n                availableWidth: o,\n                availableHeight: a,\n                vBoxMaxWidth: o / 2 / c,\n                hBoxMaxHeight: a / 2\n            }), f = Object.assign({}, n);\n            ts(f, ki(s));\n            const g = Object.assign({\n                maxPadding: f,\n                w: o,\n                h: a,\n                x: n.left,\n                y: n.top\n            }, n), p = Ji(l.concat(h), d);\n            ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) && ss(l, g, d, p), function(t) {\n                const e = t.maxPadding;\n                function i(i) {\n                    const s = Math.max(e[i] - t[i], 0);\n                    return t[i] += s, s;\n                }\n                t.y += i(\"top\"), t.x += i(\"left\"), i(\"right\"), i(\"bottom\");\n            }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {\n                left: g.left,\n                top: g.top,\n                right: g.left + g.w,\n                bottom: g.top + g.h,\n                height: g.h,\n                width: g.w\n            }, u(r.chartArea, (e)=>{\n                const i = e.box;\n                Object.assign(i, t.chartArea), i.update(g.w, g.h, {\n                    left: 0,\n                    top: 0,\n                    right: 0,\n                    bottom: 0\n                });\n            });\n        }\n    };\n    class rs {\n        acquireContext(t, e) {}\n        releaseContext(t) {\n            return !1;\n        }\n        addEventListener(t, e, i) {}\n        removeEventListener(t, e, i) {}\n        getDevicePixelRatio() {\n            return 1;\n        }\n        getMaximumSize(t, e, i, s) {\n            return e = Math.max(0, e || t.width), i = i || t.height, {\n                width: e,\n                height: Math.max(0, s ? Math.floor(e / s) : i)\n            };\n        }\n        isAttached(t) {\n            return !0;\n        }\n        updateConfig(t) {}\n    }\n    class ls extends rs {\n        acquireContext(t) {\n            return t && t.getContext && t.getContext(\"2d\") || null;\n        }\n        updateConfig(t) {\n            t.options.animation = !1;\n        }\n    }\n    const hs = \"$chartjs\", cs = {\n        touchstart: \"mousedown\",\n        touchmove: \"mousemove\",\n        touchend: \"mouseup\",\n        pointerenter: \"mouseenter\",\n        pointerdown: \"mousedown\",\n        pointermove: \"mousemove\",\n        pointerup: \"mouseup\",\n        pointerleave: \"mouseout\",\n        pointerout: \"mouseout\"\n    }, ds = (t)=>null === t || \"\" === t;\n    const us = !!Se && {\n        passive: !0\n    };\n    function fs(t, e, i) {\n        t && t.canvas && t.canvas.removeEventListener(e, i, us);\n    }\n    function gs(t, e) {\n        for (const i of t)if (i === e || i.contains(e)) return !0;\n    }\n    function ps(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.addedNodes, s), e = e && !gs(i.removedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    function ms(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.removedNodes, s), e = e && !gs(i.addedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    const xs = new Map;\n    let bs = 0;\n    function _s() {\n        const t = window.devicePixelRatio;\n        t !== bs && (bs = t, xs.forEach((e, i)=>{\n            i.currentDevicePixelRatio !== t && e();\n        }));\n    }\n    function ys(t, e, i) {\n        const s = t.canvas, n = s && ge(s);\n        if (!n) return;\n        const o = ct((t, e)=>{\n            const s = n.clientWidth;\n            i(t, e), s < n.clientWidth && i();\n        }, window), a = new ResizeObserver((t)=>{\n            const e = t[0], i = e.contentRect.width, s = e.contentRect.height;\n            0 === i && 0 === s || o(i, s);\n        });\n        return a.observe(n), function(t, e) {\n            xs.size || window.addEventListener(\"resize\", _s), xs.set(t, e);\n        }(t, o), a;\n    }\n    function vs(t, e, i) {\n        i && i.disconnect(), \"resize\" === e && function(t) {\n            xs.delete(t), xs.size || window.removeEventListener(\"resize\", _s);\n        }(t);\n    }\n    function Ms(t, e, i) {\n        const s = t.canvas, n = ct((e)=>{\n            null !== t.ctx && i(function(t, e) {\n                const i = cs[t.type] || t.type, { x: s, y: n } = ve(t, e);\n                return {\n                    type: i,\n                    chart: e,\n                    native: t,\n                    x: void 0 !== s ? s : null,\n                    y: void 0 !== n ? n : null\n                };\n            }(e, t));\n        }, t);\n        return function(t, e, i) {\n            t && t.addEventListener(e, i, us);\n        }(s, e, n), n;\n    }\n    class ws extends rs {\n        acquireContext(t, e) {\n            const i = t && t.getContext && t.getContext(\"2d\");\n            return i && i.canvas === t ? (function(t, e) {\n                const i = t.style, s = t.getAttribute(\"height\"), n = t.getAttribute(\"width\");\n                if (t[hs] = {\n                    initial: {\n                        height: s,\n                        width: n,\n                        style: {\n                            display: i.display,\n                            height: i.height,\n                            width: i.width\n                        }\n                    }\n                }, i.display = i.display || \"block\", i.boxSizing = i.boxSizing || \"border-box\", ds(n)) {\n                    const e = Pe(t, \"width\");\n                    void 0 !== e && (t.width = e);\n                }\n                if (ds(s)) {\n                    if (\"\" === t.style.height) t.height = t.width / (e || 2);\n                    else {\n                        const e = Pe(t, \"height\");\n                        void 0 !== e && (t.height = e);\n                    }\n                }\n            }(t, e), i) : null;\n        }\n        releaseContext(t) {\n            const e = t.canvas;\n            if (!e[hs]) return !1;\n            const i = e[hs].initial;\n            [\n                \"height\",\n                \"width\"\n            ].forEach((t)=>{\n                const n = i[t];\n                s(n) ? e.removeAttribute(t) : e.setAttribute(t, n);\n            });\n            const n = i.style || {};\n            return Object.keys(n).forEach((t)=>{\n                e.style[t] = n[t];\n            }), e.width = e.width, delete e[hs], !0;\n        }\n        addEventListener(t, e, i) {\n            this.removeEventListener(t, e);\n            const s = t.$proxies || (t.$proxies = {}), n = {\n                attach: ps,\n                detach: ms,\n                resize: ys\n            }[e] || Ms;\n            s[e] = n(t, e, i);\n        }\n        removeEventListener(t, e) {\n            const i = t.$proxies || (t.$proxies = {}), s = i[e];\n            if (!s) return;\n            (({\n                attach: vs,\n                detach: vs,\n                resize: vs\n            })[e] || fs)(t, e, s), i[e] = void 0;\n        }\n        getDevicePixelRatio() {\n            return window.devicePixelRatio;\n        }\n        getMaximumSize(t, e, i, s) {\n            return we(t, e, i, s);\n        }\n        isAttached(t) {\n            const e = t && ge(t);\n            return !(!e || !e.isConnected);\n        }\n    }\n    function ks(t) {\n        return !fe() || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? ls : ws;\n    }\n    var Ss = Object.freeze({\n        __proto__: null,\n        BasePlatform: rs,\n        BasicPlatform: ls,\n        DomPlatform: ws,\n        _detectPlatform: ks\n    });\n    const Ps = \"transparent\", Ds = {\n        boolean: (t, e, i)=>i > .5 ? e : t,\n        color (t, e, i) {\n            const s = Qt(t || Ps), n = s.valid && Qt(e || Ps);\n            return n && n.valid ? n.mix(s, i).hexString() : e;\n        },\n        number: (t, e, i)=>t + (e - t) * i\n    };\n    class Cs {\n        constructor(t, e, i, s){\n            const n = e[i];\n            s = Pi([\n                t.to,\n                s,\n                n,\n                t.from\n            ]);\n            const o = Pi([\n                t.from,\n                n,\n                s\n            ]);\n            this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;\n        }\n        active() {\n            return this._active;\n        }\n        update(t, e, i) {\n            if (this._active) {\n                this._notify(!1);\n                const s = this._target[this._prop], n = i - this._start, o = this._duration - n;\n                this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([\n                    t.to,\n                    e,\n                    s,\n                    t.from\n                ]), this._from = Pi([\n                    t.from,\n                    s,\n                    e\n                ]);\n            }\n        }\n        cancel() {\n            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n        }\n        tick(t) {\n            const e = t - this._start, i = this._duration, s = this._prop, n = this._from, o = this._loop, a = this._to;\n            let r;\n            if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);\n            e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r));\n        }\n        wait() {\n            const t = this._promises || (this._promises = []);\n            return new Promise((e, i)=>{\n                t.push({\n                    res: e,\n                    rej: i\n                });\n            });\n        }\n        _notify(t) {\n            const e = t ? \"res\" : \"rej\", i = this._promises || [];\n            for(let t = 0; t < i.length; t++)i[t][e]();\n        }\n    }\n    class Os {\n        constructor(t, e){\n            this._chart = t, this._properties = new Map, this.configure(e);\n        }\n        configure(t) {\n            if (!o(t)) return;\n            const e = Object.keys(ue.animation), i = this._properties;\n            Object.getOwnPropertyNames(t).forEach((s)=>{\n                const a = t[s];\n                if (!o(a)) return;\n                const r = {};\n                for (const t of e)r[t] = a[t];\n                (n(a.properties) && a.properties || [\n                    s\n                ]).forEach((t)=>{\n                    t !== s && i.has(t) || i.set(t, r);\n                });\n            });\n        }\n        _animateOptions(t, e) {\n            const i = e.options, s = function(t, e) {\n                if (!e) return;\n                let i = t.options;\n                if (!i) return void (t.options = e);\n                i.$shared && (t.options = i = Object.assign({}, i, {\n                    $shared: !1,\n                    $animations: {}\n                }));\n                return i;\n            }(t, i);\n            if (!s) return [];\n            const n = this._createAnimations(s, i);\n            return i.$shared && (function(t, e) {\n                const i = [], s = Object.keys(e);\n                for(let e = 0; e < s.length; e++){\n                    const n = t[s[e]];\n                    n && n.active() && i.push(n.wait());\n                }\n                return Promise.all(i);\n            })(t.options.$animations, i).then(()=>{\n                t.options = i;\n            }, ()=>{}), n;\n        }\n        _createAnimations(t, e) {\n            const i = this._properties, s = [], n = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now();\n            let r;\n            for(r = o.length - 1; r >= 0; --r){\n                const l = o[r];\n                if (\"$\" === l.charAt(0)) continue;\n                if (\"options\" === l) {\n                    s.push(...this._animateOptions(t, e));\n                    continue;\n                }\n                const h = e[l];\n                let c = n[l];\n                const d = i.get(l);\n                if (c) {\n                    if (d && c.active()) {\n                        c.update(d, h, a);\n                        continue;\n                    }\n                    c.cancel();\n                }\n                d && d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h;\n            }\n            return s;\n        }\n        update(t, e) {\n            if (0 === this._properties.size) return void Object.assign(t, e);\n            const i = this._createAnimations(t, e);\n            return i.length ? (bt.add(this._chart, i), !0) : void 0;\n        }\n    }\n    function As(t, e) {\n        const i = t && t.options || {}, s = i.reverse, n = void 0 === i.min ? e : 0, o = void 0 === i.max ? e : 0;\n        return {\n            start: s ? o : n,\n            end: s ? n : o\n        };\n    }\n    function Ts(t, e) {\n        const i = [], s = t._getSortedDatasetMetas(e);\n        let n, o;\n        for(n = 0, o = s.length; n < o; ++n)i.push(s[n].index);\n        return i;\n    }\n    function Ls(t, e, i, s = {}) {\n        const n = t.keys, o = \"single\" === s.mode;\n        let r, l, h, c;\n        if (null === e) return;\n        let d = !1;\n        for(r = 0, l = n.length; r < l; ++r){\n            if (h = +n[r], h === i) {\n                if (d = !0, s.all) continue;\n                break;\n            }\n            c = t.values[h], a(c) && (o || 0 === e || F(e) === F(c)) && (e += c);\n        }\n        return d || s.all ? e : 0;\n    }\n    function Es(t, e) {\n        const i = t && t.options.stacked;\n        return i || void 0 === i && void 0 !== e.stack;\n    }\n    function Rs(t, e, i) {\n        const s = t[e] || (t[e] = {});\n        return s[i] || (s[i] = {});\n    }\n    function Is(t, e, i, s) {\n        for (const n of e.getMatchingVisibleMetas(s).reverse()){\n            const e = t[n.index];\n            if (i && e > 0 || !i && e < 0) return n.index;\n        }\n        return null;\n    }\n    function zs(t, e) {\n        const { chart: i, _cachedMeta: s } = t, n = i._stacks || (i._stacks = {}), { iScale: o, vScale: a, index: r } = s, l = o.axis, h = a.axis, c = function(t, e, i) {\n            return `${t.id}.${e.id}.${i.stack || i.type}`;\n        }(o, a, s), d = e.length;\n        let u;\n        for(let t = 0; t < d; ++t){\n            const i = e[t], { [l]: o, [h]: d } = i;\n            u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);\n            (u._visualValues || (u._visualValues = {}))[r] = d;\n        }\n    }\n    function Fs(t, e) {\n        const i = t.scales;\n        return Object.keys(i).filter((t)=>i[t].axis === e).shift();\n    }\n    function Vs(t, e) {\n        const i = t.controller.index, s = t.vScale && t.vScale.axis;\n        if (s) {\n            e = e || t._parsed;\n            for (const t of e){\n                const e = t._stacks;\n                if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\n                delete e[s][i], void 0 !== e[s]._visualValues && void 0 !== e[s]._visualValues[i] && delete e[s]._visualValues[i];\n            }\n        }\n    }\n    const Bs = (t)=>\"reset\" === t || \"none\" === t, Ws = (t, e)=>e ? t : Object.assign({}, t);\n    class Ns {\n        static defaults = {};\n        static datasetElementType = null;\n        static dataElementType = null;\n        constructor(t, e){\n            this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();\n        }\n        initialize() {\n            const t = this._cachedMeta;\n            this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n        updateIndex(t) {\n            this.index !== t && Vs(this._cachedMeta), this.index = t;\n        }\n        linkScales() {\n            const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (t, e, i, s)=>\"x\" === t ? e : \"r\" === t ? s : i, n = e.xAxisID = l(i.xAxisID, Fs(t, \"x\")), o = e.yAxisID = l(i.yAxisID, Fs(t, \"y\")), a = e.rAxisID = l(i.rAxisID, Fs(t, \"r\")), r = e.indexAxis, h = e.iAxisID = s(r, n, o, a), c = e.vAxisID = s(r, o, n, a);\n            e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);\n        }\n        getDataset() {\n            return this.chart.data.datasets[this.index];\n        }\n        getMeta() {\n            return this.chart.getDatasetMeta(this.index);\n        }\n        getScaleForId(t) {\n            return this.chart.scales[t];\n        }\n        _getOtherScale(t) {\n            const e = this._cachedMeta;\n            return t === e.iScale ? e.vScale : e.iScale;\n        }\n        reset() {\n            this._update(\"reset\");\n        }\n        _destroy() {\n            const t = this._cachedMeta;\n            this._data && rt(this._data, this), t._stacked && Vs(t);\n        }\n        _dataCheck() {\n            const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;\n            if (o(e)) {\n                const t = this._cachedMeta;\n                this._data = function(t, e) {\n                    const { iScale: i, vScale: s } = e, n = \"x\" === i.axis ? \"x\" : \"y\", o = \"x\" === s.axis ? \"x\" : \"y\", a = Object.keys(t), r = new Array(a.length);\n                    let l, h, c;\n                    for(l = 0, h = a.length; l < h; ++l)c = a[l], r[l] = {\n                        [n]: c,\n                        [o]: t[c]\n                    };\n                    return r;\n                }(e, t);\n            } else if (i !== e) {\n                if (i) {\n                    rt(i, this);\n                    const t = this._cachedMeta;\n                    Vs(t), t._parsed = [];\n                }\n                e && Object.isExtensible(e) && at(e, this), this._syncList = [], this._data = e;\n            }\n        }\n        addElements() {\n            const t = this._cachedMeta;\n            this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType);\n        }\n        buildOrUpdateElements(t) {\n            const e = this._cachedMeta, i = this.getDataset();\n            let s = !1;\n            this._dataCheck();\n            const n = e._stacked;\n            e._stacked = Es(e.vScale, e), e.stack !== i.stack && (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && (zs(this, e._parsed), e._stacked = Es(e.vScale, e));\n        }\n        configure() {\n            const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0);\n            this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n        }\n        parse(t, e) {\n            const { _cachedMeta: i, _data: s } = this, { iScale: a, _stacked: r } = i, l = a.axis;\n            let h, c, d, u = 0 === t && e === s.length || i._sorted, f = t > 0 && i._parsed[t - 1];\n            if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;\n            else {\n                d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);\n                const a = ()=>null === c[l] || f && c[l] < f[l];\n                for(h = 0; h < e; ++h)i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);\n                i._sorted = u;\n            }\n            r && zs(this, d);\n        }\n        parsePrimitiveData(t, e, i, s) {\n            const { iScale: n, vScale: o } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);\n            let d, u, f;\n            for(d = 0, u = s; d < u; ++d)f = d + i, c[d] = {\n                [a]: h || n.parse(l[f], f),\n                [r]: o.parse(e[f], f)\n            };\n            return c;\n        }\n        parseArrayData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, a = new Array(s);\n            let r, l, h, c;\n            for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n                x: n.parse(c[0], h),\n                y: o.parse(c[1], h)\n            };\n            return a;\n        }\n        parseObjectData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = new Array(s);\n            let h, c, d, u;\n            for(h = 0, c = s; h < c; ++h)d = h + i, u = e[d], l[h] = {\n                x: n.parse(M(u, a), d),\n                y: o.parse(M(u, r), d)\n            };\n            return l;\n        }\n        getParsed(t) {\n            return this._cachedMeta._parsed[t];\n        }\n        getDataElement(t) {\n            return this._cachedMeta.data[t];\n        }\n        applyStack(t, e, i) {\n            const s = this.chart, n = this._cachedMeta, o = e[t.axis];\n            return Ls({\n                keys: Ts(s, !0),\n                values: e._stacks[t.axis]._visualValues\n            }, o, n.index, {\n                mode: i\n            });\n        }\n        updateRangeFromParsed(t, e, i, s) {\n            const n = i[e.axis];\n            let o = null === n ? NaN : n;\n            const a = s && i._stacks[e.axis];\n            s && a && (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);\n        }\n        getMinMax(t, e) {\n            const i = this._cachedMeta, s = i._parsed, n = i._sorted && t === i.iScale, o = s.length, r = this._getOtherScale(t), l = ((t, e, i)=>t && !e.hidden && e._stacked && {\n                    keys: Ts(i, !0),\n                    values: null\n                })(e, i, this.chart), h = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            }, { min: c, max: d } = function(t) {\n                const { min: e, max: i, minDefined: s, maxDefined: n } = t.getUserBounds();\n                return {\n                    min: s ? e : Number.NEGATIVE_INFINITY,\n                    max: n ? i : Number.POSITIVE_INFINITY\n                };\n            }(r);\n            let u, f;\n            function g() {\n                f = s[u];\n                const e = f[r.axis];\n                return !a(f[t.axis]) || c > e || d < e;\n            }\n            for(u = 0; u < o && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\n            if (n) {\n                for(u = o - 1; u >= 0; --u)if (!g()) {\n                    this.updateRangeFromParsed(h, t, f, l);\n                    break;\n                }\n            }\n            return h;\n        }\n        getAllParsedValues(t) {\n            const e = this._cachedMeta._parsed, i = [];\n            let s, n, o;\n            for(s = 0, n = e.length; s < n; ++s)o = e[s][t.axis], a(o) && i.push(o);\n            return i;\n        }\n        getMaxOverflow() {\n            return !1;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = e.iScale, s = e.vScale, n = this.getParsed(t);\n            return {\n                label: i ? \"\" + i.getLabelForValue(n[i.axis]) : \"\",\n                value: s ? \"\" + s.getLabelForValue(n[s.axis]) : \"\"\n            };\n        }\n        _update(t) {\n            const e = this._cachedMeta;\n            this.update(t || \"default\"), e._clip = function(t) {\n                let e, i, s, n;\n                return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {\n                    top: e,\n                    right: i,\n                    bottom: s,\n                    left: n,\n                    disabled: !1 === t\n                };\n            }(l(this.options.clip, function(t, e, i) {\n                if (!1 === i) return !1;\n                const s = As(t, i), n = As(e, i);\n                return {\n                    top: n.end,\n                    right: s.end,\n                    bottom: n.start,\n                    left: s.start\n                };\n            }(e.xScale, e.yScale, this.getMaxOverflow())));\n        }\n        update(t) {}\n        draw() {\n            const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], n = e.chartArea, o = [], a = this._drawStart || 0, r = this._drawCount || s.length - a, l = this.options.drawActiveElementsOnTop;\n            let h;\n            for(i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h){\n                const e = s[h];\n                e.hidden || (e.active && l ? o.push(e) : e.draw(t, n));\n            }\n            for(h = 0; h < o.length; ++h)o[h].draw(t, n);\n        }\n        getStyle(t, e) {\n            const i = e ? \"active\" : \"default\";\n            return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);\n        }\n        getContext(t, e, i) {\n            const s = this.getDataset();\n            let n;\n            if (t >= 0 && t < this._cachedMeta.data.length) {\n                const e = this._cachedMeta.data[t];\n                n = e.$context || (e.$context = function(t, e, i) {\n                    return Ci(t, {\n                        active: !1,\n                        dataIndex: e,\n                        parsed: void 0,\n                        raw: void 0,\n                        element: i,\n                        index: e,\n                        mode: \"default\",\n                        type: \"data\"\n                    });\n                }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;\n            } else n = this.$context || (this.$context = function(t, e) {\n                return Ci(t, {\n                    active: !1,\n                    dataset: void 0,\n                    datasetIndex: e,\n                    index: e,\n                    mode: \"default\",\n                    type: \"dataset\"\n                });\n            }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\n            return n.active = !!e, n.mode = i, n;\n        }\n        resolveDatasetElementOptions(t) {\n            return this._resolveElementOptions(this.datasetElementType.id, t);\n        }\n        resolveDataElementOptions(t, e) {\n            return this._resolveElementOptions(this.dataElementType.id, e, t);\n        }\n        _resolveElementOptions(t, e = \"default\", i) {\n            const s = \"active\" === e, n = this._cachedDataOpts, o = t + \"-\" + e, a = n[o], r = this.enableOptionSharing && k(i);\n            if (a) return Ws(a, r);\n            const l = this.chart.config, h = l.datasetElementScopeKeys(this._type, t), c = s ? [\n                `${t}Hover`,\n                \"hover\",\n                t,\n                \"\"\n            ] : [\n                t,\n                \"\"\n            ], d = l.getOptionScopes(this.getDataset(), h), u = Object.keys(ue.elements[t]), f = l.resolveNamedOptions(d, u, ()=>this.getContext(i, s, e), c);\n            return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f;\n        }\n        _resolveAnimations(t, e, i) {\n            const s = this.chart, n = this._cachedDataOpts, o = `animation-${e}`, a = n[o];\n            if (a) return a;\n            let r;\n            if (!1 !== s.options.animation) {\n                const s = this.chart.config, n = s.datasetAnimationScopeKeys(this._type, e), o = s.getOptionScopes(this.getDataset(), n);\n                r = s.createResolver(o, this.getContext(t, i, e));\n            }\n            const l = new Os(s, r && r.animations);\n            return r && r._cacheable && (n[o] = Object.freeze(l)), l;\n        }\n        getSharedOptions(t) {\n            if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n        }\n        includeOptions(t, e) {\n            return !e || Bs(t) || this.chart._animationsDisabled;\n        }\n        _getSharedOptions(t, e) {\n            const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, n = this.getSharedOptions(i), o = this.includeOptions(e, n) || n !== s;\n            return this.updateSharedOptions(n, e, i), {\n                sharedOptions: n,\n                includeOptions: o\n            };\n        }\n        updateElement(t, e, i, s) {\n            Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);\n        }\n        updateSharedOptions(t, e, i) {\n            t && !Bs(e) && this._resolveAnimations(void 0, e).update(t, i);\n        }\n        _setStyle(t, e, i, s) {\n            t.active = s;\n            const n = this.getStyle(e, s);\n            this._resolveAnimations(e, i, s).update(t, {\n                options: !s && this.getSharedOptions(n) || n\n            });\n        }\n        removeHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !1);\n        }\n        setHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !0);\n        }\n        _removeDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !1);\n        }\n        _setDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !0);\n        }\n        _resyncElements(t) {\n            const e = this._data, i = this._cachedMeta.data;\n            for (const [t, e, i] of this._syncList)this[t](e, i);\n            this._syncList = [];\n            const s = i.length, n = e.length, o = Math.min(n, s);\n            o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);\n        }\n        _insertElements(t, e, i = !0) {\n            const s = this._cachedMeta, n = s.data, o = t + e;\n            let a;\n            const r = (t)=>{\n                for(t.length += e, a = t.length - 1; a >= o; a--)t[a] = t[a - e];\n            };\n            for(r(n), a = t; a < o; ++a)n[a] = new this.dataElementType;\n            this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, \"reset\");\n        }\n        updateElements(t, e, i, s) {}\n        _removeElements(t, e) {\n            const i = this._cachedMeta;\n            if (this._parsing) {\n                const s = i._parsed.splice(t, e);\n                i._stacked && Vs(i, s);\n            }\n            i.data.splice(t, e);\n        }\n        _sync(t) {\n            if (this._parsing) this._syncList.push(t);\n            else {\n                const [e, i, s] = t;\n                this[e](i, s);\n            }\n            this.chart._dataChanges.push([\n                this.index,\n                ...t\n            ]);\n        }\n        _onDataPush() {\n            const t = arguments.length;\n            this._sync([\n                \"_insertElements\",\n                this.getDataset().data.length - t,\n                t\n            ]);\n        }\n        _onDataPop() {\n            this._sync([\n                \"_removeElements\",\n                this._cachedMeta.data.length - 1,\n                1\n            ]);\n        }\n        _onDataShift() {\n            this._sync([\n                \"_removeElements\",\n                0,\n                1\n            ]);\n        }\n        _onDataSplice(t, e) {\n            e && this._sync([\n                \"_removeElements\",\n                t,\n                e\n            ]);\n            const i = arguments.length - 2;\n            i && this._sync([\n                \"_insertElements\",\n                t,\n                i\n            ]);\n        }\n        _onDataUnshift() {\n            this._sync([\n                \"_insertElements\",\n                0,\n                arguments.length\n            ]);\n        }\n    }\n    class Hs {\n        static defaults = {};\n        static defaultRoutes = void 0;\n        x;\n        y;\n        active = !1;\n        options;\n        $animations;\n        tooltipPosition(t) {\n            const { x: e, y: i } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: i\n            };\n        }\n        hasValue() {\n            return N(this.x) && N(this.y);\n        }\n        getProps(t, e) {\n            const i = this.$animations;\n            if (!e || !i) return this;\n            const s = {};\n            return t.forEach((t)=>{\n                s[t] = i[t] && i[t].active() ? i[t]._to : this[t];\n            }), s;\n        }\n    }\n    function js(t, e) {\n        const i = t.options.ticks, n = function(t) {\n            const e = t.options.offset, i = t._tickSize(), s = t._length / i + (e ? 0 : 1), n = t._maxLength / i;\n            return Math.floor(Math.min(s, n));\n        }(t), o = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? function(t) {\n            const e = [];\n            let i, s;\n            for(i = 0, s = t.length; i < s; i++)t[i].major && e.push(i);\n            return e;\n        }(e) : [], r = a.length, l = a[0], h = a[r - 1], c = [];\n        if (r > o) return function(t, e, i, s) {\n            let n, o = 0, a = i[0];\n            for(s = Math.ceil(s), n = 0; n < t.length; n++)n === a && (e.push(t[n]), o++, a = i[o * s]);\n        }(e, c, a, r / o), c;\n        const d = function(t, e, i) {\n            const s = function(t) {\n                const e = t.length;\n                let i, s;\n                if (e < 2) return !1;\n                for(s = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== s) return !1;\n                return s;\n            }(t), n = e.length / i;\n            if (!s) return Math.max(n, 1);\n            const o = W(s);\n            for(let t = 0, e = o.length - 1; t < e; t++){\n                const e = o[t];\n                if (e > n) return e;\n            }\n            return Math.max(n, 1);\n        }(a, e, o);\n        if (r > 0) {\n            let t, i;\n            const n = r > 1 ? Math.round((h - l) / (r - 1)) : null;\n            for($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t < i; t++)$s(e, c, d, a[t], a[t + 1]);\n            return $s(e, c, d, h, s(n) ? e.length : h + n), c;\n        }\n        return $s(e, c, d), c;\n    }\n    function $s(t, e, i, s, n) {\n        const o = l(s, 0), a = Math.min(l(n, t.length), t.length);\n        let r, h, c, d = 0;\n        for(i = Math.ceil(i), n && (r = n - s, i = r / Math.floor(r / i)), c = o; c < 0;)d++, c = Math.round(o + d * i);\n        for(h = Math.max(o, 0); h < a; h++)h === c && (e.push(t[h]), d++, c = Math.round(o + d * i));\n    }\n    const Ys = (t, e, i)=>\"top\" === e || \"left\" === e ? t[e] + i : t[e] - i, Us = (t, e)=>Math.min(e || t, t);\n    function Xs(t, e) {\n        const i = [], s = t.length / e, n = t.length;\n        let o = 0;\n        for(; o < n; o += s)i.push(t[Math.floor(o)]);\n        return i;\n    }\n    function qs(t, e, i) {\n        const s = t.ticks.length, n = Math.min(e, s - 1), o = t._startPixel, a = t._endPixel, r = 1e-6;\n        let l, h = t.getPixelForTick(n);\n        if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h;\n    }\n    function Ks(t) {\n        return t.drawTicks ? t.tickLength : 0;\n    }\n    function Gs(t, e) {\n        if (!t.display) return 0;\n        const i = Si(t.font, e), s = ki(t.padding);\n        return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height;\n    }\n    function Zs(t, e, i) {\n        let s = ut(t);\n        return (i && \"right\" !== e || !i && \"right\" === e) && (s = ((t)=>\"left\" === t ? \"right\" : \"right\" === t ? \"left\" : t)(s)), s;\n    }\n    class Js extends Hs {\n        constructor(t){\n            super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n        }\n        init(t) {\n            this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n        }\n        parse(t, e) {\n            return t;\n        }\n        getUserBounds() {\n            let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;\n            return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {\n                min: r(t, i),\n                max: r(e, s),\n                minDefined: a(t),\n                maxDefined: a(e)\n            };\n        }\n        getMinMax(t) {\n            let e, { min: i, max: s, minDefined: n, maxDefined: o } = this.getUserBounds();\n            if (n && o) return {\n                min: i,\n                max: s\n            };\n            const a = this.getMatchingVisibleMetas();\n            for(let r = 0, l = a.length; r < l; ++r)e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\n            return i = o && i > s ? s : i, s = n && i > s ? i : s, {\n                min: r(i, r(s, i)),\n                max: r(s, r(i, s))\n            };\n        }\n        getPadding() {\n            return {\n                left: this.paddingLeft || 0,\n                top: this.paddingTop || 0,\n                right: this.paddingRight || 0,\n                bottom: this.paddingBottom || 0\n            };\n        }\n        getTicks() {\n            return this.ticks;\n        }\n        getLabels() {\n            const t = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n        }\n        getLabelItems(t = this.chart.chartArea) {\n            return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n        }\n        beforeLayout() {\n            this._cache = {}, this._dataLimitsCached = !1;\n        }\n        beforeUpdate() {\n            d(this.options.beforeUpdate, [\n                this\n            ]);\n        }\n        update(t, e, i) {\n            const { beginAtZero: s, grace: n, ticks: o } = this.options, a = o.sampleSize;\n            this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n            const r = a < this.ticks.length;\n            this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || \"auto\" === o.source) && (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n        }\n        configure() {\n            let t, e, i = this.options.reverse;\n            this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels;\n        }\n        afterUpdate() {\n            d(this.options.afterUpdate, [\n                this\n            ]);\n        }\n        beforeSetDimensions() {\n            d(this.options.beforeSetDimensions, [\n                this\n            ]);\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n        }\n        afterSetDimensions() {\n            d(this.options.afterSetDimensions, [\n                this\n            ]);\n        }\n        _callHooks(t) {\n            this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [\n                this\n            ]);\n        }\n        beforeDataLimits() {\n            this._callHooks(\"beforeDataLimits\");\n        }\n        determineDataLimits() {}\n        afterDataLimits() {\n            this._callHooks(\"afterDataLimits\");\n        }\n        beforeBuildTicks() {\n            this._callHooks(\"beforeBuildTicks\");\n        }\n        buildTicks() {\n            return [];\n        }\n        afterBuildTicks() {\n            this._callHooks(\"afterBuildTicks\");\n        }\n        beforeTickToLabelConversion() {\n            d(this.options.beforeTickToLabelConversion, [\n                this\n            ]);\n        }\n        generateTickLabels(t) {\n            const e = this.options.ticks;\n            let i, s, n;\n            for(i = 0, s = t.length; i < s; i++)n = t[i], n.label = d(e.callback, [\n                n.value,\n                i,\n                t\n            ], this);\n        }\n        afterTickToLabelConversion() {\n            d(this.options.afterTickToLabelConversion, [\n                this\n            ]);\n        }\n        beforeCalculateLabelRotation() {\n            d(this.options.beforeCalculateLabelRotation, [\n                this\n            ]);\n        }\n        calculateLabelRotation() {\n            const t = this.options, e = t.ticks, i = Us(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, n = e.maxRotation;\n            let o, a, r, l = s;\n            if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s);\n            const h = this._getLabelSizes(), c = h.widest.width, d = h.highest.height, u = J(this.chart.width - c, 0, this.maxWidth);\n            o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) / o, -1, 1)), Math.asin(J(a / r, -1, 1)) - Math.asin(J(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l;\n        }\n        afterCalculateLabelRotation() {\n            d(this.options.afterCalculateLabelRotation, [\n                this\n            ]);\n        }\n        afterAutoSkip() {}\n        beforeFit() {\n            d(this.options.beforeFit, [\n                this\n            ]);\n        }\n        fit() {\n            const t = {\n                width: 0,\n                height: 0\n            }, { chart: e, options: { ticks: i, title: s, grid: n } } = this, o = this._isVisible(), a = this.isHorizontal();\n            if (o) {\n                const o = Gs(s, e.options.font);\n                if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display && this.ticks.length) {\n                    const { first: e, last: s, widest: n, highest: o } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);\n                    if (a) {\n                        const e = i.mirror ? 0 : c * n.width + h * o.height;\n                        t.height = Math.min(this.maxHeight, t.height + e + r);\n                    } else {\n                        const e = i.mirror ? 0 : h * n.width + c * o.height;\n                        t.width = Math.min(this.maxWidth, t.width + e + r);\n                    }\n                    this._calculatePadding(e, s, c, h);\n                }\n            }\n            this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n        }\n        _calculatePadding(t, e, i, s) {\n            const { ticks: { align: n, padding: o }, position: a } = this.options, r = 0 !== this.labelRotation, l = \"top\" !== a && \"x\" === this.axis;\n            if (this.isHorizontal()) {\n                const a = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);\n                let c = 0, d = 0;\n                r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : \"start\" === n ? d = e.width : \"end\" === n ? c = t.width : \"inner\" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0);\n            } else {\n                let i = e.height / 2, s = t.height / 2;\n                \"start\" === n ? (i = 0, s = t.height) : \"end\" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o;\n            }\n        }\n        _handleMargins() {\n            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n        }\n        afterFit() {\n            d(this.options.afterFit, [\n                this\n            ]);\n        }\n        isHorizontal() {\n            const { axis: t, position: e } = this.options;\n            return \"top\" === e || \"bottom\" === e || \"x\" === t;\n        }\n        isFullSize() {\n            return this.options.fullSize;\n        }\n        _convertTicksToLabels(t) {\n            let e, i;\n            for(this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)s(t[e].label) && (t.splice(e, 1), i--, e--);\n            this.afterTickToLabelConversion();\n        }\n        _getLabelSizes() {\n            let t = this._labelSizes;\n            if (!t) {\n                const e = this.options.ticks.sampleSize;\n                let i = this.ticks;\n                e < i.length && (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);\n            }\n            return t;\n        }\n        _computeLabelSizes(t, e, i) {\n            const { ctx: o, _longestTextCache: a } = this, r = [], l = [], h = Math.floor(e / Us(e, i));\n            let c, d, f, g, p, m, x, b, _, y, v, M = 0, w = 0;\n            for(c = 0; c < e; c += h){\n                if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, x = a[m] = a[m] || {\n                    data: {},\n                    gc: []\n                }, b = p.lineHeight, _ = y = 0, s(g) || n(g)) {\n                    if (n(g)) for(d = 0, f = g.length; d < f; ++d)v = g[d], s(v) || n(v) || (_ = Ce(o, x.data, x.gc, _, v), y += b);\n                } else _ = Ce(o, x.data, x.gc, _, g), y = b;\n                r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w);\n            }\n            !function(t, e) {\n                u(t, (t)=>{\n                    const i = t.gc, s = i.length / 2;\n                    let n;\n                    if (s > e) {\n                        for(n = 0; n < s; ++n)delete t.data[i[n]];\n                        i.splice(0, s);\n                    }\n                });\n            }(a, e);\n            const k = r.indexOf(M), S = l.indexOf(w), P = (t)=>({\n                    width: r[t] || 0,\n                    height: l[t] || 0\n                });\n            return {\n                first: P(0),\n                last: P(e - 1),\n                widest: P(k),\n                highest: P(S),\n                widths: r,\n                heights: l\n            };\n        }\n        getLabelForValue(t) {\n            return t;\n        }\n        getPixelForValue(t, e) {\n            return NaN;\n        }\n        getValueForPixel(t) {}\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getPixelForDecimal(t) {\n            this._reversePixels && (t = 1 - t);\n            const e = this._startPixel + t * this._length;\n            return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e);\n        }\n        getDecimalForPixel(t) {\n            const e = (t - this._startPixel) / this._length;\n            return this._reversePixels ? 1 - e : e;\n        }\n        getBasePixel() {\n            return this.getPixelForValue(this.getBaseValue());\n        }\n        getBaseValue() {\n            const { min: t, max: e } = this;\n            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n        }\n        getContext(t) {\n            const e = this.ticks || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return i.$context || (i.$context = function(t, e, i) {\n                    return Ci(t, {\n                        tick: i,\n                        index: e,\n                        type: \"tick\"\n                    });\n                }(this.getContext(), t, i));\n            }\n            return this.$context || (this.$context = Ci(this.chart.getContext(), {\n                scale: this,\n                type: \"scale\"\n            }));\n        }\n        _tickSize() {\n            const t = this.options.ticks, e = $(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), n = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = n ? n.widest.width + o : 0, r = n ? n.highest.height + o : 0;\n            return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s;\n        }\n        _isVisible() {\n            const t = this.options.display;\n            return \"auto\" !== t ? !!t : this.getMatchingVisibleMetas().length > 0;\n        }\n        _computeGridLineItems(t) {\n            const e = this.axis, i = this.chart, s = this.options, { grid: n, position: a, border: r } = s, h = n.offset, c = this.isHorizontal(), d = this.ticks.length + (h ? 1 : 0), u = Ks(n), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, m = p / 2, x = function(t) {\n                return Ae(i, t, p);\n            };\n            let b, _, y, v, M, w, k, S, P, D, C, O;\n            if (\"top\" === a) b = x(this.bottom), w = this.bottom - u, S = b - m, D = x(t.top) + m, O = t.bottom;\n            else if (\"bottom\" === a) b = x(this.top), D = t.top, O = x(t.bottom) - m, w = b + m, S = this.top + u;\n            else if (\"left\" === a) b = x(this.right), M = this.right - u, k = b - m, P = x(t.left) + m, C = t.right;\n            else if (\"right\" === a) b = x(this.left), P = t.left, C = x(t.right) - m, M = b + m, k = this.left + u;\n            else if (\"x\" === e) {\n                if (\"center\" === a) b = x((t.top + t.bottom) / 2 + .5);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    b = x(this.chart.scales[t].getPixelForValue(e));\n                }\n                D = t.top, O = t.bottom, w = b + m, S = w + u;\n            } else if (\"y\" === e) {\n                if (\"center\" === a) b = x((t.left + t.right) / 2);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    b = x(this.chart.scales[t].getPixelForValue(e));\n                }\n                M = b - m, k = M - u, P = t.left, C = t.right;\n            }\n            const A = l(s.ticks.maxTicksLimit, d), T = Math.max(1, Math.ceil(d / A));\n            for(_ = 0; _ < d; _ += T){\n                const t = this.getContext(_), e = n.setContext(t), s = r.setContext(t), o = e.lineWidth, a = e.color, l = s.dash || [], d = s.dashOffset, u = e.tickWidth, g = e.tickColor, p = e.tickBorderDash || [], m = e.tickBorderDashOffset;\n                y = qs(this, _, h), void 0 !== y && (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({\n                    tx1: M,\n                    ty1: w,\n                    tx2: k,\n                    ty2: S,\n                    x1: P,\n                    y1: D,\n                    x2: C,\n                    y2: O,\n                    width: o,\n                    color: a,\n                    borderDash: l,\n                    borderDashOffset: d,\n                    tickWidth: u,\n                    tickColor: g,\n                    tickBorderDash: p,\n                    tickBorderDashOffset: m\n                }));\n            }\n            return this._ticksLength = d, this._borderValue = b, f;\n        }\n        _computeLabelItems(t) {\n            const e = this.axis, i = this.options, { position: s, ticks: a } = i, r = this.isHorizontal(), l = this.ticks, { align: h, crossAlign: c, padding: d, mirror: u } = a, f = Ks(i.grid), g = f + d, p = u ? -d : g, m = -$(this.labelRotation), x = [];\n            let b, _, y, v, M, w, k, S, P, D, C, O, A = \"middle\";\n            if (\"top\" === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();\n            else if (\"bottom\" === s) w = this.top + p, k = this._getXAxisLabelAlignment();\n            else if (\"left\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"right\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"x\" === e) {\n                if (\"center\" === s) w = (t.top + t.bottom) / 2 + g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    w = this.chart.scales[t].getPixelForValue(e) + g;\n                }\n                k = this._getXAxisLabelAlignment();\n            } else if (\"y\" === e) {\n                if (\"center\" === s) M = (t.left + t.right) / 2 - g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    M = this.chart.scales[t].getPixelForValue(e);\n                }\n                k = this._getYAxisLabelAlignment(f).textAlign;\n            }\n            \"y\" === e && (\"start\" === h ? A = \"top\" : \"end\" === h && (A = \"bottom\"));\n            const T = this._getLabelSizes();\n            for(b = 0, _ = l.length; b < _; ++b){\n                y = l[b], v = y.label;\n                const t = a.setContext(this.getContext(b));\n                S = this.getPixelForTick(b) + a.labelOffset, P = this._resolveTickFontOptions(b), D = P.lineHeight, C = n(v) ? v.length : 1;\n                const e = C / 2, i = t.color, o = t.textStrokeColor, h = t.textStrokeWidth;\n                let d, f = k;\n                if (r ? (M = S, \"inner\" === k && (f = b === _ - 1 ? this.options.reverse ? \"left\" : \"right\" : 0 === b ? this.options.reverse ? \"right\" : \"left\" : \"center\"), O = \"top\" === s ? \"near\" === c || 0 !== m ? -C * D + D / 2 : \"center\" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : \"near\" === c || 0 !== m ? D / 2 : \"center\" === c ? T.highest.height / 2 - e * D : T.highest.height - C * D, u && (O *= -1), 0 === m || t.showLabelBackdrop || (M += D / 2 * Math.sin(m))) : (w = S, O = (1 - C) * D / 2), t.showLabelBackdrop) {\n                    const e = ki(t.backdropPadding), i = T.heights[b], s = T.widths[b];\n                    let n = O - e.top, o = 0 - e.left;\n                    switch(A){\n                        case \"middle\":\n                            n -= i / 2;\n                            break;\n                        case \"bottom\":\n                            n -= i;\n                    }\n                    switch(k){\n                        case \"center\":\n                            o -= s / 2;\n                            break;\n                        case \"right\":\n                            o -= s;\n                            break;\n                        case \"inner\":\n                            b === _ - 1 ? o -= s : b > 0 && (o -= s / 2);\n                    }\n                    d = {\n                        left: o,\n                        top: n,\n                        width: s + e.width,\n                        height: i + e.height,\n                        color: t.backdropColor\n                    };\n                }\n                x.push({\n                    label: v,\n                    font: P,\n                    textOffset: O,\n                    options: {\n                        rotation: m,\n                        color: i,\n                        strokeColor: o,\n                        strokeWidth: h,\n                        textAlign: f,\n                        textBaseline: A,\n                        translation: [\n                            M,\n                            w\n                        ],\n                        backdrop: d\n                    }\n                });\n            }\n            return x;\n        }\n        _getXAxisLabelAlignment() {\n            const { position: t, ticks: e } = this.options;\n            if (-$(this.labelRotation)) return \"top\" === t ? \"left\" : \"right\";\n            let i = \"center\";\n            return \"start\" === e.align ? i = \"left\" : \"end\" === e.align ? i = \"right\" : \"inner\" === e.align && (i = \"inner\"), i;\n        }\n        _getYAxisLabelAlignment(t) {\n            const { position: e, ticks: { crossAlign: i, mirror: s, padding: n } } = this.options, o = t + n, a = this._getLabelSizes().widest.width;\n            let r, l;\n            return \"left\" === e ? s ? (l = this.right + n, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l += a)) : (l = this.right - o, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l = this.left)) : \"right\" === e ? s ? (l = this.left + n, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l -= a)) : (l = this.left + o, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l = this.right)) : r = \"right\", {\n                textAlign: r,\n                x: l\n            };\n        }\n        _computeLabelArea() {\n            if (this.options.ticks.mirror) return;\n            const t = this.chart, e = this.options.position;\n            return \"left\" === e || \"right\" === e ? {\n                top: 0,\n                left: this.left,\n                bottom: t.height,\n                right: this.right\n            } : \"top\" === e || \"bottom\" === e ? {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: t.width\n            } : void 0;\n        }\n        drawBackground() {\n            const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: n, height: o } = this;\n            e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore());\n        }\n        getLineWidthForValue(t) {\n            const e = this.options.grid;\n            if (!this._isVisible() || !e.display) return 0;\n            const i = this.ticks.findIndex((e)=>e.value === t);\n            if (i >= 0) return e.setContext(this.getContext(i)).lineWidth;\n            return 0;\n        }\n        drawGrid(t) {\n            const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n            let n, o;\n            const a = (t, e, s)=>{\n                s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore());\n            };\n            if (e.display) for(n = 0, o = s.length; n < o; ++n){\n                const t = s[n];\n                e.drawOnChartArea && a({\n                    x: t.x1,\n                    y: t.y1\n                }, {\n                    x: t.x2,\n                    y: t.y2\n                }, t), e.drawTicks && a({\n                    x: t.tx1,\n                    y: t.ty1\n                }, {\n                    x: t.tx2,\n                    y: t.ty2\n                }, {\n                    color: t.tickColor,\n                    width: t.tickWidth,\n                    borderDash: t.tickBorderDash,\n                    borderDashOffset: t.tickBorderDashOffset\n                });\n            }\n        }\n        drawBorder() {\n            const { chart: t, ctx: e, options: { border: i, grid: s } } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;\n            if (!o) return;\n            const a = s.setContext(this.getContext(0)).lineWidth, r = this._borderValue;\n            let l, h, c, d;\n            this.isHorizontal() ? (l = Ae(t, this.left, o) - o / 2, h = Ae(t, this.right, a) + a / 2, c = d = r) : (c = Ae(t, this.top, o) - o / 2, d = Ae(t, this.bottom, a) + a / 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore();\n        }\n        drawLabels(t) {\n            if (!this.options.ticks.display) return;\n            const e = this.ctx, i = this._computeLabelArea();\n            i && Ie(e, i);\n            const s = this.getLabelItems(t);\n            for (const t of s){\n                const i = t.options, s = t.font;\n                Ne(e, t.label, 0, t.textOffset, s, i);\n            }\n            i && ze(e);\n        }\n        drawTitle() {\n            const { ctx: t, options: { position: e, title: i, reverse: s } } = this;\n            if (!i.display) return;\n            const a = Si(i.font), r = ki(i.padding), l = i.align;\n            let h = a.lineHeight / 2;\n            \"bottom\" === e || \"center\" === e || o(e) ? (h += r.bottom, n(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\n            const { titleX: c, titleY: d, maxWidth: u, rotation: f } = function(t, e, i, s) {\n                const { top: n, left: a, bottom: r, right: l, chart: h } = t, { chartArea: c, scales: d } = h;\n                let u, f, g, p = 0;\n                const m = r - n, x = l - a;\n                if (t.isHorizontal()) {\n                    if (f = ft(s, a, l), o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        g = d[t].getPixelForValue(s) + m - e;\n                    } else g = \"center\" === i ? (c.bottom + c.top) / 2 + m - e : Ys(t, i, e);\n                    u = l - a;\n                } else {\n                    if (o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        f = d[t].getPixelForValue(s) - x + e;\n                    } else f = \"center\" === i ? (c.left + c.right) / 2 - x + e : Ys(t, i, e);\n                    g = ft(s, r, n), p = \"left\" === i ? -E : E;\n                }\n                return {\n                    titleX: f,\n                    titleY: g,\n                    maxWidth: u,\n                    rotation: p\n                };\n            }(this, h, e, l);\n            Ne(t, i.text, 0, 0, a, {\n                color: i.color,\n                maxWidth: u,\n                rotation: f,\n                textAlign: Zs(l, e, s),\n                textBaseline: \"middle\",\n                translation: [\n                    c,\n                    d\n                ]\n            });\n        }\n        draw(t) {\n            this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n        }\n        _layers() {\n            const t = this.options, e = t.ticks && t.ticks.z || 0, i = l(t.grid && t.grid.z, -1), s = l(t.border && t.border.z, 0);\n            return this._isVisible() && this.draw === Js.prototype.draw ? [\n                {\n                    z: i,\n                    draw: (t)=>{\n                        this.drawBackground(), this.drawGrid(t), this.drawTitle();\n                    }\n                },\n                {\n                    z: s,\n                    draw: ()=>{\n                        this.drawBorder();\n                    }\n                },\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.drawLabels(t);\n                    }\n                }\n            ] : [\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.draw(t);\n                    }\n                }\n            ];\n        }\n        getMatchingVisibleMetas(t) {\n            const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + \"AxisID\", s = [];\n            let n, o;\n            for(n = 0, o = e.length; n < o; ++n){\n                const o = e[n];\n                o[i] !== this.id || t && o.type !== t || s.push(o);\n            }\n            return s;\n        }\n        _resolveTickFontOptions(t) {\n            return Si(this.options.ticks.setContext(this.getContext(t)).font);\n        }\n        _maxDigits() {\n            const t = this._resolveTickFontOptions(0).lineHeight;\n            return (this.isHorizontal() ? this.width : this.height) / t;\n        }\n    }\n    class Qs {\n        constructor(t, e, i){\n            this.type = t, this.scope = e, this.override = i, this.items = Object.create(null);\n        }\n        isForType(t) {\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n        }\n        register(t) {\n            const e = Object.getPrototypeOf(t);\n            let i;\n            (function(t) {\n                return \"id\" in t && \"defaults\" in t;\n            })(e) && (i = this.register(e));\n            const s = this.items, n = t.id, o = this.scope + \".\" + n;\n            if (!n) throw new Error(\"class does not have id: \" + t);\n            return n in s || (s[n] = t, function(t, e, i) {\n                const s = x(Object.create(null), [\n                    i ? ue.get(i) : {},\n                    ue.get(e),\n                    t.defaults\n                ]);\n                ue.set(e, s), t.defaultRoutes && function(t, e) {\n                    Object.keys(e).forEach((i)=>{\n                        const s = i.split(\".\"), n = s.pop(), o = [\n                            t\n                        ].concat(s).join(\".\"), a = e[i].split(\".\"), r = a.pop(), l = a.join(\".\");\n                        ue.route(o, n, l, r);\n                    });\n                }(e, t.defaultRoutes);\n                t.descriptors && ue.describe(e, t.descriptors);\n            }(t, o, i), this.override && ue.override(t.id, t.overrides)), o;\n        }\n        get(t) {\n            return this.items[t];\n        }\n        unregister(t) {\n            const e = this.items, i = t.id, s = this.scope;\n            i in e && delete e[i], s && i in ue[s] && (delete ue[s][i], this.override && delete re[i]);\n        }\n    }\n    class tn {\n        constructor(){\n            this.controllers = new Qs(Ns, \"datasets\", !0), this.elements = new Qs(Hs, \"elements\"), this.plugins = new Qs(Object, \"plugins\"), this.scales = new Qs(Js, \"scales\"), this._typedRegistries = [\n                this.controllers,\n                this.scales,\n                this.elements\n            ];\n        }\n        add(...t) {\n            this._each(\"register\", t);\n        }\n        remove(...t) {\n            this._each(\"unregister\", t);\n        }\n        addControllers(...t) {\n            this._each(\"register\", t, this.controllers);\n        }\n        addElements(...t) {\n            this._each(\"register\", t, this.elements);\n        }\n        addPlugins(...t) {\n            this._each(\"register\", t, this.plugins);\n        }\n        addScales(...t) {\n            this._each(\"register\", t, this.scales);\n        }\n        getController(t) {\n            return this._get(t, this.controllers, \"controller\");\n        }\n        getElement(t) {\n            return this._get(t, this.elements, \"element\");\n        }\n        getPlugin(t) {\n            return this._get(t, this.plugins, \"plugin\");\n        }\n        getScale(t) {\n            return this._get(t, this.scales, \"scale\");\n        }\n        removeControllers(...t) {\n            this._each(\"unregister\", t, this.controllers);\n        }\n        removeElements(...t) {\n            this._each(\"unregister\", t, this.elements);\n        }\n        removePlugins(...t) {\n            this._each(\"unregister\", t, this.plugins);\n        }\n        removeScales(...t) {\n            this._each(\"unregister\", t, this.scales);\n        }\n        _each(t, e, i) {\n            [\n                ...e\n            ].forEach((e)=>{\n                const s = i || this._getRegistryForType(e);\n                i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : u(e, (e)=>{\n                    const s = i || this._getRegistryForType(e);\n                    this._exec(t, s, e);\n                });\n            });\n        }\n        _exec(t, e, i) {\n            const s = w(t);\n            d(i[\"before\" + s], [], i), e[t](i), d(i[\"after\" + s], [], i);\n        }\n        _getRegistryForType(t) {\n            for(let e = 0; e < this._typedRegistries.length; e++){\n                const i = this._typedRegistries[e];\n                if (i.isForType(t)) return i;\n            }\n            return this.plugins;\n        }\n        _get(t, e, i) {\n            const s = e.get(t);\n            if (void 0 === s) throw new Error('\"' + t + '\" is not a registered ' + i + \".\");\n            return s;\n        }\n    }\n    var en = new tn;\n    class sn {\n        constructor(){\n            this._init = [];\n        }\n        notify(t, e, i, s) {\n            \"beforeInit\" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n            const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(n, t, e, i);\n            return \"afterDestroy\" === e && (this._notify(n, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), o;\n        }\n        _notify(t, e, i, s) {\n            s = s || {};\n            for (const n of t){\n                const t = n.plugin;\n                if (!1 === d(t[i], [\n                    e,\n                    s,\n                    n.options\n                ], t) && s.cancelable) return !1;\n            }\n            return !0;\n        }\n        invalidate() {\n            s(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n        }\n        _descriptors(t) {\n            if (this._cache) return this._cache;\n            const e = this._cache = this._createDescriptors(t);\n            return this._notifyStateChanges(t), e;\n        }\n        _createDescriptors(t, e) {\n            const i = t && t.config, s = l(i.options && i.options.plugins, {}), n = function(t) {\n                const e = {}, i = [], s = Object.keys(en.plugins.items);\n                for(let t = 0; t < s.length; t++)i.push(en.getPlugin(s[t]));\n                const n = t.plugins || [];\n                for(let t = 0; t < n.length; t++){\n                    const s = n[t];\n                    -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0);\n                }\n                return {\n                    plugins: i,\n                    localIds: e\n                };\n            }(i);\n            return !1 !== s || e ? function(t, { plugins: e, localIds: i }, s, n) {\n                const o = [], a = t.getContext();\n                for (const r of e){\n                    const e = r.id, l = nn(s[e], n);\n                    null !== l && o.push({\n                        plugin: r,\n                        options: on(t.config, {\n                            plugin: r,\n                            local: i[e]\n                        }, l, a)\n                    });\n                }\n                return o;\n            }(t, n, s, e) : [];\n        }\n        _notifyStateChanges(t) {\n            const e = this._oldCache || [], i = this._cache, s = (t, e)=>t.filter((t)=>!e.some((e)=>t.plugin.id === e.plugin.id));\n            this._notify(s(e, i), t, \"stop\"), this._notify(s(i, e), t, \"start\");\n        }\n    }\n    function nn(t, e) {\n        return e || !1 !== t ? !0 === t ? {} : t : null;\n    }\n    function on(t, { plugin: e, local: i }, s, n) {\n        const o = t.pluginScopeKeys(e), a = t.getOptionScopes(s, o);\n        return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [\n            \"\"\n        ], {\n            scriptable: !1,\n            indexable: !1,\n            allKeys: !0\n        });\n    }\n    function an(t, e) {\n        const i = ue.datasets[t] || {};\n        return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || \"x\";\n    }\n    function rn(t) {\n        if (\"x\" === t || \"y\" === t || \"r\" === t) return t;\n    }\n    function ln(t, ...e) {\n        if (rn(t)) return t;\n        for (const s of e){\n            const e = s.axis || (\"top\" === (i = s.position) || \"bottom\" === i ? \"x\" : \"left\" === i || \"right\" === i ? \"y\" : void 0) || t.length > 1 && rn(t[0].toLowerCase());\n            if (e) return e;\n        }\n        var i;\n        throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);\n    }\n    function hn(t, e, i) {\n        if (i[e + \"AxisID\"] === t) return {\n            axis: e\n        };\n    }\n    function cn(t, e) {\n        const i = re[t.type] || {\n            scales: {}\n        }, s = e.scales || {}, n = an(t.type, e), a = Object.create(null);\n        return Object.keys(s).forEach((e)=>{\n            const r = s[e];\n            if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);\n            if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);\n            const l = ln(e, r, function(t, e) {\n                if (e.data && e.data.datasets) {\n                    const i = e.data.datasets.filter((e)=>e.xAxisID === t || e.yAxisID === t);\n                    if (i.length) return hn(t, \"x\", i[0]) || hn(t, \"y\", i[0]);\n                }\n                return {};\n            }(e, t), ue.scales[r.type]), h = function(t, e) {\n                return t === e ? \"_index_\" : \"_value_\";\n            }(l, n), c = i.scales || {};\n            a[e] = b(Object.create(null), [\n                {\n                    axis: l\n                },\n                r,\n                c[l],\n                c[h]\n            ]);\n        }), t.data.datasets.forEach((i)=>{\n            const n = i.type || t.type, o = i.indexAxis || an(n, e), r = (re[n] || {}).scales || {};\n            Object.keys(r).forEach((t)=>{\n                const e = function(t, e) {\n                    let i = t;\n                    return \"_index_\" === t ? i = e : \"_value_\" === t && (i = \"x\" === e ? \"y\" : \"x\"), i;\n                }(t, o), n = i[e + \"AxisID\"] || e;\n                a[n] = a[n] || Object.create(null), b(a[n], [\n                    {\n                        axis: e\n                    },\n                    s[n],\n                    r[t]\n                ]);\n            });\n        }), Object.keys(a).forEach((t)=>{\n            const e = a[t];\n            b(e, [\n                ue.scales[e.type],\n                ue.scale\n            ]);\n        }), a;\n    }\n    function dn(t) {\n        const e = t.options || (t.options = {});\n        e.plugins = l(e.plugins, {}), e.scales = cn(t, e);\n    }\n    function un(t) {\n        return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t;\n    }\n    const fn = new Map, gn = new Set;\n    function pn(t, e) {\n        let i = fn.get(t);\n        return i || (i = e(), fn.set(t, i), gn.add(i)), i;\n    }\n    const mn = (t, e, i)=>{\n        const s = M(e, i);\n        void 0 !== s && t.add(s);\n    };\n    class xn {\n        constructor(t){\n            this._config = function(t) {\n                return (t = t || {}).data = un(t.data), dn(t), t;\n            }(t), this._scopeCache = new Map, this._resolverCache = new Map;\n        }\n        get platform() {\n            return this._config.platform;\n        }\n        get type() {\n            return this._config.type;\n        }\n        set type(t) {\n            this._config.type = t;\n        }\n        get data() {\n            return this._config.data;\n        }\n        set data(t) {\n            this._config.data = un(t);\n        }\n        get options() {\n            return this._config.options;\n        }\n        set options(t) {\n            this._config.options = t;\n        }\n        get plugins() {\n            return this._config.plugins;\n        }\n        update() {\n            const t = this._config;\n            this.clearCache(), dn(t);\n        }\n        clearCache() {\n            this._scopeCache.clear(), this._resolverCache.clear();\n        }\n        datasetScopeKeys(t) {\n            return pn(t, ()=>[\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetAnimationScopeKeys(t, e) {\n            return pn(`${t}.transition.${e}`, ()=>[\n                    [\n                        `datasets.${t}.transitions.${e}`,\n                        `transitions.${e}`\n                    ],\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetElementScopeKeys(t, e) {\n            return pn(`${t}-${e}`, ()=>[\n                    [\n                        `datasets.${t}.elements.${e}`,\n                        `datasets.${t}`,\n                        `elements.${e}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        pluginScopeKeys(t) {\n            const e = t.id;\n            return pn(`${this.type}-plugin-${e}`, ()=>[\n                    [\n                        `plugins.${e}`,\n                        ...t.additionalOptionScopes || []\n                    ]\n                ]);\n        }\n        _cachedScopes(t, e) {\n            const i = this._scopeCache;\n            let s = i.get(t);\n            return s && !e || (s = new Map, i.set(t, s)), s;\n        }\n        getOptionScopes(t, e, i) {\n            const { options: s, type: n } = this, o = this._cachedScopes(t, i), a = o.get(e);\n            if (a) return a;\n            const r = new Set;\n            e.forEach((e)=>{\n                t && (r.add(t), e.forEach((e)=>mn(r, t, e))), e.forEach((t)=>mn(r, s, t)), e.forEach((t)=>mn(r, re[n] || {}, t)), e.forEach((t)=>mn(r, ue, t)), e.forEach((t)=>mn(r, le, t));\n            });\n            const l = Array.from(r);\n            return 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l;\n        }\n        chartOptionScopes() {\n            const { options: t, type: e } = this;\n            return [\n                t,\n                re[e] || {},\n                ue.datasets[e] || {},\n                {\n                    type: e\n                },\n                ue,\n                le\n            ];\n        }\n        resolveNamedOptions(t, e, i, s = [\n            \"\"\n        ]) {\n            const o = {\n                $shared: !0\n            }, { resolver: a, subPrefixes: r } = bn(this._resolverCache, t, s);\n            let l = a;\n            if (function(t, e) {\n                const { isScriptable: i, isIndexable: s } = Ye(t);\n                for (const o of e){\n                    const e = i(o), a = s(o), r = (a || e) && t[o];\n                    if (e && (S(r) || _n(r)) || a && n(r)) return !0;\n                }\n                return !1;\n            }(a, e)) {\n                o.$shared = !1;\n                l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r));\n            }\n            for (const t of e)o[t] = l[t];\n            return o;\n        }\n        createResolver(t, e, i = [\n            \"\"\n        ], s) {\n            const { resolver: n } = bn(this._resolverCache, t, i);\n            return o(e) ? $e(n, e, void 0, s) : n;\n        }\n    }\n    function bn(t, e, i) {\n        let s = t.get(e);\n        s || (s = new Map, t.set(e, s));\n        const n = i.join();\n        let o = s.get(n);\n        if (!o) o = {\n            resolver: je(e, i),\n            subPrefixes: i.filter((t)=>!t.toLowerCase().includes(\"hover\"))\n        }, s.set(n, o);\n        return o;\n    }\n    const _n = (t)=>o(t) && Object.getOwnPropertyNames(t).some((e)=>S(t[e]));\n    const yn = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"chartArea\"\n    ];\n    function vn(t, e) {\n        return \"top\" === t || \"bottom\" === t || -1 === yn.indexOf(t) && \"x\" === e;\n    }\n    function Mn(t, e) {\n        return function(i, s) {\n            return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t];\n        };\n    }\n    function wn(t) {\n        const e = t.chart, i = e.options.animation;\n        e.notifyPlugins(\"afterRender\"), d(i && i.onComplete, [\n            t\n        ], e);\n    }\n    function kn(t) {\n        const e = t.chart, i = e.options.animation;\n        d(i && i.onProgress, [\n            t\n        ], e);\n    }\n    function Sn(t) {\n        return fe() && \"string\" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;\n    }\n    const Pn = {}, Dn = (t)=>{\n        const e = Sn(t);\n        return Object.values(Pn).filter((t)=>t.canvas === e).pop();\n    };\n    function Cn(t, e, i) {\n        const s = Object.keys(t);\n        for (const n of s){\n            const s = +n;\n            if (s >= e) {\n                const o = t[n];\n                delete t[n], (i > 0 || s > e) && (t[s + i] = o);\n            }\n        }\n    }\n    function On(t, e, i) {\n        return t.options.clip ? t[i] : e[i];\n    }\n    class An {\n        static defaults = ue;\n        static instances = Pn;\n        static overrides = re;\n        static registry = en;\n        static version = \"4.4.8\";\n        static getChart = Dn;\n        static register(...t) {\n            en.add(...t), Tn();\n        }\n        static unregister(...t) {\n            en.remove(...t), Tn();\n        }\n        constructor(t, e){\n            const s = this.config = new xn(e), n = Sn(t), o = Dn(n);\n            if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n            const a = s.createResolver(s.chartOptionScopes(), this.getContext());\n            this.platform = new (s.platform || ks(n)), this.platform.updateConfig(s);\n            const r = this.platform.acquireContext(n, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width;\n            this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t)=>this.update(t), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (bt.listen(this, \"complete\", wn), bt.listen(this, \"progress\", kn), this._initialize(), this.attached && this.update()) : console.error(\"Failed to create chart: can't acquire context from the given item\");\n        }\n        get aspectRatio() {\n            const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this;\n            return s(t) ? e && o ? o : n ? i / n : null : t;\n        }\n        get data() {\n            return this.config.data;\n        }\n        set data(t) {\n            this.config.data = t;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(t) {\n            this.config.options = t;\n        }\n        get registry() {\n            return en;\n        }\n        _initialize() {\n            return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n        }\n        clear() {\n            return Te(this.canvas, this.ctx), this;\n        }\n        stop() {\n            return bt.stop(this), this;\n        }\n        resize(t, e) {\n            bt.running(this) ? this._resizeBeforeDraw = {\n                width: t,\n                height: e\n            } : this._resize(t, e);\n        }\n        _resize(t, e) {\n            const i = this.options, s = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, t, e, n), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), r = this.width ? \"resize\" : \"attach\";\n            this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) && (this.notifyPlugins(\"resize\", {\n                size: o\n            }), d(i.onResize, [\n                this,\n                o\n            ], this), this.attached && this._doResize(r) && this.render());\n        }\n        ensureScalesHaveIDs() {\n            u(this.options.scales || {}, (t, e)=>{\n                t.id = e;\n            });\n        }\n        buildOrUpdateScales() {\n            const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((t, e)=>(t[e] = !1, t), {});\n            let n = [];\n            e && (n = n.concat(Object.keys(e).map((t)=>{\n                const i = e[t], s = ln(t, i), n = \"r\" === s, o = \"x\" === s;\n                return {\n                    options: i,\n                    dposition: n ? \"chartArea\" : o ? \"bottom\" : \"left\",\n                    dtype: n ? \"radialLinear\" : o ? \"category\" : \"linear\"\n                };\n            }))), u(n, (e)=>{\n                const n = e.options, o = n.id, a = ln(o, n), r = l(n.type, e.dtype);\n                void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;\n                let h = null;\n                if (o in i && i[o].type === r) h = i[o];\n                else h = new (en.getScale(r))({\n                    id: o,\n                    type: r,\n                    ctx: this.ctx,\n                    chart: this\n                }), i[h.id] = h;\n                h.init(n, t);\n            }), u(s, (t, e)=>{\n                t || delete i[e];\n            }), u(i, (t)=>{\n                as.configure(this, t, t.options), as.addBox(this, t);\n            });\n        }\n        _updateMetasets() {\n            const t = this._metasets, e = this.data.datasets.length, i = t.length;\n            if (t.sort((t, e)=>t.index - e.index), i > e) {\n                for(let t = e; t < i; ++t)this._destroyDatasetMeta(t);\n                t.splice(e, i - e);\n            }\n            this._sortedMetasets = t.slice(0).sort(Mn(\"order\", \"index\"));\n        }\n        _removeUnreferencedMetasets() {\n            const { _metasets: t, data: { datasets: e } } = this;\n            t.length > e.length && delete this._stacks, t.forEach((t, i)=>{\n                0 === e.filter((e)=>e === t._dataset).length && this._destroyDatasetMeta(i);\n            });\n        }\n        buildOrUpdateControllers() {\n            const t = [], e = this.data.datasets;\n            let i, s;\n            for(this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++){\n                const s = e[i];\n                let n = this.getDatasetMeta(i);\n                const o = s.type || this.config.type;\n                if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = \"\" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();\n                else {\n                    const e = en.getController(o), { datasetElementType: s, dataElementType: a } = ue.datasets[o];\n                    Object.assign(e, {\n                        dataElementType: en.getElement(a),\n                        datasetElementType: s && en.getElement(s)\n                    }), n.controller = new e(this, i), t.push(n.controller);\n                }\n            }\n            return this._updateMetasets(), t;\n        }\n        _resetElements() {\n            u(this.data.datasets, (t, e)=>{\n                this.getDatasetMeta(e).controller.reset();\n            }, this);\n        }\n        reset() {\n            this._resetElements(), this.notifyPlugins(\"reset\");\n        }\n        update(t) {\n            const e = this.config;\n            e.update();\n            const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;\n            if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(\"beforeUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) return;\n            const n = this.buildOrUpdateControllers();\n            this.notifyPlugins(\"beforeElementsUpdate\");\n            let o = 0;\n            for(let t = 0, e = this.data.datasets.length; t < e; t++){\n                const { controller: e } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);\n                e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o);\n            }\n            o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t)=>{\n                t.reset();\n            }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n                mode: t\n            }), this._layers.sort(Mn(\"z\", \"_idx\"));\n            const { _active: a, _lastEvent: r } = this;\n            r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n        }\n        _updateScales() {\n            u(this.scales, (t)=>{\n                as.removeBox(this, t);\n            }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n        }\n        _checkEventBindings() {\n            const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);\n            P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents());\n        }\n        _updateHiddenIndices() {\n            const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n            for (const { method: i, start: s, count: n } of e)Cn(t, s, \"_removeElements\" === i ? -n : n);\n        }\n        _getUniformDataChanges() {\n            const t = this._dataChanges;\n            if (!t || !t.length) return;\n            this._dataChanges = [];\n            const e = this.data.datasets.length, i = (e)=>new Set(t.filter((t)=>t[0] === e).map((t, e)=>e + \",\" + t.splice(1).join(\",\"))), s = i(0);\n            for(let t = 1; t < e; t++)if (!P(s, i(t))) return;\n            return Array.from(s).map((t)=>t.split(\",\")).map((t)=>({\n                    method: t[1],\n                    start: +t[2],\n                    count: +t[3]\n                }));\n        }\n        _updateLayout(t) {\n            if (!1 === this.notifyPlugins(\"beforeLayout\", {\n                cancelable: !0\n            })) return;\n            as.update(this, this.width, this.height, t);\n            const e = this.chartArea, i = e.width <= 0 || e.height <= 0;\n            this._layers = [], u(this.boxes, (t)=>{\n                i && \"chartArea\" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()));\n            }, this), this._layers.forEach((t, e)=>{\n                t._idx = e;\n            }), this.notifyPlugins(\"afterLayout\");\n        }\n        _updateDatasets(t) {\n            if (!1 !== this.notifyPlugins(\"beforeDatasetsUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) {\n                for(let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure();\n                for(let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, S(t) ? t({\n                    datasetIndex: e\n                }) : t);\n                this.notifyPlugins(\"afterDatasetsUpdate\", {\n                    mode: t\n                });\n            }\n        }\n        _updateDataset(t, e) {\n            const i = this.getDatasetMeta(t), s = {\n                meta: i,\n                index: t,\n                mode: e,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetUpdate\", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", s));\n        }\n        render() {\n            !1 !== this.notifyPlugins(\"beforeRender\", {\n                cancelable: !0\n            }) && (bt.has(this) ? this.attached && !bt.running(this) && bt.start(this) : (this.draw(), wn({\n                chart: this\n            })));\n        }\n        draw() {\n            let t;\n            if (this._resizeBeforeDraw) {\n                const { width: t, height: e } = this._resizeBeforeDraw;\n                this._resizeBeforeDraw = null, this._resize(t, e);\n            }\n            if (this.clear(), this.width <= 0 || this.height <= 0) return;\n            if (!1 === this.notifyPlugins(\"beforeDraw\", {\n                cancelable: !0\n            })) return;\n            const e = this._layers;\n            for(t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea);\n            for(this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea);\n            this.notifyPlugins(\"afterDraw\");\n        }\n        _getSortedDatasetMetas(t) {\n            const e = this._sortedMetasets, i = [];\n            let s, n;\n            for(s = 0, n = e.length; s < n; ++s){\n                const n = e[s];\n                t && !n.visible || i.push(n);\n            }\n            return i;\n        }\n        getSortedVisibleDatasetMetas() {\n            return this._getSortedDatasetMetas(!0);\n        }\n        _drawDatasets() {\n            if (!1 === this.notifyPlugins(\"beforeDatasetsDraw\", {\n                cancelable: !0\n            })) return;\n            const t = this.getSortedVisibleDatasetMetas();\n            for(let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]);\n            this.notifyPlugins(\"afterDatasetsDraw\");\n        }\n        _drawDataset(t) {\n            const e = this.ctx, i = t._clip, s = !i.disabled, n = function(t, e) {\n                const { xScale: i, yScale: s } = t;\n                return i && s ? {\n                    left: On(i, e, \"left\"),\n                    right: On(i, e, \"right\"),\n                    top: On(s, e, \"top\"),\n                    bottom: On(s, e, \"bottom\")\n                } : e;\n            }(t, this.chartArea), o = {\n                meta: t,\n                index: t.index,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetDraw\", o) && (s && Ie(e, {\n                left: !1 === i.left ? 0 : n.left - i.left,\n                right: !1 === i.right ? this.width : n.right + i.right,\n                top: !1 === i.top ? 0 : n.top - i.top,\n                bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\n            }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", o));\n        }\n        isPointInArea(t) {\n            return Re(t, this.chartArea, this._minPadding);\n        }\n        getElementsAtEventForMode(t, e, i, s) {\n            const n = Xi.modes[e];\n            return \"function\" == typeof n ? n(this, t, i, s) : [];\n        }\n        getDatasetMeta(t) {\n            const e = this.data.datasets[t], i = this._metasets;\n            let s = i.filter((t)=>t && t._dataset === e).pop();\n            return s || (s = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: e && e.order || 0,\n                index: t,\n                _dataset: e,\n                _parsed: [],\n                _sorted: !1\n            }, i.push(s)), s;\n        }\n        getContext() {\n            return this.$context || (this.$context = Ci(null, {\n                chart: this,\n                type: \"chart\"\n            }));\n        }\n        getVisibleDatasetCount() {\n            return this.getSortedVisibleDatasetMetas().length;\n        }\n        isDatasetVisible(t) {\n            const e = this.data.datasets[t];\n            if (!e) return !1;\n            const i = this.getDatasetMeta(t);\n            return \"boolean\" == typeof i.hidden ? !i.hidden : !e.hidden;\n        }\n        setDatasetVisibility(t, e) {\n            this.getDatasetMeta(t).hidden = !e;\n        }\n        toggleDataVisibility(t) {\n            this._hiddenIndices[t] = !this._hiddenIndices[t];\n        }\n        getDataVisibility(t) {\n            return !this._hiddenIndices[t];\n        }\n        _updateVisibility(t, e, i) {\n            const s = i ? \"show\" : \"hide\", n = this.getDatasetMeta(t), o = n.controller._resolveAnimations(void 0, s);\n            k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\n                visible: i\n            }), this.update((e)=>e.datasetIndex === t ? s : void 0));\n        }\n        hide(t, e) {\n            this._updateVisibility(t, e, !1);\n        }\n        show(t, e) {\n            this._updateVisibility(t, e, !0);\n        }\n        _destroyDatasetMeta(t) {\n            const e = this._metasets[t];\n            e && e.controller && e.controller._destroy(), delete this._metasets[t];\n        }\n        _stop() {\n            let t, e;\n            for(this.stop(), bt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t);\n        }\n        destroy() {\n            this.notifyPlugins(\"beforeDestroy\");\n            const { canvas: t, ctx: e } = this;\n            this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins(\"afterDestroy\");\n        }\n        toBase64Image(...t) {\n            return this.canvas.toDataURL(...t);\n        }\n        bindEvents() {\n            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n        }\n        bindUserEvents() {\n            const t = this._listeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (t, e, i)=>{\n                t.offsetX = e, t.offsetY = i, this._eventHandler(t);\n            };\n            u(this.options.events, (t)=>i(t, s));\n        }\n        bindResponsiveEvents() {\n            this._responsiveListeners || (this._responsiveListeners = {});\n            const t = this._responsiveListeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (i, s)=>{\n                t[i] && (e.removeEventListener(this, i, s), delete t[i]);\n            }, n = (t, e)=>{\n                this.canvas && this.resize(t, e);\n            };\n            let o;\n            const a = ()=>{\n                s(\"attach\", a), this.attached = !0, this.resize(), i(\"resize\", n), i(\"detach\", o);\n            };\n            o = ()=>{\n                this.attached = !1, s(\"resize\", n), this._stop(), this._resize(0, 0), i(\"attach\", a);\n            }, e.isAttached(this.canvas) ? a() : o();\n        }\n        unbindEvents() {\n            u(this._listeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._listeners = {}, u(this._responsiveListeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._responsiveListeners = void 0;\n        }\n        updateHoverStyle(t, e, i) {\n            const s = i ? \"set\" : \"remove\";\n            let n, o, a, r;\n            for(\"dataset\" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[\"_\" + s + \"DatasetHoverStyle\"]()), a = 0, r = t.length; a < r; ++a){\n                o = t[a];\n                const e = o && this.getDatasetMeta(o.datasetIndex).controller;\n                e && e[s + \"HoverStyle\"](o.element, o.datasetIndex, o.index);\n            }\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t) {\n            const e = this._active || [], i = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.getDatasetMeta(t);\n                if (!i) throw new Error(\"No dataset found at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            });\n            !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));\n        }\n        notifyPlugins(t, e, i) {\n            return this._plugins.notify(this, t, e, i);\n        }\n        isPluginEnabled(t) {\n            return 1 === this._plugins._cache.filter((e)=>e.plugin.id === t).length;\n        }\n        _updateHoverStyles(t, e, i) {\n            const s = this.options.hover, n = (t, e)=>t.filter((t)=>!e.some((e)=>t.datasetIndex === e.datasetIndex && t.index === e.index)), o = n(e, t), a = i ? t : n(t, e);\n            o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);\n        }\n        _eventHandler(t, e) {\n            const i = {\n                event: t,\n                replay: e,\n                cancelable: !0,\n                inChartArea: this.isPointInArea(t)\n            }, s = (e)=>(e.options.events || this.options.events).includes(t.native.type);\n            if (!1 === this.notifyPlugins(\"beforeEvent\", i, s)) return;\n            const n = this._handleEvent(t, e, i.inChartArea);\n            return i.cancelable = !1, this.notifyPlugins(\"afterEvent\", i, s), (n || i.changed) && this.render(), this;\n        }\n        _handleEvent(t, e, i) {\n            const { _active: s = [], options: n } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {\n                return i && \"mouseout\" !== t.type ? s ? e : t : null;\n            }(t, this._lastEvent, i, r);\n            i && (this._lastEvent = null, d(n.onHover, [\n                t,\n                a,\n                this\n            ], this), r && d(n.onClick, [\n                t,\n                a,\n                this\n            ], this));\n            const h = !f(a, s);\n            return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h;\n        }\n        _getActiveElements(t, e, i, s) {\n            if (\"mouseout\" === t.type) return [];\n            if (!i) return e;\n            const n = this.options.hover;\n            return this.getElementsAtEventForMode(t, n.mode, n, s);\n        }\n    }\n    function Tn() {\n        return u(An.instances, (t)=>t._plugins.invalidate());\n    }\n    function Ln() {\n        throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n    }\n    class En {\n        static override(t) {\n            Object.assign(En.prototype, t);\n        }\n        options;\n        constructor(t){\n            this.options = t || {};\n        }\n        init() {}\n        formats() {\n            return Ln();\n        }\n        parse() {\n            return Ln();\n        }\n        format() {\n            return Ln();\n        }\n        add() {\n            return Ln();\n        }\n        diff() {\n            return Ln();\n        }\n        startOf() {\n            return Ln();\n        }\n        endOf() {\n            return Ln();\n        }\n    }\n    var Rn = {\n        _date: En\n    };\n    function In(t) {\n        const e = t.iScale, i = function(t, e) {\n            if (!t._cache.$bar) {\n                const i = t.getMatchingVisibleMetas(e);\n                let s = [];\n                for(let e = 0, n = i.length; e < n; e++)s = s.concat(i[e].controller.getAllParsedValues(t));\n                t._cache.$bar = lt(s.sort((t, e)=>t - e));\n            }\n            return t._cache.$bar;\n        }(e, t.type);\n        let s, n, o, a, r = e._length;\n        const l = ()=>{\n            32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);\n        };\n        for(s = 0, n = i.length; s < n; ++s)o = e.getPixelForValue(i[s]), l();\n        for(a = void 0, s = 0, n = e.ticks.length; s < n; ++s)o = e.getPixelForTick(s), l();\n        return r;\n    }\n    function zn(t, e, i, s) {\n        return n(t) ? function(t, e, i, s) {\n            const n = i.parse(t[0], s), o = i.parse(t[1], s), a = Math.min(n, o), r = Math.max(n, o);\n            let l = a, h = r;\n            Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {\n                barStart: l,\n                barEnd: h,\n                start: n,\n                end: o,\n                min: a,\n                max: r\n            };\n        }(t, e, i, s) : e[i.axis] = i.parse(t, s), e;\n    }\n    function Fn(t, e, i, s) {\n        const n = t.iScale, o = t.vScale, a = n.getLabels(), r = n === o, l = [];\n        let h, c, d, u;\n        for(h = i, c = i + s; h < c; ++h)u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));\n        return l;\n    }\n    function Vn(t) {\n        return t && void 0 !== t.barStart && void 0 !== t.barEnd;\n    }\n    function Bn(t, e, i, s) {\n        let n = e.borderSkipped;\n        const o = {};\n        if (!n) return void (t.borderSkipped = o);\n        if (!0 === n) return void (t.borderSkipped = {\n            top: !0,\n            right: !0,\n            bottom: !0,\n            left: !0\n        });\n        const { start: a, end: r, reverse: l, top: h, bottom: c } = function(t) {\n            let e, i, s, n, o;\n            return t.horizontal ? (e = t.base > t.x, i = \"left\", s = \"right\") : (e = t.base < t.y, i = \"bottom\", s = \"top\"), e ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n                start: i,\n                end: s,\n                reverse: e,\n                top: n,\n                bottom: o\n            };\n        }(t);\n        \"middle\" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o;\n    }\n    function Wn(t, e, i, s) {\n        var n, o, a;\n        return s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t;\n    }\n    function Nn(t, e, i) {\n        return \"start\" === t ? e : \"end\" === t ? i : t;\n    }\n    function Hn(t, { inflateAmount: e }, i) {\n        t.inflateAmount = \"auto\" === e ? 1 === i ? .33 : 0 : e;\n    }\n    class jn extends Ns {\n        static id = \"doughnut\";\n        static defaults = {\n            datasetElementType: !1,\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !1\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"circumference\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\",\n                        \"startAngle\",\n                        \"x\",\n                        \"y\",\n                        \"offset\",\n                        \"borderWidth\",\n                        \"spacing\"\n                    ]\n                }\n            },\n            cutout: \"50%\",\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\",\n            spacing: 0,\n            indexAxis: \"r\"\n        };\n        static descriptors = {\n            _scriptable: (t)=>\"spacing\" !== t,\n            _indexable: (t)=>\"spacing\" !== t && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\")\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n        }\n        linkScales() {}\n        parse(t, e) {\n            const i = this.getDataset().data, s = this._cachedMeta;\n            if (!1 === this._parsing) s._parsed = i;\n            else {\n                let n, a, r = (t)=>+i[t];\n                if (o(i[t])) {\n                    const { key: t = \"value\" } = this._parsing;\n                    r = (e)=>+M(i[e], t);\n                }\n                for(n = t, a = t + e; n < a; ++n)s._parsed[n] = r(n);\n            }\n        }\n        _getRotation() {\n            return $(this.options.rotation - 90);\n        }\n        _getCircumference() {\n            return $(this.options.circumference);\n        }\n        _getRotationExtents() {\n            let t = O, e = -O;\n            for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), o = s._getCircumference();\n                t = Math.min(t, n), e = Math.max(e, n + o);\n            }\n            return {\n                rotation: t,\n                circumference: e - t\n            };\n        }\n        update(t) {\n            const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), r = Math.min(h(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: g, offsetX: p, offsetY: m } = function(t, e, i) {\n                let s = 1, n = 1, o = 0, a = 0;\n                if (e < O) {\n                    const r = t, l = r + e, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, s)=>Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i), g = (t, e, s)=>Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i), p = f(0, h, d), m = f(E, c, u), x = g(C, h, d), b = g(C + E, c, u);\n                    s = (p - x) / 2, n = (m - b) / 2, o = -(p + x) / 2, a = -(m + b) / 2;\n                }\n                return {\n                    ratioX: s,\n                    ratioY: n,\n                    offsetX: o,\n                    offsetY: a\n                };\n            }(u, d, r), x = (i.width - o) / f, b = (i.height - o) / g, _ = Math.max(Math.min(x, b) / 2, 0), y = c(this.options.radius, _), v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n            this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t);\n        }\n        _circumference(t, e) {\n            const i = this.options, s = this._cachedMeta, n = this._getCircumference();\n            return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O);\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.chartArea, r = o.options.animation, l = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, c = n && r.animateScale, d = c ? 0 : this.innerRadius, u = c ? 0 : this.outerRadius, { sharedOptions: f, includeOptions: g } = this._getSharedOptions(e, s);\n            let p, m = this._getRotation();\n            for(p = 0; p < e; ++p)m += this._circumference(p, n);\n            for(p = e; p < e + i; ++p){\n                const e = this._circumference(p, n), i = t[p], o = {\n                    x: l + this.offsetX,\n                    y: h + this.offsetY,\n                    startAngle: m,\n                    endAngle: m + e,\n                    circumference: e,\n                    outerRadius: u,\n                    innerRadius: d\n                };\n                g && (o.options = f || this.resolveDataElementOptions(p, i.active ? \"active\" : s)), m += e, this.updateElement(i, p, o, s);\n            }\n        }\n        calculateTotal() {\n            const t = this._cachedMeta, e = t.data;\n            let i, s = 0;\n            for(i = 0; i < e.length; i++){\n                const n = t._parsed[i];\n                null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n));\n            }\n            return s;\n        }\n        calculateCircumference(t) {\n            const e = this._cachedMeta.total;\n            return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t], i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        getMaxBorderWidth(t) {\n            let e = 0;\n            const i = this.chart;\n            let s, n, o, a, r;\n            if (!t) {\n                for(s = 0, n = i.data.datasets.length; s < n; ++s)if (i.isDatasetVisible(s)) {\n                    o = i.getDatasetMeta(s), t = o.data, a = o.controller;\n                    break;\n                }\n            }\n            if (!t) return 0;\n            for(s = 0, n = t.length; s < n; ++s)r = a.resolveDataElementOptions(s), \"inner\" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\n            return e;\n        }\n        getMaxOffset(t) {\n            let e = 0;\n            for(let i = 0, s = t.length; i < s; ++i){\n                const t = this.resolveDataElementOptions(i);\n                e = Math.max(e, t.offset || 0, t.hoverOffset || 0);\n            }\n            return e;\n        }\n        _getRingWeightOffset(t) {\n            let e = 0;\n            for(let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));\n            return e;\n        }\n        _getRingWeight(t) {\n            return Math.max(l(this.chart.data.datasets[t].weight, 1), 0);\n        }\n        _getVisibleDatasetWeightTotal() {\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n        }\n    }\n    class $n extends Ns {\n        static id = \"polarArea\";\n        static defaults = {\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !0\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"startAngle\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\"\n                    ]\n                }\n            },\n            indexAxis: \"r\",\n            startAngle: 0\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: \"radialLinear\",\n                    angleLines: {\n                        display: !1\n                    },\n                    beginAtZero: !0,\n                    grid: {\n                        circular: !0\n                    },\n                    pointLabels: {\n                        display: !1\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t].r, i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        parseObjectData(t, e, i, s) {\n            return ii.bind(this)(t, e, i, s);\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this._updateRadius(), this.updateElements(e, 0, e.length, t);\n        }\n        getMinMax() {\n            const t = this._cachedMeta, e = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n            return t.data.forEach((t, i)=>{\n                const s = this.getParsed(i).r;\n                !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s));\n            }), e;\n        }\n        _updateRadius() {\n            const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), n = Math.max(s / 2, 0), o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();\n            this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o;\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.options.animation, r = this._cachedMeta.rScale, l = r.xCenter, h = r.yCenter, c = r.getIndexAngle(0) - .5 * C;\n            let d, u = c;\n            const f = 360 / this.countVisibleElements();\n            for(d = 0; d < e; ++d)u += this._computeAngle(d, s, f);\n            for(d = e; d < e + i; d++){\n                const e = t[d];\n                let i = u, g = u + this._computeAngle(d, s, f), p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\n                u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));\n                const m = {\n                    x: l,\n                    y: h,\n                    innerRadius: 0,\n                    outerRadius: p,\n                    startAngle: i,\n                    endAngle: g,\n                    options: this.resolveDataElementOptions(d, e.active ? \"active\" : s)\n                };\n                this.updateElement(e, d, m, s);\n            }\n        }\n        countVisibleElements() {\n            const t = this._cachedMeta;\n            let e = 0;\n            return t.data.forEach((t, i)=>{\n                !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++;\n            }), e;\n        }\n        _computeAngle(t, e, i) {\n            return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0;\n        }\n    }\n    var Yn = Object.freeze({\n        __proto__: null,\n        BarController: class extends Ns {\n            static id = \"bar\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"bar\",\n                categoryPercentage: .8,\n                barPercentage: .9,\n                grouped: !0,\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"base\",\n                            \"width\",\n                            \"height\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\",\n                        offset: !0,\n                        grid: {\n                            offset: !0\n                        }\n                    },\n                    _value_: {\n                        type: \"linear\",\n                        beginAtZero: !0\n                    }\n                }\n            };\n            parsePrimitiveData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseArrayData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseObjectData(t, e, i, s) {\n                const { iScale: n, vScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = \"x\" === n.axis ? a : r, h = \"x\" === o.axis ? a : r, c = [];\n                let d, u, f, g;\n                for(d = i, u = i + s; d < u; ++d)g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d));\n                return c;\n            }\n            updateRangeFromParsed(t, e, i, s) {\n                super.updateRangeFromParsed(t, e, i, s);\n                const n = i._custom;\n                n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));\n            }\n            getMaxOverflow() {\n                return 0;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), o = n._custom, a = Vn(o) ? \"[\" + o.start + \", \" + o.end + \"]\" : \"\" + s.getLabelForValue(n[s.axis]);\n                return {\n                    label: \"\" + i.getLabelForValue(n[i.axis]),\n                    value: a\n                };\n            }\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n                this._cachedMeta.stack = this.getDataset().stack;\n            }\n            update(t) {\n                const e = this._cachedMeta;\n                this.updateElements(e.data, 0, e.data.length, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n                for(let f = e; f < e + i; f++){\n                    const e = this.getParsed(f), i = o || s(e[r.axis]) ? {\n                        base: l,\n                        head: l\n                    } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), p = (e._stacks || {})[r.axis], m = {\n                        horizontal: h,\n                        base: i.base,\n                        enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom,\n                        x: h ? i.head : g.center,\n                        y: h ? g.center : i.head,\n                        height: h ? g.size : Math.abs(i.size),\n                        width: h ? Math.abs(i.size) : g.size\n                    };\n                    u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n                    const x = m.options || t[f].options;\n                    Bn(m, x, p, a), Hn(m, x, c.ratio), this.updateElement(t[f], f, m, n);\n                }\n            }\n            _getStacks(t, e) {\n                const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t)=>t.controller.options.grouped), o = i.options.stacked, a = [], r = this._cachedMeta.controller.getParsed(e), l = r && r[i.axis], h = (t)=>{\n                    const e = t._parsed.find((t)=>t[i.axis] === l), n = e && e[t.vScale.axis];\n                    if (s(n) || isNaN(n)) return !0;\n                };\n                for (const i of n)if ((void 0 === e || !h(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;\n                return a.length || a.push(void 0), a;\n            }\n            _getStackCount(t) {\n                return this._getStacks(void 0, t).length;\n            }\n            _getStackIndex(t, e, i) {\n                const s = this._getStacks(t, i), n = void 0 !== e ? s.indexOf(e) : -1;\n                return -1 === n ? s.length - 1 : n;\n            }\n            _getRuler() {\n                const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];\n                let n, o;\n                for(n = 0, o = e.data.length; n < o; ++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\n                const a = t.barThickness;\n                return {\n                    min: a || In(e),\n                    pixels: s,\n                    start: i._startPixel,\n                    end: i._endPixel,\n                    stackCount: this._getStackCount(),\n                    scale: i,\n                    grouped: t.grouped,\n                    ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n                };\n            }\n            _calculateBarValuePixels(t) {\n                const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);\n                let d, u, f = l[e.axis], g = 0, p = i ? this.applyStack(e, l, i) : f;\n                p !== f && (g = p - f, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f);\n                const m = s(o) || c ? g : o;\n                let x = e.getPixelForValue(m);\n                if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : x, u = d - x, Math.abs(u) < a) {\n                    u = function(t, e, i) {\n                        return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);\n                    }(u, e, r) * a, f === r && (x -= u / 2);\n                    const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), o = Math.min(t, s), h = Math.max(t, s);\n                    x = Math.max(Math.min(x, h), o), d = x + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(x));\n                }\n                if (x === e.getPixelForValue(r)) {\n                    const t = F(u) * e.getLineWidthForValue(r) / 2;\n                    x += t, u -= t;\n                }\n                return {\n                    size: u,\n                    base: x,\n                    head: d,\n                    center: d + u / 2\n                };\n            }\n            _calculateBarIndexPixels(t, e) {\n                const i = e.scale, n = this.options, o = n.skipNull, a = l(n.maxBarThickness, 1 / 0);\n                let r, h;\n                if (e.grouped) {\n                    const i = o ? this._getStackCount(t) : e.stackCount, l = \"flex\" === n.barThickness ? function(t, e, i, s) {\n                        const n = e.pixels, o = n[t];\n                        let a = t > 0 ? n[t - 1] : null, r = t < n.length - 1 ? n[t + 1] : null;\n                        const l = i.categoryPercentage;\n                        null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);\n                        const h = o - (o - Math.min(a, r)) / 2 * l;\n                        return {\n                            chunk: Math.abs(r - a) / 2 * l / s,\n                            ratio: i.barPercentage,\n                            start: h\n                        };\n                    }(t, e, n, i) : function(t, e, i, n) {\n                        const o = i.barThickness;\n                        let a, r;\n                        return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {\n                            chunk: a / n,\n                            ratio: r,\n                            start: e.pixels[t] - a / 2\n                        };\n                    }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n                    r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio);\n                } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);\n                return {\n                    base: r - h / 2,\n                    head: r + h / 2,\n                    center: r,\n                    size: h\n                };\n            }\n            draw() {\n                const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;\n                let n = 0;\n                for(; n < s; ++n)null === this.getParsed(n)[e.axis] || i[n].hidden || i[n].draw(this._ctx);\n            }\n        },\n        BubbleController: class extends Ns {\n            static id = \"bubble\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"borderWidth\",\n                            \"radius\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n            }\n            parsePrimitiveData(t, e, i, s) {\n                const n = super.parsePrimitiveData(t, e, i, s);\n                for(let t = 0; t < n.length; t++)n[t]._custom = this.resolveDataElementOptions(t + i).radius;\n                return n;\n            }\n            parseArrayData(t, e, i, s) {\n                const n = super.parseArrayData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            parseObjectData(t, e, i, s) {\n                const n = super.parseObjectData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta.data;\n                let e = 0;\n                for(let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);\n                return e > 0 && e;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y), l = o._custom;\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + (l ? \", \" + l : \"\") + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta.data;\n                this.updateElements(e, 0, e.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = \"reset\" === s, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: r, includeOptions: l } = this._getSharedOptions(e, s), h = o.axis, c = a.axis;\n                for(let d = e; d < e + i; d++){\n                    const e = t[d], i = !n && this.getParsed(d), u = {}, f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]), g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\n                    u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? \"active\" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s);\n                }\n            }\n            resolveDataElementOptions(t, e) {\n                const i = this.getParsed(t);\n                let s = super.resolveDataElementOptions(t, e);\n                s.$shared && (s = Object.assign({}, s, {\n                    $shared: !1\n                }));\n                const n = s.radius;\n                return \"active\" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s;\n            }\n        },\n        DoughnutController: jn,\n        LineController: class extends Ns {\n            static id = \"line\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                showLine: !0,\n                spanGaps: !1\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\"\n                    },\n                    _value_: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n            }\n            update(t) {\n                const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: n } = e, o = this.chart._animationsDisabled;\n                let { start: a, count: r } = pt(e, s, o);\n                this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\n                const l = this.resolveDatasetElementOptions(t);\n                this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\n                    animated: !o,\n                    options: l\n                }, t), this.updateElements(s, a, r, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, { sharedOptions: c, includeOptions: d } = this._getSharedOptions(e, n), u = a.axis, f = r.axis, { spanGaps: g, segment: p } = this.options, m = N(g) ? g : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || \"none\" === n, b = e + i, _ = t.length;\n                let y = e > 0 && this.getParsed(e - 1);\n                for(let i = 0; i < _; ++i){\n                    const g = t[i], _ = x ? g : {};\n                    if (i < e || i >= b) {\n                        _.skip = !0;\n                        continue;\n                    }\n                    const v = this.getParsed(i), M = s(v[f]), w = _[u] = a.getPixelForValue(v[u], i), k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);\n                    _.skip = isNaN(w) || isNaN(k) || M, _.stop = i > 0 && Math.abs(v[u] - y[u]) > m, p && (_.parsed = v, _.raw = h.data[i]), d && (_.options = c || this.resolveDataElementOptions(i, g.active ? \"active\" : n)), x || this.updateElement(g, i, _, n), y = v;\n                }\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || [];\n                if (!s.length) return i;\n                const n = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\n                return Math.max(i, n, o) / 2;\n            }\n            draw() {\n                const t = this._cachedMeta;\n                t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n            }\n        },\n        PieController: class extends jn {\n            static id = \"pie\";\n            static defaults = {\n                cutout: 0,\n                rotation: 0,\n                circumference: 360,\n                radius: \"100%\"\n            };\n        },\n        PolarAreaController: $n,\n        RadarController: class extends Ns {\n            static id = \"radar\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                indexAxis: \"r\",\n                showLine: !0,\n                elements: {\n                    line: {\n                        fill: \"start\"\n                    }\n                }\n            };\n            static overrides = {\n                aspectRatio: 1,\n                scales: {\n                    r: {\n                        type: \"radialLinear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta.vScale, i = this.getParsed(t);\n                return {\n                    label: e.getLabels()[t],\n                    value: \"\" + e.getLabelForValue(i[e.axis])\n                };\n            }\n            parseObjectData(t, e, i, s) {\n                return ii.bind(this)(t, e, i, s);\n            }\n            update(t) {\n                const e = this._cachedMeta, i = e.dataset, s = e.data || [], n = e.iScale.getLabels();\n                if (i.points = s, \"resize\" !== t) {\n                    const e = this.resolveDatasetElementOptions(t);\n                    this.options.showLine || (e.borderWidth = 0);\n                    const o = {\n                        _loop: !0,\n                        _fullLoop: n.length === s.length,\n                        options: e\n                    };\n                    this.updateElement(i, void 0, o, t);\n                }\n                this.updateElements(s, 0, s.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = this._cachedMeta.rScale, o = \"reset\" === s;\n                for(let a = e; a < e + i; a++){\n                    const e = t[a], i = this.resolveDataElementOptions(a, e.active ? \"active\" : s), r = n.getPointPositionForValue(a, this.getParsed(a).r), l = o ? n.xCenter : r.x, h = o ? n.yCenter : r.y, c = {\n                        x: l,\n                        y: h,\n                        angle: r.angle,\n                        skip: isNaN(l) || isNaN(h),\n                        options: i\n                    };\n                    this.updateElement(e, a, c, s);\n                }\n            }\n        },\n        ScatterController: class extends Ns {\n            static id = \"scatter\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                showLine: !1,\n                fill: !1\n            };\n            static overrides = {\n                interaction: {\n                    mode: \"point\"\n                },\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y);\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled;\n                let { start: n, count: o } = pt(e, i, s);\n                if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) {\n                    this.datasetElementType || this.addElements();\n                    const { dataset: n, _dataset: o } = e;\n                    n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\n                    const a = this.resolveDatasetElementOptions(t);\n                    a.segment = this.options.segment, this.updateElement(n, void 0, {\n                        animated: !s,\n                        options: a\n                    }, t);\n                } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n                this.updateElements(i, n, o, t);\n            }\n            addElements() {\n                const { showLine: t } = this.options;\n                !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), super.addElements();\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(c), u = this.includeOptions(n, d), f = a.axis, g = r.axis, { spanGaps: p, segment: m } = this.options, x = N(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || \"none\" === n;\n                let _ = e > 0 && this.getParsed(e - 1);\n                for(let c = e; c < e + i; ++c){\n                    const e = t[c], i = this.getParsed(c), p = b ? e : {}, y = s(i[g]), v = p[f] = a.getPixelForValue(i[f], c), M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);\n                    p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > x, m && (p.parsed = i, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? \"active\" : n)), b || this.updateElement(e, c, p, n), _ = i;\n                }\n                this.updateSharedOptions(d, n, c);\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.data || [];\n                if (!this.options.showLine) {\n                    let t = 0;\n                    for(let i = e.length - 1; i >= 0; --i)t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);\n                    return t > 0 && t;\n                }\n                const i = t.dataset, s = i.options && i.options.borderWidth || 0;\n                if (!e.length) return s;\n                const n = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n                return Math.max(s, n, o) / 2;\n            }\n        }\n    });\n    function Un(t, e, i, s) {\n        const n = vi(t.options.borderRadius, [\n            \"outerStart\",\n            \"outerEnd\",\n            \"innerStart\",\n            \"innerEnd\"\n        ]);\n        const o = (i - e) / 2, a = Math.min(o, s * e / 2), r = (t)=>{\n            const e = (i - Math.min(o, t)) * s / 2;\n            return J(t, 0, Math.min(o, e));\n        };\n        return {\n            outerStart: r(n.outerStart),\n            outerEnd: r(n.outerEnd),\n            innerStart: J(n.innerStart, 0, a),\n            innerEnd: J(n.innerEnd, 0, a)\n        };\n    }\n    function Xn(t, e, i, s) {\n        return {\n            x: i + t * Math.cos(e),\n            y: s + t * Math.sin(e)\n        };\n    }\n    function qn(t, e, i, s, n, o) {\n        const { x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;\n        let f = 0;\n        const g = n - l;\n        if (s) {\n            const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;\n            f = (g - (0 !== t ? g * t / (t + s) : g)) / 2;\n        }\n        const p = (g - Math.max(.001, g * d - i / C) / d) / 2, m = l + p + f, x = n - p - f, { outerStart: b, outerEnd: _, innerStart: y, innerEnd: v } = Un(e, u, d, x - m), M = d - b, w = d - _, k = m + b / M, S = x - _ / w, P = u + y, D = u + v, O = m + y / P, A = x - v / D;\n        if (t.beginPath(), o) {\n            const e = (k + S) / 2;\n            if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0) {\n                const e = Xn(w, S, a, r);\n                t.arc(e.x, e.y, _, S, x + E);\n            }\n            const i = Xn(D, x, a, r);\n            if (t.lineTo(i.x, i.y), v > 0) {\n                const e = Xn(D, A, a, r);\n                t.arc(e.x, e.y, v, x + E, A + Math.PI);\n            }\n            const s = (x - v / u + (m + y / u)) / 2;\n            if (t.arc(a, r, u, x - v / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0) {\n                const e = Xn(P, O, a, r);\n                t.arc(e.x, e.y, y, O + Math.PI, m - E);\n            }\n            const n = Xn(M, m, a, r);\n            if (t.lineTo(n.x, n.y), b > 0) {\n                const e = Xn(M, k, a, r);\n                t.arc(e.x, e.y, b, m - E, k);\n            }\n        } else {\n            t.moveTo(a, r);\n            const e = Math.cos(k) * d + a, i = Math.sin(k) * d + r;\n            t.lineTo(e, i);\n            const s = Math.cos(S) * d + a, n = Math.sin(S) * d + r;\n            t.lineTo(s, n);\n        }\n        t.closePath();\n    }\n    function Kn(t, e, i, s, n) {\n        const { fullCircles: o, startAngle: a, circumference: r, options: l } = e, { borderWidth: h, borderJoinStyle: c, borderDash: d, borderDashOffset: u } = l, f = \"inner\" === l.borderAlign;\n        if (!h) return;\n        t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || \"round\") : (t.lineWidth = h, t.lineJoin = c || \"bevel\");\n        let g = e.endAngle;\n        if (o) {\n            qn(t, e, i, s, g, n);\n            for(let e = 0; e < o; ++e)t.stroke();\n            isNaN(r) || (g = a + (r % O || O));\n        }\n        f && function(t, e, i) {\n            const { startAngle: s, pixelMargin: n, x: o, y: a, outerRadius: r, innerRadius: l } = e;\n            let h = n / r;\n            t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip();\n        }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke());\n    }\n    function Gn(t, e, i = e) {\n        t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor);\n    }\n    function Zn(t, e, i) {\n        t.lineTo(i.x, i.y);\n    }\n    function Jn(t, e, i = {}) {\n        const s = t.length, { start: n = 0, end: o = s - 1 } = i, { start: a, end: r } = e, l = Math.max(n, a), h = Math.min(o, r), c = n < a && o < a || n > r && o > r;\n        return {\n            count: s,\n            start: l,\n            loop: e.loop,\n            ilen: h < l && !c ? s + h - l : h - l\n        };\n    }\n    function Qn(t, e, i, s) {\n        const { points: n, options: o } = e, { count: a, start: r, loop: l, ilen: h } = Jn(n, i, s), c = function(t) {\n            return t.stepped ? Fe : t.tension || \"monotone\" === t.cubicInterpolationMode ? Ve : Zn;\n        }(o);\n        let d, u, f, { move: g = !0, reverse: p } = s || {};\n        for(d = 0; d <= h; ++d)u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\n        return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l;\n    }\n    function to(t, e, i, s) {\n        const n = e.points, { count: o, start: a, ilen: r } = Jn(n, i, s), { move: l = !0, reverse: h } = s || {};\n        let c, d, u, f, g, p, m = 0, x = 0;\n        const b = (t)=>(a + (h ? r - t : t)) % o, _ = ()=>{\n            f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p));\n        };\n        for(l && (d = n[b(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c){\n            if (d = n[b(c)], d.skip) continue;\n            const e = d.x, i = d.y, s = 0 | e;\n            s === u ? (i < f ? f = i : i > g && (g = i), m = (x * m + e) / ++x) : (_(), t.lineTo(e, i), u = s, x = 0, f = g = i), p = i;\n        }\n        _();\n    }\n    function eo(t) {\n        const e = t.options, i = e.borderDash && e.borderDash.length;\n        return !(t._decimated || t._loop || e.tension || \"monotone\" === e.cubicInterpolationMode || e.stepped || i) ? to : Qn;\n    }\n    const io = \"function\" == typeof Path2D;\n    function so(t, e, i, s) {\n        io && !e.options.segment ? function(t, e, i, s) {\n            let n = e._path;\n            n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Gn(t, e.options), t.stroke(n);\n        }(t, e, i, s) : function(t, e, i, s) {\n            const { segments: n, options: o } = e, a = eo(e);\n            for (const r of n)Gn(t, o, r.style), t.beginPath(), a(t, e, r, {\n                start: i,\n                end: i + s - 1\n            }) && t.closePath(), t.stroke();\n        }(t, e, i, s);\n    }\n    class no extends Hs {\n        static id = \"line\";\n        static defaults = {\n            borderCapStyle: \"butt\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: \"miter\",\n            borderWidth: 3,\n            capBezierPoints: !0,\n            cubicInterpolationMode: \"default\",\n            fill: !1,\n            spanGaps: !1,\n            stepped: !1,\n            tension: 0\n        };\n        static defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n        static descriptors = {\n            _scriptable: !0,\n            _indexable: (t)=>\"borderDash\" !== t && \"fill\" !== t\n        };\n        constructor(t){\n            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n        }\n        updateControlPoints(t, e) {\n            const i = this.options;\n            if ((i.tension || \"monotone\" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {\n                const s = i.spanGaps ? this._loop : this._fullLoop;\n                hi(this._points, i, t, s, e), this._pointsUpdated = !0;\n            }\n        }\n        set points(t) {\n            this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n        }\n        get points() {\n            return this._points;\n        }\n        get segments() {\n            return this._segments || (this._segments = zi(this, this.options.segment));\n        }\n        first() {\n            const t = this.segments, e = this.points;\n            return t.length && e[t[0].start];\n        }\n        last() {\n            const t = this.segments, e = this.points, i = t.length;\n            return i && e[t[i - 1].end];\n        }\n        interpolate(t, e) {\n            const i = this.options, s = t[e], n = this.points, o = Ii(this, {\n                property: e,\n                start: s,\n                end: s\n            });\n            if (!o.length) return;\n            const a = [], r = function(t) {\n                return t.stepped ? pi : t.tension || \"monotone\" === t.cubicInterpolationMode ? mi : gi;\n            }(i);\n            let l, h;\n            for(l = 0, h = o.length; l < h; ++l){\n                const { start: h, end: c } = o[l], d = n[h], u = n[c];\n                if (d === u) {\n                    a.push(d);\n                    continue;\n                }\n                const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);\n                f[e] = t[e], a.push(f);\n            }\n            return 1 === a.length ? a[0] : a;\n        }\n        pathSegment(t, e, i) {\n            return eo(this)(t, this, e, i);\n        }\n        path(t, e, i) {\n            const s = this.segments, n = eo(this);\n            let o = this._loop;\n            e = e || 0, i = i || this.points.length - e;\n            for (const a of s)o &= n(t, this, a, {\n                start: e,\n                end: e + i - 1\n            });\n            return !!o;\n        }\n        draw(t, e, i, s) {\n            const n = this.options || {};\n            (this.points || []).length && n.borderWidth && (t.save(), so(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n        }\n    }\n    function oo(t, e, i, s) {\n        const n = t.options, { [i]: o } = t.getProps([\n            i\n        ], s);\n        return Math.abs(e - o) < n.radius + n.hitRadius;\n    }\n    function ao(t, e) {\n        const { x: i, y: s, base: n, width: o, height: a } = t.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"width\",\n            \"height\"\n        ], e);\n        let r, l, h, c, d;\n        return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\n            left: r,\n            top: h,\n            right: l,\n            bottom: c\n        };\n    }\n    function ro(t, e, i, s) {\n        return t ? 0 : J(e, i, s);\n    }\n    function lo(t) {\n        const e = ao(t), i = e.right - e.left, s = e.bottom - e.top, n = function(t, e, i) {\n            const s = t.options.borderWidth, n = t.borderSkipped, o = Mi(s);\n            return {\n                t: ro(n.top, o.top, 0, i),\n                r: ro(n.right, o.right, 0, e),\n                b: ro(n.bottom, o.bottom, 0, i),\n                l: ro(n.left, o.left, 0, e)\n            };\n        }(t, i / 2, s / 2), a = function(t, e, i) {\n            const { enableBorderRadius: s } = t.getProps([\n                \"enableBorderRadius\"\n            ]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);\n            return {\n                topLeft: ro(!h || l.top || l.left, a.topLeft, 0, r),\n                topRight: ro(!h || l.top || l.right, a.topRight, 0, r),\n                bottomLeft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r),\n                bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r)\n            };\n        }(t, i / 2, s / 2);\n        return {\n            outer: {\n                x: e.left,\n                y: e.top,\n                w: i,\n                h: s,\n                radius: a\n            },\n            inner: {\n                x: e.left + n.l,\n                y: e.top + n.t,\n                w: i - n.l - n.r,\n                h: s - n.t - n.b,\n                radius: {\n                    topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),\n                    topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),\n                    bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),\n                    bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))\n                }\n            }\n        };\n    }\n    function ho(t, e, i, s) {\n        const n = null === e, o = null === i, a = t && !(n && o) && ao(t, s);\n        return a && (n || tt(e, a.left, a.right)) && (o || tt(i, a.top, a.bottom));\n    }\n    function co(t, e) {\n        t.rect(e.x, e.y, e.w, e.h);\n    }\n    function uo(t, e, i = {}) {\n        const s = t.x !== i.x ? -e : 0, n = t.y !== i.y ? -e : 0, o = (t.x + t.w !== i.x + i.w ? e : 0) - s, a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\n        return {\n            x: t.x + s,\n            y: t.y + n,\n            w: t.w + o,\n            h: t.h + a,\n            radius: t.radius\n        };\n    }\n    var fo = Object.freeze({\n        __proto__: null,\n        ArcElement: class extends Hs {\n            static id = \"arc\";\n            static defaults = {\n                borderAlign: \"center\",\n                borderColor: \"#fff\",\n                borderDash: [],\n                borderDashOffset: 0,\n                borderJoinStyle: void 0,\n                borderRadius: 0,\n                borderWidth: 2,\n                offset: 0,\n                spacing: 0,\n                angle: void 0,\n                circular: !0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\"\n            };\n            static descriptors = {\n                _scriptable: !0,\n                _indexable: (t)=>\"borderDash\" !== t\n            };\n            circumference;\n            endAngle;\n            fullCircles;\n            innerRadius;\n            outerRadius;\n            pixelMargin;\n            startAngle;\n            constructor(t){\n                super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i), { angle: n, distance: o } = X(s, {\n                    x: t,\n                    y: e\n                }), { startAngle: a, endAngle: r, innerRadius: h, outerRadius: c, circumference: d } = this.getProps([\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\",\n                    \"circumference\"\n                ], i), u = (this.options.spacing + this.options.borderWidth) / 2, f = l(d, r - a), g = Z(n, a, r) && a !== r, p = f >= O || g, m = tt(o, h + u, c + u);\n                return p && m;\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, startAngle: s, endAngle: n, innerRadius: o, outerRadius: a } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\"\n                ], t), { offset: r, spacing: l } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;\n                return {\n                    x: e + Math.cos(h) * c,\n                    y: i + Math.sin(h) * c\n                };\n            }\n            tooltipPosition(t) {\n                return this.getCenterPoint(t);\n            }\n            draw(t) {\n                const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular;\n                if (this.pixelMargin = \"inner\" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;\n                t.save();\n                const a = (this.startAngle + this.endAngle) / 2;\n                t.translate(Math.cos(a) * s, Math.sin(a) * s);\n                const r = s * (1 - Math.sin(Math.min(C, i || 0)));\n                t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function(t, e, i, s, n) {\n                    const { fullCircles: o, startAngle: a, circumference: r } = e;\n                    let l = e.endAngle;\n                    if (o) {\n                        qn(t, e, i, s, l, n);\n                        for(let e = 0; e < o; ++e)t.fill();\n                        isNaN(r) || (l = a + (r % O || O));\n                    }\n                    qn(t, e, i, s, l, n), t.fill();\n                }(t, this, r, n, o), Kn(t, this, r, n, o), t.restore();\n            }\n        },\n        BarElement: class extends Hs {\n            static id = \"bar\";\n            static defaults = {\n                borderSkipped: \"start\",\n                borderWidth: 0,\n                borderRadius: 0,\n                inflateAmount: \"auto\",\n                pointStyle: void 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n            }\n            draw(t) {\n                const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: o } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co;\n                var r;\n                t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill(\"evenodd\")), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore();\n            }\n            inRange(t, e, i) {\n                return ho(this, t, e, i);\n            }\n            inXRange(t, e) {\n                return ho(this, t, null, e);\n            }\n            inYRange(t, e) {\n                return ho(this, null, t, e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, base: s, horizontal: n } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"base\",\n                    \"horizontal\"\n                ], t);\n                return {\n                    x: n ? (e + s) / 2 : e,\n                    y: n ? i : (i + s) / 2\n                };\n            }\n            getRange(t) {\n                return \"x\" === t ? this.width / 2 : this.height / 2;\n            }\n        },\n        LineElement: no,\n        PointElement: class extends Hs {\n            static id = \"point\";\n            parsed;\n            skip;\n            stop;\n            static defaults = {\n                borderWidth: 1,\n                hitRadius: 1,\n                hoverBorderWidth: 1,\n                hoverRadius: 4,\n                pointStyle: \"circle\",\n                radius: 3,\n                rotation: 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.options, { x: n, y: o } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i);\n                return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);\n            }\n            inXRange(t, e) {\n                return oo(this, t, \"x\", e);\n            }\n            inYRange(t, e) {\n                return oo(this, t, \"y\", e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], t);\n                return {\n                    x: e,\n                    y: i\n                };\n            }\n            size(t) {\n                let e = (t = t || this.options || {}).radius || 0;\n                e = Math.max(e, e && t.hoverRadius || 0);\n                return 2 * (e + (e && t.borderWidth || 0));\n            }\n            draw(t, e) {\n                const i = this.options;\n                this.skip || i.radius < .1 || !Re(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y));\n            }\n            getRange() {\n                const t = this.options || {};\n                return t.radius + t.hitRadius;\n            }\n        }\n    });\n    function go(t, e, i, s) {\n        const n = t.indexOf(e);\n        if (-1 === n) return ((t, e, i, s)=>(\"string\" == typeof e ? (i = t.push(e) - 1, s.unshift({\n                index: i,\n                label: e\n            })) : isNaN(e) && (i = null), i))(t, e, i, s);\n        return n !== t.lastIndexOf(e) ? i : n;\n    }\n    function po(t) {\n        const e = this.getLabels();\n        return t >= 0 && t < e.length ? e[t] : t;\n    }\n    function mo(t, e, { horizontal: i, minRotation: s }) {\n        const n = $(s), o = (i ? Math.sin(n) : Math.cos(n)) || .001, a = .75 * e * (\"\" + t).length;\n        return Math.min(e / o, a);\n    }\n    class xo extends Js {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            return s(t) || (\"number\" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t;\n        }\n        handleTickRangeOptions() {\n            const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();\n            let { min: s, max: n } = this;\n            const o = (t)=>s = e ? s : t, a = (t)=>n = i ? n : t;\n            if (t) {\n                const t = F(s), e = F(n);\n                t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0);\n            }\n            if (s === n) {\n                let e = 0 === n ? 1 : Math.abs(.05 * n);\n                a(n + e), t || o(s - e);\n            }\n            this.min = s, this.max = n;\n        }\n        getTickLimit() {\n            const t = this.options.ticks;\n            let e, { maxTicksLimit: i, stepSize: s } = t;\n            return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e;\n        }\n        computeTickLimit() {\n            return Number.POSITIVE_INFINITY;\n        }\n        buildTicks() {\n            const t = this.options, e = t.ticks;\n            let i = this.getTickLimit();\n            i = Math.max(2, i);\n            const n = function(t, e) {\n                const i = [], { bounds: n, step: o, min: a, max: r, precision: l, count: h, maxTicks: c, maxDigits: d, includeBounds: u } = t, f = o || 1, g = c - 1, { min: p, max: m } = e, x = !s(a), b = !s(r), _ = !s(h), y = (m - p) / (d + 1);\n                let v, M, w, k, S = B((m - p) / g / f) * f;\n                if (S < 1e-14 && !x && !b) return [\n                    {\n                        value: p\n                    },\n                    {\n                        value: m\n                    }\n                ];\n                k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), \"ticks\" === n ? (M = Math.floor(p / S) * S, w = Math.ceil(m / S) * S) : (M = p, w = m), x && b && o && H((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, M = a, w = r) : _ ? (M = x ? a : M, w = b ? r : w, k = h - 1, S = (w - M) / k) : (k = (w - M) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));\n                const P = Math.max(U(S), U(M));\n                v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;\n                let D = 0;\n                for(x && (u && M !== a ? (i.push({\n                    value: a\n                }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, mo(a, y, t)) && D++) : M < a && D++); D < k; ++D){\n                    const t = Math.round((M + D * S) * v) / v;\n                    if (b && t > r) break;\n                    i.push({\n                        value: t\n                    });\n                }\n                return b && u && w !== r ? i.length && V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({\n                    value: r\n                }) : b && w !== r || i.push({\n                    value: w\n                }), i;\n            }({\n                maxTicks: i,\n                bounds: t.bounds,\n                min: t.min,\n                max: t.max,\n                precision: e.precision,\n                step: e.stepSize,\n                count: e.count,\n                maxDigits: this._maxDigits(),\n                horizontal: this.isHorizontal(),\n                minRotation: e.minRotation || 0,\n                includeBounds: !1 !== e.includeBounds\n            }, this._range || this);\n            return \"ticks\" === t.bounds && j(n, this, \"value\"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;\n        }\n        configure() {\n            const t = this.ticks;\n            let e = this.min, i = this.max;\n            if (super.configure(), this.options.offset && t.length) {\n                const s = (i - e) / Math.max(t.length - 1, 1) / 2;\n                e -= s, i += s;\n            }\n            this._startValue = e, this._endValue = i, this._valueRange = i - e;\n        }\n        getLabelForValue(t) {\n            return ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n    }\n    class bo extends xo {\n        static id = \"linear\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.numeric\n            }\n        };\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            const t = this.isHorizontal(), e = t ? this.width : this.height, i = $(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, n = this._resolveTickFontOptions(0);\n            return Math.ceil(e / Math.min(40, n.lineHeight / s));\n        }\n        getPixelForValue(t) {\n            return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n        }\n    }\n    const _o = (t)=>Math.floor(z(t)), yo = (t, e)=>Math.pow(10, _o(t) + e);\n    function vo(t) {\n        return 1 === t / Math.pow(10, _o(t));\n    }\n    function Mo(t, e, i) {\n        const s = Math.pow(10, i), n = Math.floor(t / s);\n        return Math.ceil(e / s) - n;\n    }\n    function wo(t, { min: e, max: i }) {\n        e = r(t.min, e);\n        const s = [], n = _o(e);\n        let o = function(t, e) {\n            let i = _o(e - t);\n            for(; Mo(t, e, i) > 10;)i++;\n            for(; Mo(t, e, i) < 10;)i--;\n            return Math.min(i, _o(t));\n        }(e, i), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;\n        const l = Math.pow(10, o), h = n > o ? Math.pow(10, n) : 0, c = Math.round((e - h) * a) / a, d = Math.floor((e - h) / l / 10) * l * 10;\n        let u = Math.floor((c - d) / Math.pow(10, o)), f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a);\n        for(; f < i;)s.push({\n            value: f,\n            major: vo(f),\n            significand: u\n        }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a;\n        const g = r(t.max, f);\n        return s.push({\n            value: g,\n            major: vo(g),\n            significand: u\n        }), s;\n    }\n    class ko extends Js {\n        static id = \"logarithmic\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.logarithmic,\n                major: {\n                    enabled: !0\n                }\n            }\n        };\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            const i = xo.prototype.parse.apply(this, [\n                t,\n                e\n            ]);\n            if (0 !== i) return a(i) && i > 0 ? i : null;\n            this._zero = !0;\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions();\n        }\n        handleTickRangeOptions() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let i = this.min, s = this.max;\n            const n = (e)=>i = t ? i : e, o = (t)=>s = e ? s : t;\n            i === s && (i <= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i <= 0 && n(yo(s, -1)), s <= 0 && o(yo(i, 1)), this.min = i, this.max = s;\n        }\n        buildTicks() {\n            const t = this.options, e = wo({\n                min: this._userMin,\n                max: this._userMax\n            }, this);\n            return \"ticks\" === t.bounds && j(e, this, \"value\"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e;\n        }\n        getLabelForValue(t) {\n            return void 0 === t ? \"0\" : ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n        configure() {\n            const t = this.min;\n            super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t);\n        }\n        getPixelForValue(t) {\n            return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            const e = this.getDecimalForPixel(t);\n            return Math.pow(10, this._startValue + e * this._valueRange);\n        }\n    }\n    function So(t) {\n        const e = t.ticks;\n        if (e.display && t.display) {\n            const t = ki(e.backdropPadding);\n            return l(e.font && e.font.size, ue.font.size) + t.height;\n        }\n        return 0;\n    }\n    function Po(t, e, i, s, n) {\n        return t === s || t === n ? {\n            start: e - i / 2,\n            end: e + i / 2\n        } : t < s || t > n ? {\n            start: e - i,\n            end: e\n        } : {\n            start: e,\n            end: e + i\n        };\n    }\n    function Do(t) {\n        const e = {\n            l: t.left + t._padding.left,\n            r: t.right - t._padding.right,\n            t: t.top + t._padding.top,\n            b: t.bottom - t._padding.bottom\n        }, i = Object.assign({}, e), s = [], o = [], a = t._pointLabels.length, r = t.options.pointLabels, l = r.centerPointLabels ? C / a : 0;\n        for(let u = 0; u < a; u++){\n            const a = r.setContext(t.getPointLabelContext(u));\n            o[u] = a.padding;\n            const f = t.getPointPosition(u, t.drawingArea + o[u], l), g = Si(a.font), p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [\n                d\n            ], {\n                w: Oe(h, c.string, d),\n                h: d.length * c.lineHeight\n            });\n            s[u] = p;\n            const m = G(t.getIndexAngle(u) + l), x = Math.round(Y(m));\n            Co(i, e, m, Po(x, f.x, p.w, 0, 180), Po(x, f.y, p.h, 90, 270));\n        }\n        var h, c, d;\n        t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {\n            const s = [], n = t._pointLabels.length, o = t.options, { centerPointLabels: a, display: r } = o.pointLabels, l = {\n                extra: So(o) / 2,\n                additionalAngle: a ? C / n : 0\n            };\n            let h;\n            for(let o = 0; o < n; o++){\n                l.padding = i[o], l.size = e[o];\n                const n = Oo(t, o, l);\n                s.push(n), \"auto\" === r && (n.visible = Ao(n, h), n.visible && (h = n));\n            }\n            return s;\n        }(t, s, o);\n    }\n    function Co(t, e, i, s, n) {\n        const o = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));\n        let r = 0, l = 0;\n        s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l));\n    }\n    function Oo(t, e, i) {\n        const s = t.drawingArea, { extra: n, additionalAngle: o, padding: a, size: r } = i, l = t.getPointPosition(e, s + n + a, o), h = Math.round(Y(G(l.angle + E))), c = function(t, e, i) {\n            90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);\n            return t;\n        }(l.y, r.h, h), d = function(t) {\n            if (0 === t || 180 === t) return \"center\";\n            if (t < 180) return \"left\";\n            return \"right\";\n        }(h), u = function(t, e, i) {\n            \"right\" === i ? t -= e : \"center\" === i && (t -= e / 2);\n            return t;\n        }(l.x, r.w, d);\n        return {\n            visible: !0,\n            x: l.x,\n            y: c,\n            textAlign: d,\n            left: u,\n            top: c,\n            right: u + r.w,\n            bottom: c + r.h\n        };\n    }\n    function Ao(t, e) {\n        if (!e) return !0;\n        const { left: i, top: s, right: n, bottom: o } = t;\n        return !(Re({\n            x: i,\n            y: s\n        }, e) || Re({\n            x: i,\n            y: o\n        }, e) || Re({\n            x: n,\n            y: s\n        }, e) || Re({\n            x: n,\n            y: o\n        }, e));\n    }\n    function To(t, e, i) {\n        const { left: n, top: o, right: a, bottom: r } = i, { backdropColor: l } = e;\n        if (!s(l)) {\n            const i = wi(e.borderRadius), s = ki(e.backdropPadding);\n            t.fillStyle = l;\n            const h = n - s.left, c = o - s.top, d = a - n + s.width, u = r - o + s.height;\n            Object.values(i).some((t)=>0 !== t) ? (t.beginPath(), He(t, {\n                x: h,\n                y: c,\n                w: d,\n                h: u,\n                radius: i\n            }), t.fill()) : t.fillRect(h, c, d, u);\n        }\n    }\n    function Lo(t, e, i, s) {\n        const { ctx: n } = t;\n        if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);\n        else {\n            let i = t.getPointPosition(0, e);\n            n.moveTo(i.x, i.y);\n            for(let o = 1; o < s; o++)i = t.getPointPosition(o, e), n.lineTo(i.x, i.y);\n        }\n    }\n    class Eo extends xo {\n        static id = \"radialLinear\";\n        static defaults = {\n            display: !0,\n            animate: !0,\n            position: \"chartArea\",\n            angleLines: {\n                display: !0,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0\n            },\n            grid: {\n                circular: !1\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: !0,\n                callback: ae.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: void 0,\n                backdropPadding: 2,\n                display: !0,\n                font: {\n                    size: 10\n                },\n                callback: (t)=>t,\n                padding: 5,\n                centerPointLabels: !1\n            }\n        };\n        static defaultRoutes = {\n            \"angleLines.color\": \"borderColor\",\n            \"pointLabels.color\": \"color\",\n            \"ticks.color\": \"color\"\n        };\n        static descriptors = {\n            angleLines: {\n                _fallback: \"grid\"\n            }\n        };\n        constructor(t){\n            super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n        }\n        setDimensions() {\n            const t = this._padding = ki(So(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;\n            this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!1);\n            this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            return Math.ceil(this.drawingArea / So(this.options));\n        }\n        generateTickLabels(t) {\n            xo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e)=>{\n                const i = d(this.options.pointLabels.callback, [\n                    t,\n                    e\n                ], this);\n                return i || 0 === i ? i : \"\";\n            }).filter((t, e)=>this.chart.getDataVisibility(e));\n        }\n        fit() {\n            const t = this.options;\n            t.display && t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0);\n        }\n        setCenterPoint(t, e, i, s) {\n            this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));\n        }\n        getIndexAngle(t) {\n            return G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0));\n        }\n        getDistanceFromCenterForValue(t) {\n            if (s(t)) return NaN;\n            const e = this.drawingArea / (this.max - this.min);\n            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n        }\n        getValueForDistanceFromCenter(t) {\n            if (s(t)) return NaN;\n            const e = t / (this.drawingArea / (this.max - this.min));\n            return this.options.reverse ? this.max - e : this.min + e;\n        }\n        getPointLabelContext(t) {\n            const e = this._pointLabels || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return function(t, e, i) {\n                    return Ci(t, {\n                        label: i,\n                        index: e,\n                        type: \"pointLabel\"\n                    });\n                }(this.getContext(), t, i);\n            }\n        }\n        getPointPosition(t, e, i = 0) {\n            const s = this.getIndexAngle(t) - E + i;\n            return {\n                x: Math.cos(s) * e + this.xCenter,\n                y: Math.sin(s) * e + this.yCenter,\n                angle: s\n            };\n        }\n        getPointPositionForValue(t, e) {\n            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n        }\n        getBasePosition(t) {\n            return this.getPointPositionForValue(t || 0, this.getBaseValue());\n        }\n        getPointLabelPosition(t) {\n            const { left: e, top: i, right: s, bottom: n } = this._pointLabelItems[t];\n            return {\n                left: e,\n                top: i,\n                right: s,\n                bottom: n\n            };\n        }\n        drawBackground() {\n            const { backgroundColor: t, grid: { circular: e } } = this.options;\n            if (t) {\n                const i = this.ctx;\n                i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();\n            }\n        }\n        drawGrid() {\n            const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, o = this._pointLabels.length;\n            let a, r, l;\n            if (e.pointLabels.display && function(t, e) {\n                const { ctx: i, options: { pointLabels: s } } = t;\n                for(let n = e - 1; n >= 0; n--){\n                    const e = t._pointLabelItems[n];\n                    if (!e.visible) continue;\n                    const o = s.setContext(t.getPointLabelContext(n));\n                    To(i, o, e);\n                    const a = Si(o.font), { x: r, y: l, textAlign: h } = e;\n                    Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, {\n                        color: o.color,\n                        textAlign: h,\n                        textBaseline: \"middle\"\n                    });\n                }\n            }(this, o), s.display && this.ticks.forEach((t, e)=>{\n                if (0 !== e || 0 === e && this.min < 0) {\n                    r = this.getDistanceFromCenterForValue(t.value);\n                    const i = this.getContext(e), a = s.setContext(i), l = n.setContext(i);\n                    !function(t, e, i, s, n) {\n                        const o = t.ctx, a = e.circular, { color: r, lineWidth: l } = e;\n                        !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash || []), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore());\n                    }(this, a, r, o, l);\n                }\n            }), i.display) {\n                for(t.save(), a = o - 1; a >= 0; a--){\n                    const s = i.setContext(this.getPointLabelContext(a)), { color: n, lineWidth: o } = s;\n                    o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n                }\n                t.restore();\n            }\n        }\n        drawBorder() {}\n        drawLabels() {\n            const t = this.ctx, e = this.options, i = e.ticks;\n            if (!i.display) return;\n            const s = this.getIndexAngle(0);\n            let n, o;\n            t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((s, a)=>{\n                if (0 === a && this.min >= 0 && !e.reverse) return;\n                const r = i.setContext(this.getContext(a)), l = Si(r.font);\n                if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\n                    t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\n                    const e = ki(r.backdropPadding);\n                    t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height);\n                }\n                Ne(t, s.label, 0, -n, l, {\n                    color: r.color,\n                    strokeColor: r.textStrokeColor,\n                    strokeWidth: r.textStrokeWidth\n                });\n            }), t.restore();\n        }\n        drawTitle() {}\n    }\n    const Ro = {\n        millisecond: {\n            common: !0,\n            size: 1,\n            steps: 1e3\n        },\n        second: {\n            common: !0,\n            size: 1e3,\n            steps: 60\n        },\n        minute: {\n            common: !0,\n            size: 6e4,\n            steps: 60\n        },\n        hour: {\n            common: !0,\n            size: 36e5,\n            steps: 24\n        },\n        day: {\n            common: !0,\n            size: 864e5,\n            steps: 30\n        },\n        week: {\n            common: !1,\n            size: 6048e5,\n            steps: 4\n        },\n        month: {\n            common: !0,\n            size: 2628e6,\n            steps: 12\n        },\n        quarter: {\n            common: !1,\n            size: 7884e6,\n            steps: 4\n        },\n        year: {\n            common: !0,\n            size: 3154e7\n        }\n    }, Io = Object.keys(Ro);\n    function zo(t, e) {\n        return t - e;\n    }\n    function Fo(t, e) {\n        if (s(e)) return null;\n        const i = t._adapter, { parser: n, round: o, isoWeekday: r } = t._parseOpts;\n        let l = e;\n        return \"function\" == typeof n && (l = n(l)), a(l) || (l = \"string\" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = \"week\" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, \"isoWeek\", r)), +l);\n    }\n    function Vo(t, e, i, s) {\n        const n = Io.length;\n        for(let o = Io.indexOf(t); o < n - 1; ++o){\n            const t = Ro[Io[o]], n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\n            if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return Io[o];\n        }\n        return Io[n - 1];\n    }\n    function Bo(t, e, i) {\n        if (i) {\n            if (i.length) {\n                const { lo: s, hi: n } = et(i, e);\n                t[i[s] >= e ? i[s] : i[n]] = !0;\n            }\n        } else t[e] = !0;\n    }\n    function Wo(t, e, i) {\n        const s = [], n = {}, o = e.length;\n        let a, r;\n        for(a = 0; a < o; ++a)r = e[a], n[r] = a, s.push({\n            value: r,\n            major: !1\n        });\n        return 0 !== o && i ? function(t, e, i, s) {\n            const n = t._adapter, o = +n.startOf(e[0].value, s), a = e[e.length - 1].value;\n            let r, l;\n            for(r = o; r <= a; r = +n.add(r, 1, s))l = i[r], l >= 0 && (e[l].major = !0);\n            return e;\n        }(t, s, n, i) : s;\n    }\n    class No extends Js {\n        static id = \"time\";\n        static defaults = {\n            bounds: \"data\",\n            adapters: {},\n            time: {\n                parser: !1,\n                unit: !1,\n                round: !1,\n                isoWeekday: !1,\n                minUnit: \"millisecond\",\n                displayFormats: {}\n            },\n            ticks: {\n                source: \"auto\",\n                callback: !1,\n                major: {\n                    enabled: !1\n                }\n            }\n        };\n        constructor(t){\n            super(t), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n        }\n        init(t, e = {}) {\n            const i = t.time || (t.time = {}), s = this._adapter = new Rn._date(t.adapters.date);\n            s.init(e), b(i.displayFormats, s.formats()), this._parseOpts = {\n                parser: i.parser,\n                round: i.round,\n                isoWeekday: i.isoWeekday\n            }, super.init(t), this._normalized = e.normalized;\n        }\n        parse(t, e) {\n            return void 0 === t ? null : Fo(this, t);\n        }\n        beforeLayout() {\n            super.beforeLayout(), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            };\n        }\n        determineDataLimits() {\n            const t = this.options, e = this._adapter, i = t.time.unit || \"day\";\n            let { min: s, max: n, minDefined: o, maxDefined: r } = this.getUserBounds();\n            function l(t) {\n                o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max));\n            }\n            o && r || (l(this._getLabelBounds()), \"ticks\" === t.bounds && \"labels\" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);\n        }\n        _getLabelBounds() {\n            const t = this.getLabelTimestamps();\n            let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n            return t.length && (e = t[0], i = t[t.length - 1]), {\n                min: e,\n                max: i\n            };\n        }\n        buildTicks() {\n            const t = this.options, e = t.time, i = t.ticks, s = \"labels\" === i.source ? this.getLabelTimestamps() : this._generate();\n            \"ticks\" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\n            const n = this.min, o = nt(s, n, this.max);\n            return this._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {\n                for(let o = Io.length - 1; o >= Io.indexOf(i); o--){\n                    const i = Io[o];\n                    if (Ro[i].common && t._adapter.diff(n, s, i) >= e - 1) return i;\n                }\n                return Io[i ? Io.indexOf(i) : 0];\n            }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && \"year\" !== this._unit ? function(t) {\n                for(let e = Io.indexOf(t) + 1, i = Io.length; e < i; ++e)if (Ro[Io[e]].common) return Io[e];\n            }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), Wo(this, o, this._majorUnit);\n        }\n        afterAutoSkip() {\n            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t)=>+t.value));\n        }\n        initOffsets(t = []) {\n            let e, i, s = 0, n = 0;\n            this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);\n            const o = t.length < 3 ? .5 : .25;\n            s = J(s, 0, o), n = J(n, 0, o), this._offsets = {\n                start: s,\n                end: n,\n                factor: 1 / (s + 1 + n)\n            };\n        }\n        _generate() {\n            const t = this._adapter, e = this.min, i = this.max, s = this.options, n = s.time, o = n.unit || Vo(n.minUnit, e, i, this._getLabelCapacity(e)), a = l(s.ticks.stepSize, 1), r = \"week\" === o && n.isoWeekday, h = N(r) || !0 === r, c = {};\n            let d, u, f = e;\n            if (h && (f = +t.startOf(f, \"isoWeek\", r)), f = +t.startOf(f, h ? \"day\" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n            const g = \"data\" === s.ticks.source && this.getDataTimestamps();\n            for(d = f, u = 0; d < i; d = +t.add(d, a, o), u++)Bo(c, d, g);\n            return d !== i && \"ticks\" !== s.bounds && 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t)=>+t);\n        }\n        getLabelForValue(t) {\n            const e = this._adapter, i = this.options.time;\n            return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);\n        }\n        format(t, e) {\n            const i = this.options.time.displayFormats, s = this._unit, n = e || i[s];\n            return this._adapter.format(t, n);\n        }\n        _tickFormatFunction(t, e, i, s) {\n            const n = this.options, o = n.ticks.callback;\n            if (o) return d(o, [\n                t,\n                e,\n                i\n            ], this);\n            const a = n.time.displayFormats, r = this._unit, l = this._majorUnit, h = r && a[r], c = l && a[l], u = i[e], f = l && c && u && u.major;\n            return this._adapter.format(t, s || (f ? c : h));\n        }\n        generateTickLabels(t) {\n            let e, i, s;\n            for(e = 0, i = t.length; e < i; ++e)s = t[e], s.label = this._tickFormatFunction(s.value, e, t);\n        }\n        getDecimalForValue(t) {\n            return null === t ? NaN : (t - this.min) / (this.max - this.min);\n        }\n        getPixelForValue(t) {\n            const e = this._offsets, i = this.getDecimalForValue(t);\n            return this.getPixelForDecimal((e.start + i) * e.factor);\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n            return this.min + i * (this.max - this.min);\n        }\n        _getLabelSize(t) {\n            const e = this.options.ticks, i = this.ctx.measureText(t).width, s = $(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;\n            return {\n                w: i * n + a * o,\n                h: i * o + a * n\n            };\n        }\n        _getLabelCapacity(t) {\n            const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, Wo(this, [\n                t\n            ], this._majorUnit), s), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;\n            return a > 0 ? a : 1;\n        }\n        getDataTimestamps() {\n            let t, e, i = this._cache.data || [];\n            if (i.length) return i;\n            const s = this.getMatchingVisibleMetas();\n            if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\n            for(t = 0, e = s.length; t < e; ++t)i = i.concat(s[t].controller.getAllParsedValues(this));\n            return this._cache.data = this.normalize(i);\n        }\n        getLabelTimestamps() {\n            const t = this._cache.labels || [];\n            let e, i;\n            if (t.length) return t;\n            const s = this.getLabels();\n            for(e = 0, i = s.length; e < i; ++e)t.push(Fo(this, s[e]));\n            return this._cache.labels = this._normalized ? t : this.normalize(t);\n        }\n        normalize(t) {\n            return lt(t.sort(zo));\n        }\n    }\n    function Ho(t, e, i) {\n        let s, n, o, a, r = 0, l = t.length - 1;\n        i ? (e >= t[r].pos && e <= t[l].pos && ({ lo: r, hi: l } = it(t, \"pos\", e)), { pos: s, time: o } = t[r], { pos: n, time: a } = t[l]) : (e >= t[r].time && e <= t[l].time && ({ lo: r, hi: l } = it(t, \"time\", e)), { time: s, pos: o } = t[r], { time: n, pos: a } = t[l]);\n        const h = n - s;\n        return h ? o + (a - o) * (e - s) / h : o;\n    }\n    var jo = Object.freeze({\n        __proto__: null,\n        CategoryScale: class extends Js {\n            static id = \"category\";\n            static defaults = {\n                ticks: {\n                    callback: po\n                }\n            };\n            constructor(t){\n                super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n            }\n            init(t) {\n                const e = this._addedLabels;\n                if (e.length) {\n                    const t = this.getLabels();\n                    for (const { index: i, label: s } of e)t[i] === s && t.splice(i, 1);\n                    this._addedLabels = [];\n                }\n                super.init(t);\n            }\n            parse(t, e) {\n                if (s(t)) return null;\n                const i = this.getLabels();\n                return ((t, e)=>null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1);\n            }\n            determineDataLimits() {\n                const { minDefined: t, maxDefined: e } = this.getUserBounds();\n                let { min: i, max: s } = this.getMinMax(!0);\n                \"ticks\" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;\n            }\n            buildTicks() {\n                const t = this.min, e = this.max, i = this.options.offset, s = [];\n                let n = this.getLabels();\n                n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\n                for(let i = t; i <= e; i++)s.push({\n                    value: i\n                });\n                return s;\n            }\n            getLabelForValue(t) {\n                return po.call(this, t);\n            }\n            configure() {\n                super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n            }\n            getPixelForValue(t) {\n                return \"number\" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n            }\n            getPixelForTick(t) {\n                const e = this.ticks;\n                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n            }\n            getValueForPixel(t) {\n                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n            }\n            getBasePixel() {\n                return this.bottom;\n            }\n        },\n        LinearScale: bo,\n        LogarithmicScale: ko,\n        RadialLinearScale: Eo,\n        TimeScale: No,\n        TimeSeriesScale: class extends No {\n            static id = \"timeseries\";\n            static defaults = No.defaults;\n            constructor(t){\n                super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n            }\n            initOffsets() {\n                const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n                this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t);\n            }\n            buildLookupTable(t) {\n                const { min: e, max: i } = this, s = [], n = [];\n                let o, a, r, l, h;\n                for(o = 0, a = t.length; o < a; ++o)l = t[o], l >= e && l <= i && s.push(l);\n                if (s.length < 2) return [\n                    {\n                        time: e,\n                        pos: 0\n                    },\n                    {\n                        time: i,\n                        pos: 1\n                    }\n                ];\n                for(o = 0, a = s.length; o < a; ++o)h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({\n                    time: l,\n                    pos: o / (a - 1)\n                });\n                return n;\n            }\n            _generate() {\n                const t = this.min, e = this.max;\n                let i = super.getDataTimestamps();\n                return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort((t, e)=>t - e);\n            }\n            _getTimestampsForTable() {\n                let t = this._cache.all || [];\n                if (t.length) return t;\n                const e = this.getDataTimestamps(), i = this.getLabelTimestamps();\n                return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t;\n            }\n            getDecimalForValue(t) {\n                return (Ho(this._table, t) - this._minPos) / this._tableRange;\n            }\n            getValueForPixel(t) {\n                const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n                return Ho(this._table, i * this._tableRange + this._minPos, !0);\n            }\n        }\n    });\n    const $o = [\n        \"rgb(54, 162, 235)\",\n        \"rgb(255, 99, 132)\",\n        \"rgb(255, 159, 64)\",\n        \"rgb(255, 205, 86)\",\n        \"rgb(75, 192, 192)\",\n        \"rgb(153, 102, 255)\",\n        \"rgb(201, 203, 207)\"\n    ], Yo = $o.map((t)=>t.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\n    function Uo(t) {\n        return $o[t % $o.length];\n    }\n    function Xo(t) {\n        return Yo[t % Yo.length];\n    }\n    function qo(t) {\n        let e = 0;\n        return (i, s)=>{\n            const n = t.getDatasetMeta(s).controller;\n            n instanceof jn ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Uo(e++)), e;\n            }(i, e) : n instanceof $n ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Xo(e++)), e;\n            }(i, e) : n && (e = function(t, e) {\n                return t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e;\n            }(i, e));\n        };\n    }\n    function Ko(t) {\n        let e;\n        for(e in t)if (t[e].borderColor || t[e].backgroundColor) return !0;\n        return !1;\n    }\n    var Go = {\n        id: \"colors\",\n        defaults: {\n            enabled: !0,\n            forceOverride: !1\n        },\n        beforeLayout (t, e, i) {\n            if (!i.enabled) return;\n            const { data: { datasets: s }, options: n } = t.config, { elements: o } = n, a = Ko(s) || (r = n) && (r.borderColor || r.backgroundColor) || o && Ko(o) || \"rgba(0,0,0,0.1)\" !== ue.borderColor || \"rgba(0,0,0,0.1)\" !== ue.backgroundColor;\n            var r;\n            if (!i.forceOverride && a) return;\n            const l = qo(t);\n            s.forEach(l);\n        }\n    };\n    function Zo(t) {\n        if (t._decimated) {\n            const e = t._data;\n            delete t._decimated, delete t._data, Object.defineProperty(t, \"data\", {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0,\n                value: e\n            });\n        }\n    }\n    function Jo(t) {\n        t.data.datasets.forEach((t)=>{\n            Zo(t);\n        });\n    }\n    var Qo = {\n        id: \"decimation\",\n        defaults: {\n            algorithm: \"min-max\",\n            enabled: !1\n        },\n        beforeElementsUpdate: (t, e, i)=>{\n            if (!i.enabled) return void Jo(t);\n            const n = t.width;\n            t.data.datasets.forEach((e, o)=>{\n                const { _data: a, indexAxis: r } = e, l = t.getDatasetMeta(o), h = a || e.data;\n                if (\"y\" === Pi([\n                    r,\n                    t.options.indexAxis\n                ])) return;\n                if (!l.controller.supportsDecimation) return;\n                const c = t.scales[l.xAxisID];\n                if (\"linear\" !== c.type && \"time\" !== c.type) return;\n                if (t.options.parsing) return;\n                let { start: d, count: u } = function(t, e) {\n                    const i = e.length;\n                    let s, n = 0;\n                    const { iScale: o } = t, { min: a, max: r, minDefined: l, maxDefined: h } = o.getUserBounds();\n                    return l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {\n                        start: n,\n                        count: s\n                    };\n                }(l, h);\n                if (u <= (i.threshold || 4 * n)) return void Zo(e);\n                let f;\n                switch(s(a) && (e._data = h, delete e.data, Object.defineProperty(e, \"data\", {\n                    configurable: !0,\n                    enumerable: !0,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(t) {\n                        this._data = t;\n                    }\n                })), i.algorithm){\n                    case \"lttb\":\n                        f = function(t, e, i, s, n) {\n                            const o = n.samples || s;\n                            if (o >= i) return t.slice(e, e + i);\n                            const a = [], r = (i - 2) / (o - 2);\n                            let l = 0;\n                            const h = e + i - 1;\n                            let c, d, u, f, g, p = e;\n                            for(a[l++] = t[p], c = 0; c < o - 2; c++){\n                                let s, n = 0, o = 0;\n                                const h = Math.floor((c + 1) * r) + 1 + e, m = Math.min(Math.floor((c + 2) * r) + 1, i) + e, x = m - h;\n                                for(s = h; s < m; s++)n += t[s].x, o += t[s].y;\n                                n /= x, o /= x;\n                                const b = Math.floor(c * r) + 1 + e, _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e, { x: y, y: v } = t[p];\n                                for(u = f = -1, s = b; s < _; s++)f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);\n                                a[l++] = d, p = g;\n                            }\n                            return a[l++] = t[h], a;\n                        }(h, d, u, n, i);\n                        break;\n                    case \"min-max\":\n                        f = function(t, e, i, n) {\n                            let o, a, r, l, h, c, d, u, f, g, p = 0, m = 0;\n                            const x = [], b = e + i - 1, _ = t[e].x, y = t[b].x - _;\n                            for(o = e; o < e + i; ++o){\n                                a = t[o], r = (a.x - _) / y * n, l = a.y;\n                                const e = 0 | r;\n                                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;\n                                else {\n                                    const i = o - 1;\n                                    if (!s(c) && !s(d)) {\n                                        const e = Math.min(c, d), s = Math.max(c, d);\n                                        e !== u && e !== i && x.push({\n                                            ...t[e],\n                                            x: p\n                                        }), s !== u && s !== i && x.push({\n                                            ...t[s],\n                                            x: p\n                                        });\n                                    }\n                                    o > 0 && i !== u && x.push(t[i]), x.push(a), h = e, m = 0, f = g = l, c = d = u = o;\n                                }\n                            }\n                            return x;\n                        }(h, d, u, n);\n                        break;\n                    default:\n                        throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);\n                }\n                e._decimated = f;\n            });\n        },\n        destroy (t) {\n            Jo(t);\n        }\n    };\n    function ta(t, e, i, s) {\n        if (s) return;\n        let n = e[t], o = i[t];\n        return \"angle\" === t && (n = G(n), o = G(o)), {\n            property: t,\n            start: n,\n            end: o\n        };\n    }\n    function ea(t, e, i) {\n        for(; e > t; e--){\n            const t = i[e];\n            if (!isNaN(t.x) && !isNaN(t.y)) break;\n        }\n        return e;\n    }\n    function ia(t, e, i, s) {\n        return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;\n    }\n    function sa(t, e) {\n        let i = [], s = !1;\n        return n(t) ? (s = !0, i = t) : i = function(t, e) {\n            const { x: i = null, y: s = null } = t || {}, n = e.points, o = [];\n            return e.segments.forEach(({ start: t, end: e })=>{\n                e = ea(t, e, n);\n                const a = n[t], r = n[e];\n                null !== s ? (o.push({\n                    x: a.x,\n                    y: s\n                }), o.push({\n                    x: r.x,\n                    y: s\n                })) : null !== i && (o.push({\n                    x: i,\n                    y: a.y\n                }), o.push({\n                    x: i,\n                    y: r.y\n                }));\n            }), o;\n        }(t, e), i.length ? new no({\n            points: i,\n            options: {\n                tension: 0\n            },\n            _loop: s,\n            _fullLoop: s\n        }) : null;\n    }\n    function na(t) {\n        return t && !1 !== t.fill;\n    }\n    function oa(t, e, i) {\n        let s = t[e].fill;\n        const n = [\n            e\n        ];\n        let o;\n        if (!i) return s;\n        for(; !1 !== s && -1 === n.indexOf(s);){\n            if (!a(s)) return s;\n            if (o = t[s], !o) return !1;\n            if (o.visible) return s;\n            n.push(s), s = o.fill;\n        }\n        return !1;\n    }\n    function aa(t, e, i) {\n        const s = function(t) {\n            const e = t.options, i = e.fill;\n            let s = l(i && i.target, i);\n            void 0 === s && (s = !!e.backgroundColor);\n            if (!1 === s || null === s) return !1;\n            if (!0 === s) return \"origin\";\n            return s;\n        }(t);\n        if (o(s)) return !isNaN(s.value) && s;\n        let n = parseFloat(s);\n        return a(n) && Math.floor(n) === n ? function(t, e, i, s) {\n            \"-\" !== t && \"+\" !== t || (i = e + i);\n            if (i === e || i < 0 || i >= s) return !1;\n            return i;\n        }(s[0], e, n, i) : [\n            \"origin\",\n            \"start\",\n            \"end\",\n            \"stack\",\n            \"shape\"\n        ].indexOf(s) >= 0 && s;\n    }\n    function ra(t, e, i) {\n        const s = [];\n        for(let n = 0; n < i.length; n++){\n            const o = i[n], { first: a, last: r, point: l } = la(o, e, \"x\");\n            if (!(!l || a && r)) {\n                if (a) s.unshift(l);\n                else if (t.push(l), !r) break;\n            }\n        }\n        t.push(...s);\n    }\n    function la(t, e, i) {\n        const s = t.interpolate(e, i);\n        if (!s) return {};\n        const n = s[i], o = t.segments, a = t.points;\n        let r = !1, l = !1;\n        for(let t = 0; t < o.length; t++){\n            const e = o[t], s = a[e.start][i], h = a[e.end][i];\n            if (tt(n, s, h)) {\n                r = n === s, l = n === h;\n                break;\n            }\n        }\n        return {\n            first: r,\n            last: l,\n            point: s\n        };\n    }\n    class ha {\n        constructor(t){\n            this.x = t.x, this.y = t.y, this.radius = t.radius;\n        }\n        pathSegment(t, e, i) {\n            const { x: s, y: n, radius: o } = this;\n            return e = e || {\n                start: 0,\n                end: O\n            }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds;\n        }\n        interpolate(t) {\n            const { x: e, y: i, radius: s } = this, n = t.angle;\n            return {\n                x: e + Math.cos(n) * s,\n                y: i + Math.sin(n) * s,\n                angle: n\n            };\n        }\n    }\n    function ca(t) {\n        const { chart: e, fill: i, line: s } = t;\n        if (a(i)) return function(t, e) {\n            const i = t.getDatasetMeta(e), s = i && t.isDatasetVisible(e);\n            return s ? i.dataset : null;\n        }(e, i);\n        if (\"stack\" === i) return function(t) {\n            const { scale: e, index: i, line: s } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {\n                const i = [], s = t.getMatchingVisibleMetas(\"line\");\n                for(let t = 0; t < s.length; t++){\n                    const n = s[t];\n                    if (n.index === e) break;\n                    n.hidden || i.unshift(n.dataset);\n                }\n                return i;\n            }(e, i);\n            r.push(sa({\n                x: null,\n                y: e.bottom\n            }, s));\n            for(let t = 0; t < o.length; t++){\n                const e = o[t];\n                for(let t = e.start; t <= e.end; t++)ra(n, a[t], r);\n            }\n            return new no({\n                points: n,\n                options: {}\n            });\n        }(t);\n        if (\"shape\" === i) return !0;\n        const n = function(t) {\n            const e = t.scale || {};\n            if (e.getPointPositionForValue) return function(t) {\n                const { scale: e, fill: i } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {\n                    let s;\n                    return s = \"start\" === t ? i : \"end\" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s;\n                }(i, e, a), l = [];\n                if (s.grid.circular) {\n                    const t = e.getPointPositionForValue(0, a);\n                    return new ha({\n                        x: t.x,\n                        y: t.y,\n                        radius: e.getDistanceFromCenterForValue(r)\n                    });\n                }\n                for(let t = 0; t < n; ++t)l.push(e.getPointPositionForValue(t, r));\n                return l;\n            }(t);\n            return function(t) {\n                const { scale: e = {}, fill: i } = t, s = function(t, e) {\n                    let i = null;\n                    return \"start\" === t ? i = e.bottom : \"end\" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;\n                }(i, e);\n                if (a(s)) {\n                    const t = e.isHorizontal();\n                    return {\n                        x: t ? s : null,\n                        y: t ? null : s\n                    };\n                }\n                return null;\n            }(t);\n        }(t);\n        return n instanceof ha ? n : sa(n, s);\n    }\n    function da(t, e, i) {\n        const s = ca(e), { line: n, scale: o, axis: a } = e, r = n.options, l = r.fill, h = r.backgroundColor, { above: c = h, below: d = h } = l || {};\n        s && n.points.length && (Ie(t, i), function(t, e) {\n            const { line: i, target: s, above: n, below: o, area: a, scale: r } = e, l = i._loop ? \"angle\" : e.axis;\n            t.save(), \"x\" === l && o !== n && (ua(t, s, a.top), fa(t, {\n                line: i,\n                target: s,\n                color: n,\n                scale: r,\n                property: l\n            }), t.restore(), t.save(), ua(t, s, a.bottom));\n            fa(t, {\n                line: i,\n                target: s,\n                color: o,\n                scale: r,\n                property: l\n            }), t.restore();\n        }(t, {\n            line: n,\n            target: s,\n            above: c,\n            below: d,\n            area: i,\n            scale: o,\n            axis: a\n        }), ze(t));\n    }\n    function ua(t, e, i) {\n        const { segments: s, points: n } = e;\n        let o = !0, a = !1;\n        t.beginPath();\n        for (const r of s){\n            const { start: s, end: l } = r, h = n[s], c = n[ea(s, l, n)];\n            o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\n                move: a\n            }), a ? t.closePath() : t.lineTo(c.x, i);\n        }\n        t.lineTo(e.first().x, i), t.closePath(), t.clip();\n    }\n    function fa(t, e) {\n        const { line: i, target: s, property: n, color: o, scale: a } = e, r = function(t, e, i) {\n            const s = t.segments, n = t.points, o = e.points, a = [];\n            for (const t of s){\n                let { start: s, end: r } = t;\n                r = ea(s, r, n);\n                const l = ta(i, n[s], n[r], t.loop);\n                if (!e.segments) {\n                    a.push({\n                        source: t,\n                        target: l,\n                        start: n[s],\n                        end: n[r]\n                    });\n                    continue;\n                }\n                const h = Ii(e, l);\n                for (const e of h){\n                    const s = ta(i, o[e.start], o[e.end], e.loop), r = Ri(t, n, s);\n                    for (const t of r)a.push({\n                        source: t,\n                        target: e,\n                        start: {\n                            [i]: ia(l, s, \"start\", Math.max)\n                        },\n                        end: {\n                            [i]: ia(l, s, \"end\", Math.min)\n                        }\n                    });\n                }\n            }\n            return a;\n        }(i, s, n);\n        for (const { source: e, target: l, start: h, end: c } of r){\n            const { style: { backgroundColor: r = o } = {} } = e, d = !0 !== s;\n            t.save(), t.fillStyle = r, ga(t, a, d && ta(n, h, c)), t.beginPath();\n            const u = !!i.pathSegment(t, e);\n            let f;\n            if (d) {\n                u ? t.closePath() : pa(t, s, c, n);\n                const e = !!s.pathSegment(t, l, {\n                    move: u,\n                    reverse: !0\n                });\n                f = u && e, f || pa(t, s, h, n);\n            }\n            t.closePath(), t.fill(f ? \"evenodd\" : \"nonzero\"), t.restore();\n        }\n    }\n    function ga(t, e, i) {\n        const { top: s, bottom: n } = e.chart.chartArea, { property: o, start: a, end: r } = i || {};\n        \"x\" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip());\n    }\n    function pa(t, e, i, s) {\n        const n = e.interpolate(i, s);\n        n && t.lineTo(n.x, n.y);\n    }\n    var ma = {\n        id: \"filler\",\n        afterDatasetsUpdate (t, e, i) {\n            const s = (t.data.datasets || []).length, n = [];\n            let o, a, r, l;\n            for(a = 0; a < s; ++a)o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof no && (l = {\n                visible: t.isDatasetVisible(a),\n                index: a,\n                fill: aa(r, a, s),\n                chart: t,\n                axis: o.controller.options.indexAxis,\n                scale: o.vScale,\n                line: r\n            }), o.$filler = l, n.push(l);\n            for(a = 0; a < s; ++a)l = n[a], l && !1 !== l.fill && (l.fill = oa(n, a, i.propagate));\n        },\n        beforeDraw (t, e, i) {\n            const s = \"beforeDraw\" === i.drawTime, n = t.getSortedVisibleDatasetMetas(), o = t.chartArea;\n            for(let e = n.length - 1; e >= 0; --e){\n                const i = n[e].$filler;\n                i && (i.line.updateControlPoints(o, i.axis), s && i.fill && da(t.ctx, i, o));\n            }\n        },\n        beforeDatasetsDraw (t, e, i) {\n            if (\"beforeDatasetsDraw\" !== i.drawTime) return;\n            const s = t.getSortedVisibleDatasetMetas();\n            for(let e = s.length - 1; e >= 0; --e){\n                const i = s[e].$filler;\n                na(i) && da(t.ctx, i, t.chartArea);\n            }\n        },\n        beforeDatasetDraw (t, e, i) {\n            const s = e.meta.$filler;\n            na(s) && \"beforeDatasetDraw\" === i.drawTime && da(t.ctx, s, t.chartArea);\n        },\n        defaults: {\n            propagate: !0,\n            drawTime: \"beforeDatasetDraw\"\n        }\n    };\n    const xa = (t, e)=>{\n        let { boxHeight: i = e, boxWidth: s = e } = t;\n        return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\n            boxWidth: s,\n            boxHeight: i,\n            itemHeight: Math.max(e, i)\n        };\n    };\n    class ba extends Hs {\n        constructor(t){\n            super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e, i) {\n            this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n        }\n        buildLabels() {\n            const t = this.options.labels || {};\n            let e = d(t.generateLabels, [\n                this.chart\n            ], this) || [];\n            t.filter && (e = e.filter((e)=>t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i)=>t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n        }\n        fit() {\n            const { options: t, ctx: e } = this;\n            if (!t.display) return void (this.width = this.height = 0);\n            const i = t.labels, s = Si(i.font), n = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: r } = xa(i, n);\n            let l, h;\n            e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n        }\n        _fitRows(t, e, i, s) {\n            const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [\n                0\n            ], h = s + a;\n            let c = t;\n            n.textAlign = \"left\", n.textBaseline = \"middle\";\n            let d = -1, u = -h;\n            return this.legendItems.forEach((t, f)=>{\n                const g = i + e / 2 + n.measureText(t.text).width;\n                (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\n                    left: 0,\n                    top: u,\n                    row: d,\n                    width: g,\n                    height: s\n                }, l[l.length - 1] += g + a;\n            }), c;\n        }\n        _fitCols(t, e, i, s) {\n            const { ctx: n, maxHeight: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;\n            let c = a, d = 0, u = 0, f = 0, g = 0;\n            return this.legendItems.forEach((t, o)=>{\n                const { itemWidth: p, itemHeight: m } = function(t, e, i, s, n) {\n                    const o = function(t, e, i, s) {\n                        let n = t.text;\n                        n && \"string\" != typeof n && (n = n.reduce((t, e)=>t.length > e.length ? t : e));\n                        return e + i.size / 2 + s.measureText(n).width;\n                    }(s, t, e, i), a = function(t, e, i) {\n                        let s = t;\n                        \"string\" != typeof e.text && (s = _a(e, i));\n                        return s;\n                    }(n, s, e.lineHeight);\n                    return {\n                        itemWidth: o,\n                        itemHeight: a\n                    };\n                }(i, e, n, t, s);\n                o > 0 && u + m + 2 * a > h && (c += d + a, l.push({\n                    width: d,\n                    height: u\n                }), f += d + a, g++, d = u = 0), r[o] = {\n                    left: f,\n                    top: u,\n                    col: g,\n                    width: p,\n                    height: m\n                }, d = Math.max(d, p), u += m + a;\n            }), c += d, l.push({\n                width: d,\n                height: u\n            }), c;\n        }\n        adjustHitBoxes() {\n            if (!this.options.display) return;\n            const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, o = Oi(n, this.left, this.width);\n            if (this.isHorizontal()) {\n                let n = 0, a = ft(i, this.left + s, this.right - this.lineWidths[n]);\n                for (const r of e)n !== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s;\n            } else {\n                let n = 0, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\n                for (const r of e)r.col !== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s;\n            }\n        }\n        isHorizontal() {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n        }\n        draw() {\n            if (this.options.display) {\n                const t = this.ctx;\n                Ie(t, this), this._draw(), ze(t);\n            }\n        }\n        _draw() {\n            const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: n, labels: o } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), { padding: c } = o, d = h.size, u = d / 2;\n            let f;\n            this.drawTitle(), s.textAlign = r.textAlign(\"left\"), s.textBaseline = \"middle\", s.lineWidth = .5, s.font = h.string;\n            const { boxWidth: g, boxHeight: p, itemHeight: m } = xa(o, d), x = this.isHorizontal(), b = this._computeTitleHeight();\n            f = x ? {\n                x: ft(n, this.left + c, this.right - i[0]),\n                y: this.top + c + b,\n                line: 0\n            } : {\n                x: this.left + c,\n                y: ft(n, this.top + b + c, this.bottom - e[0].height),\n                line: 0\n            }, Ai(this.ctx, t.textDirection);\n            const _ = m + c;\n            this.legendItems.forEach((y, v)=>{\n                s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;\n                const M = s.measureText(y.text).width, w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = g + u + M;\n                let S = f.x, P = f.y;\n                r.setWidth(this.width), x ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + b + c, this.bottom - e[f.line].height));\n                if (function(t, e, i) {\n                    if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return;\n                    s.save();\n                    const n = l(i.lineWidth, 1);\n                    if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, \"butt\"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, \"miter\"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {\n                        const a = {\n                            radius: p * Math.SQRT2 / 2,\n                            pointStyle: i.pointStyle,\n                            rotation: i.rotation,\n                            borderWidth: n\n                        }, l = r.xPlus(t, g / 2);\n                        Ee(s, a, l, e + u, o.pointStyleWidth && g);\n                    } else {\n                        const o = e + Math.max((d - p) / 2, 0), a = r.leftForLtr(t, g), l = wi(i.borderRadius);\n                        s.beginPath(), Object.values(l).some((t)=>0 !== t) ? He(s, {\n                            x: a,\n                            y: o,\n                            w: g,\n                            h: p,\n                            radius: l\n                        }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke();\n                    }\n                    s.restore();\n                }(r.x(S), P, y), S = gt(w, S + g + u, x ? S + k : this.right, t.rtl), function(t, e, i) {\n                    Ne(s, i.text, t, e + m / 2, h, {\n                        strikethrough: i.hidden,\n                        textAlign: r.textAlign(i.textAlign)\n                    });\n                }(r.x(S), P, y), x) f.x += k + c;\n                else if (\"string\" != typeof y.text) {\n                    const t = h.lineHeight;\n                    f.y += _a(y, t) + c;\n                } else f.y += _;\n            }), Ti(this.ctx, t.textDirection);\n        }\n        drawTitle() {\n            const t = this.options, e = t.title, i = Si(e.font), s = ki(e.padding);\n            if (!e.display) return;\n            const n = Oi(t.rtl, this.left, this.width), o = this.ctx, a = e.position, r = i.size / 2, l = s.top + r;\n            let h, c = this.left, d = this.width;\n            if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);\n            else {\n                const e = this.columnSizes.reduce((t, e)=>Math.max(t, e.height), 0);\n                h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight());\n            }\n            const u = ft(a, c, c + d);\n            o.textAlign = n.textAlign(ut(a)), o.textBaseline = \"middle\", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i);\n        }\n        _computeTitleHeight() {\n            const t = this.options.title, e = Si(t.font), i = ki(t.padding);\n            return t.display ? e.lineHeight + i.height : 0;\n        }\n        _getLegendItemAt(t, e) {\n            let i, s, n;\n            if (tt(t, this.left, this.right) && tt(e, this.top, this.bottom)) {\n                for(n = this.legendHitBoxes, i = 0; i < n.length; ++i)if (s = n[i], tt(t, s.left, s.left + s.width) && tt(e, s.top, s.top + s.height)) return this.legendItems[i];\n            }\n            return null;\n        }\n        handleEvent(t) {\n            const e = this.options;\n            if (!function(t, e) {\n                if ((\"mousemove\" === t || \"mouseout\" === t) && (e.onHover || e.onLeave)) return !0;\n                if (e.onClick && (\"click\" === t || \"mouseup\" === t)) return !0;\n                return !1;\n            }(t.type, e)) return;\n            const i = this._getLegendItemAt(t.x, t.y);\n            if (\"mousemove\" === t.type || \"mouseout\" === t.type) {\n                const o = this._hoveredItem, a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);\n                o && !a && d(e.onLeave, [\n                    t,\n                    o,\n                    this\n                ], this), this._hoveredItem = i, i && !a && d(e.onHover, [\n                    t,\n                    i,\n                    this\n                ], this);\n            } else i && d(e.onClick, [\n                t,\n                i,\n                this\n            ], this);\n            var s, n;\n        }\n    }\n    function _a(t, e) {\n        return e * (t.text ? t.text.length : 0);\n    }\n    var ya = {\n        id: \"legend\",\n        _element: ba,\n        start (t, e, i) {\n            const s = t.legend = new ba({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, t.legend), delete t.legend;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.legend;\n            as.configure(t, s, i), s.options = i;\n        },\n        afterUpdate (t) {\n            const e = t.legend;\n            e.buildLabels(), e.adjustHitBoxes();\n        },\n        afterEvent (t, e) {\n            e.replay || t.legend.handleEvent(e.event);\n        },\n        defaults: {\n            display: !0,\n            position: \"top\",\n            align: \"center\",\n            fullSize: !0,\n            reverse: !1,\n            weight: 1e3,\n            onClick (t, e, i) {\n                const s = e.datasetIndex, n = i.chart;\n                n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1);\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                color: (t)=>t.chart.options.color,\n                boxWidth: 40,\n                padding: 10,\n                generateLabels (t) {\n                    const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: s, textAlign: n, color: o, useBorderRadius: a, borderRadius: r } } = t.legend.options;\n                    return t._getSortedDatasetMetas().map((t)=>{\n                        const l = t.controller.getStyle(i ? 0 : void 0), h = ki(l.borderWidth);\n                        return {\n                            text: e[t.index].label,\n                            fillStyle: l.backgroundColor,\n                            fontColor: o,\n                            hidden: !t.visible,\n                            lineCap: l.borderCapStyle,\n                            lineDash: l.borderDash,\n                            lineDashOffset: l.borderDashOffset,\n                            lineJoin: l.borderJoinStyle,\n                            lineWidth: (h.width + h.height) / 4,\n                            strokeStyle: l.borderColor,\n                            pointStyle: s || l.pointStyle,\n                            rotation: l.rotation,\n                            textAlign: n || l.textAlign,\n                            borderRadius: a && (r || l.borderRadius),\n                            datasetIndex: t.index\n                        };\n                    }, this);\n                }\n            },\n            title: {\n                color: (t)=>t.chart.options.color,\n                display: !1,\n                position: \"center\",\n                text: \"\"\n            }\n        },\n        descriptors: {\n            _scriptable: (t)=>!t.startsWith(\"on\"),\n            labels: {\n                _scriptable: (t)=>![\n                        \"generateLabels\",\n                        \"filter\",\n                        \"sort\"\n                    ].includes(t)\n            }\n        }\n    };\n    class va extends Hs {\n        constructor(t){\n            super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e) {\n            const i = this.options;\n            if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);\n            this.width = this.right = t, this.height = this.bottom = e;\n            const s = n(i.text) ? i.text.length : 1;\n            this._padding = ki(i.padding);\n            const o = s * Si(i.font).lineHeight + this._padding.height;\n            this.isHorizontal() ? this.height = o : this.width = o;\n        }\n        isHorizontal() {\n            const t = this.options.position;\n            return \"top\" === t || \"bottom\" === t;\n        }\n        _drawArgs(t) {\n            const { top: e, left: i, bottom: s, right: n, options: o } = this, a = o.align;\n            let r, l, h, c = 0;\n            return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : (\"left\" === o.position ? (l = i + t, h = ft(a, s, e), c = -0.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {\n                titleX: l,\n                titleY: h,\n                maxWidth: r,\n                rotation: c\n            };\n        }\n        draw() {\n            const t = this.ctx, e = this.options;\n            if (!e.display) return;\n            const i = Si(e.font), s = i.lineHeight / 2 + this._padding.top, { titleX: n, titleY: o, maxWidth: a, rotation: r } = this._drawArgs(s);\n            Ne(t, e.text, 0, 0, i, {\n                color: e.color,\n                maxWidth: a,\n                rotation: r,\n                textAlign: ut(e.align),\n                textBaseline: \"middle\",\n                translation: [\n                    n,\n                    o\n                ]\n            });\n        }\n    }\n    var Ma = {\n        id: \"title\",\n        _element: va,\n        start (t, e, i) {\n            !function(t, e) {\n                const i = new va({\n                    ctx: t.ctx,\n                    options: e,\n                    chart: t\n                });\n                as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i;\n            }(t, i);\n        },\n        stop (t) {\n            const e = t.titleBlock;\n            as.removeBox(t, e), delete t.titleBlock;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.titleBlock;\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"bold\"\n            },\n            fullSize: !0,\n            padding: 10,\n            position: \"top\",\n            text: \"\",\n            weight: 2e3\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const wa = new WeakMap;\n    var ka = {\n        id: \"subtitle\",\n        start (t, e, i) {\n            const s = new va({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s), wa.set(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, wa.get(t)), wa.delete(t);\n        },\n        beforeUpdate (t, e, i) {\n            const s = wa.get(t);\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"normal\"\n            },\n            fullSize: !0,\n            padding: 0,\n            position: \"top\",\n            text: \"\",\n            weight: 1500\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const Sa = {\n        average (t) {\n            if (!t.length) return !1;\n            let e, i, s = new Set, n = 0, o = 0;\n            for(e = 0, i = t.length; e < i; ++e){\n                const i = t[e].element;\n                if (i && i.hasValue()) {\n                    const t = i.tooltipPosition();\n                    s.add(t.x), n += t.y, ++o;\n                }\n            }\n            if (0 === o || 0 === s.size) return !1;\n            return {\n                x: [\n                    ...s\n                ].reduce((t, e)=>t + e) / s.size,\n                y: n / o\n            };\n        },\n        nearest (t, e) {\n            if (!t.length) return !1;\n            let i, s, n, o = e.x, a = e.y, r = Number.POSITIVE_INFINITY;\n            for(i = 0, s = t.length; i < s; ++i){\n                const s = t[i].element;\n                if (s && s.hasValue()) {\n                    const t = q(e, s.getCenterPoint());\n                    t < r && (r = t, n = s);\n                }\n            }\n            if (n) {\n                const t = n.tooltipPosition();\n                o = t.x, a = t.y;\n            }\n            return {\n                x: o,\n                y: a\n            };\n        }\n    };\n    function Pa(t, e) {\n        return e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n    }\n    function Da(t) {\n        return (\"string\" == typeof t || t instanceof String) && t.indexOf(\"\\n\") > -1 ? t.split(\"\\n\") : t;\n    }\n    function Ca(t, e) {\n        const { element: i, datasetIndex: s, index: n } = e, o = t.getDatasetMeta(s).controller, { label: a, value: r } = o.getLabelAndValue(n);\n        return {\n            chart: t,\n            label: a,\n            parsed: o.getParsed(n),\n            raw: t.data.datasets[s].data[n],\n            formattedValue: r,\n            dataset: o.getDataset(),\n            dataIndex: n,\n            datasetIndex: s,\n            element: i\n        };\n    }\n    function Oa(t, e) {\n        const i = t.chart.ctx, { body: s, footer: n, title: o } = t, { boxWidth: a, boxHeight: r } = e, l = Si(e.bodyFont), h = Si(e.titleFont), c = Si(e.footerFont), d = o.length, f = n.length, g = s.length, p = ki(e.padding);\n        let m = p.height, x = 0, b = s.reduce((t, e)=>t + e.before.length + e.lines.length + e.after.length, 0);\n        if (b += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (b - g) * l.lineHeight + (b - 1) * e.bodySpacing;\n        f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\n        let _ = 0;\n        const y = function(t) {\n            x = Math.max(x, i.measureText(t).width + _);\n        };\n        return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t)=>{\n            u(t.before, y), u(t.lines, y), u(t.after, y);\n        }), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), x += p.width, {\n            width: x,\n            height: m\n        };\n    }\n    function Aa(t, e, i, s) {\n        const { x: n, width: o } = i, { width: a, chartArea: { left: r, right: l } } = t;\n        let h = \"center\";\n        return \"center\" === s ? h = n <= (r + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? h = \"left\" : n >= a - o / 2 && (h = \"right\"), function(t, e, i, s) {\n            const { x: n, width: o } = s, a = i.caretSize + i.caretPadding;\n            return \"left\" === t && n + o + a > e.width || \"right\" === t && n - o - a < 0 || void 0;\n        }(h, t, e, i) && (h = \"center\"), h;\n    }\n    function Ta(t, e, i) {\n        const s = i.yAlign || e.yAlign || function(t, e) {\n            const { y: i, height: s } = e;\n            return i < s / 2 ? \"top\" : i > t.height - s / 2 ? \"bottom\" : \"center\";\n        }(t, i);\n        return {\n            xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s),\n            yAlign: s\n        };\n    }\n    function La(t, e, i, s) {\n        const { caretSize: n, caretPadding: o, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, h = n + o, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(a);\n        let g = function(t, e) {\n            let { x: i, width: s } = t;\n            return \"right\" === e ? i -= s : \"center\" === e && (i -= s / 2), i;\n        }(e, r);\n        const p = function(t, e, i) {\n            let { y: s, height: n } = t;\n            return \"top\" === e ? s += i : s -= \"bottom\" === e ? n + i : n / 2, s;\n        }(e, l, h);\n        return \"center\" === l ? \"left\" === r ? g += h : \"right\" === r && (g -= h) : \"left\" === r ? g -= Math.max(c, u) + n : \"right\" === r && (g += Math.max(d, f) + n), {\n            x: J(g, 0, s.width - e.width),\n            y: J(p, 0, s.height - e.height)\n        };\n    }\n    function Ea(t, e, i) {\n        const s = ki(i.padding);\n        return \"center\" === e ? t.x + t.width / 2 : \"right\" === e ? t.x + t.width - s.right : t.x + s.left;\n    }\n    function Ra(t) {\n        return Pa([], Da(t));\n    }\n    function Ia(t, e) {\n        const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;\n        return i ? t.override(i) : t;\n    }\n    const za = {\n        beforeTitle: e,\n        title (t) {\n            if (t.length > 0) {\n                const e = t[0], i = e.chart.data.labels, s = i ? i.length : 0;\n                if (this && this.options && \"dataset\" === this.options.mode) return e.dataset.label || \"\";\n                if (e.label) return e.label;\n                if (s > 0 && e.dataIndex < s) return i[e.dataIndex];\n            }\n            return \"\";\n        },\n        afterTitle: e,\n        beforeBody: e,\n        beforeLabel: e,\n        label (t) {\n            if (this && this.options && \"dataset\" === this.options.mode) return t.label + \": \" + t.formattedValue || t.formattedValue;\n            let e = t.dataset.label || \"\";\n            e && (e += \": \");\n            const i = t.formattedValue;\n            return s(i) || (e += i), e;\n        },\n        labelColor (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                borderColor: e.borderColor,\n                backgroundColor: e.backgroundColor,\n                borderWidth: e.borderWidth,\n                borderDash: e.borderDash,\n                borderDashOffset: e.borderDashOffset,\n                borderRadius: 0\n            };\n        },\n        labelTextColor () {\n            return this.options.bodyColor;\n        },\n        labelPointStyle (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                pointStyle: e.pointStyle,\n                rotation: e.rotation\n            };\n        },\n        afterLabel: e,\n        afterBody: e,\n        beforeFooter: e,\n        footer: e,\n        afterFooter: e\n    };\n    function Fa(t, e, i, s) {\n        const n = t[e].call(i, s);\n        return void 0 === n ? za[e].call(i, s) : n;\n    }\n    class Va extends Hs {\n        static positioners = Sa;\n        constructor(t){\n            super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n        }\n        initialize(t) {\n            this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n        }\n        _resolveAnimations() {\n            const t = this._cachedAnimations;\n            if (t) return t;\n            const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new Os(this.chart, s);\n            return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;\n        }\n        getContext() {\n            var t, e, i;\n            return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {\n                tooltip: e,\n                tooltipItems: i,\n                type: \"tooltip\"\n            })));\n        }\n        getTitle(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeTitle\", this, t), n = Fa(i, \"title\", this, t), o = Fa(i, \"afterTitle\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        getBeforeBody(t, e) {\n            return Ra(Fa(e.callbacks, \"beforeBody\", this, t));\n        }\n        getBody(t, e) {\n            const { callbacks: i } = e, s = [];\n            return u(t, (t)=>{\n                const e = {\n                    before: [],\n                    lines: [],\n                    after: []\n                }, n = Ia(i, t);\n                Pa(e.before, Da(Fa(n, \"beforeLabel\", this, t))), Pa(e.lines, Fa(n, \"label\", this, t)), Pa(e.after, Da(Fa(n, \"afterLabel\", this, t))), s.push(e);\n            }), s;\n        }\n        getAfterBody(t, e) {\n            return Ra(Fa(e.callbacks, \"afterBody\", this, t));\n        }\n        getFooter(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeFooter\", this, t), n = Fa(i, \"footer\", this, t), o = Fa(i, \"afterFooter\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        _createItems(t) {\n            const e = this._active, i = this.chart.data, s = [], n = [], o = [];\n            let a, r, l = [];\n            for(a = 0, r = e.length; a < r; ++a)l.push(Ca(this.chart, e[a]));\n            return t.filter && (l = l.filter((e, s, n)=>t.filter(e, s, n, i))), t.itemSort && (l = l.sort((e, s)=>t.itemSort(e, s, i))), u(l, (e)=>{\n                const i = Ia(t.callbacks, e);\n                s.push(Fa(i, \"labelColor\", this, e)), n.push(Fa(i, \"labelPointStyle\", this, e)), o.push(Fa(i, \"labelTextColor\", this, e));\n            }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l;\n        }\n        update(t, e) {\n            const i = this.options.setContext(this.getContext()), s = this._active;\n            let n, o = [];\n            if (s.length) {\n                const t = Sa[i.position].call(this, s, this._eventPosition);\n                o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\n                const e = this._size = Oa(this, i), a = Object.assign({}, t, e), r = Ta(this.chart, i, a), l = La(i, a, r, this.chart);\n                this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\n                    opacity: 1,\n                    x: l.x,\n                    y: l.y,\n                    width: e.width,\n                    height: e.height,\n                    caretX: t.x,\n                    caretY: t.y\n                };\n            } else 0 !== this.opacity && (n = {\n                opacity: 0\n            });\n            this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay: e\n            });\n        }\n        drawCaret(t, e, i, s) {\n            const n = this.getCaretPosition(t, i, s);\n            e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);\n        }\n        getCaretPosition(t, e, i) {\n            const { xAlign: s, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: r, topRight: l, bottomLeft: h, bottomRight: c } = wi(a), { x: d, y: u } = t, { width: f, height: g } = e;\n            let p, m, x, b, _, y;\n            return \"center\" === n ? (_ = u + g / 2, \"left\" === s ? (p = d, m = p - o, b = _ + o, y = _ - o) : (p = d + f, m = p + o, b = _ - o, y = _ + o), x = p) : (m = \"left\" === s ? d + Math.max(r, h) + o : \"right\" === s ? d + f - Math.max(l, c) - o : this.caretX, \"top\" === n ? (b = u, _ = b - o, p = m - o, x = m + o) : (b = u + g, _ = b + o, p = m + o, x = m - o), y = b), {\n                x1: p,\n                x2: m,\n                x3: x,\n                y1: b,\n                y2: _,\n                y3: y\n            };\n        }\n        drawTitle(t, e, i) {\n            const s = this.title, n = s.length;\n            let o, a, r;\n            if (n) {\n                const l = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = \"middle\", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r)e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a);\n            }\n        }\n        _drawColorBox(t, e, i, s, n) {\n            const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h } = n, c = Si(n.bodyFont), d = Ea(this, \"left\", n), u = s.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = e.y + f;\n            if (n.usePointStyle) {\n                const e = {\n                    radius: Math.min(h, l) / 2,\n                    pointStyle: r.pointStyle,\n                    rotation: r.rotation,\n                    borderWidth: 1\n                }, i = s.leftForLtr(u, h) + h / 2, o = g + l / 2;\n                t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o);\n            } else {\n                t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\n                const e = s.leftForLtr(u, h), i = s.leftForLtr(s.xPlus(u, 1), h - 2), r = wi(a.borderRadius);\n                Object.values(r).some((t)=>0 !== t) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {\n                    x: e,\n                    y: g,\n                    w: h,\n                    h: l,\n                    radius: r\n                }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {\n                    x: i,\n                    y: g + 1,\n                    w: h - 2,\n                    h: l - 2,\n                    radius: r\n                }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2));\n            }\n            t.fillStyle = this.labelTextColors[i];\n        }\n        drawBody(t, e, i) {\n            const { body: s } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h } = i, c = Si(i.bodyFont);\n            let d = c.lineHeight, f = 0;\n            const g = Oi(i.rtl, this.x, this.width), p = function(i) {\n                e.fillText(i, g.x(t.x + f), t.y + d / 2), t.y += d + n;\n            }, m = g.textAlign(o);\n            let x, b, _, y, v, M, w;\n            for(e.textAlign = o, e.textBaseline = \"middle\", e.font = c.string, t.x = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a && \"right\" !== m ? \"center\" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.length; y < M; ++y){\n                for(x = s[y], b = this.labelTextColors[y], e.fillStyle = b, u(x.before, p), _ = x.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v < w; ++v)p(_[v]), d = c.lineHeight;\n                u(x.after, p);\n            }\n            f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n;\n        }\n        drawFooter(t, e, i) {\n            const s = this.footer, n = s.length;\n            let o, a;\n            if (n) {\n                const r = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = \"middle\", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a)e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;\n            }\n        }\n        drawBackground(t, e, i, s) {\n            const { xAlign: n, yAlign: o } = this, { x: a, y: r } = t, { width: l, height: h } = i, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(s.cornerRadius);\n            e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), \"top\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), \"center\" === o && \"right\" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), \"bottom\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), \"center\" === o && \"left\" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();\n        }\n        _updateAnimationTarget(t) {\n            const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y;\n            if (s || n) {\n                const i = Sa[t.position].call(this, this._active, this._eventPosition);\n                if (!i) return;\n                const o = this._size = Oa(this, t), a = Object.assign({}, i, this._size), r = Ta(e, t, a), l = La(t, a, r, e);\n                s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l));\n            }\n        }\n        _willRender() {\n            return !!this.opacity;\n        }\n        draw(t) {\n            const e = this.options.setContext(this.getContext());\n            let i = this.opacity;\n            if (!i) return;\n            this._updateAnimationTarget(e);\n            const s = {\n                width: this.width,\n                height: this.height\n            }, n = {\n                x: this.x,\n                y: this.y\n            };\n            i = Math.abs(i) < .001 ? 0 : i;\n            const o = ki(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n            e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore());\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t, e) {\n            const i = this._active, s = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.chart.getDatasetMeta(t);\n                if (!i) throw new Error(\"Cannot find a dataset at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            }), n = !f(i, s), o = this._positionChanged(s, e);\n            (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n        }\n        handleEvent(t, e, i = !0) {\n            if (e && this._ignoreReplayEvents) return !1;\n            this._ignoreReplayEvents = !1;\n            const s = this.options, n = this._active || [], o = this._getActiveElements(t, n, e, i), a = this._positionChanged(o, t), r = e || !f(o, n) || a;\n            return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {\n                x: t.x,\n                y: t.y\n            }, this.update(!0, e))), r;\n        }\n        _getActiveElements(t, e, i, s) {\n            const n = this.options;\n            if (\"mouseout\" === t.type) return [];\n            if (!s) return e.filter((t)=>this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index));\n            const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\n            return n.reverse && o.reverse(), o;\n        }\n        _positionChanged(t, e) {\n            const { caretX: i, caretY: s, options: n } = this, o = Sa[n.position].call(this, t, e);\n            return !1 !== o && (i !== o.x || s !== o.y);\n        }\n    }\n    var Ba = {\n        id: \"tooltip\",\n        _element: Va,\n        positioners: Sa,\n        afterInit (t, e, i) {\n            i && (t.tooltip = new Va({\n                chart: t,\n                options: i\n            }));\n        },\n        beforeUpdate (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        reset (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        afterDraw (t) {\n            const e = t.tooltip;\n            if (e && e._willRender()) {\n                const i = {\n                    tooltip: e\n                };\n                if (!1 === t.notifyPlugins(\"beforeTooltipDraw\", {\n                    ...i,\n                    cancelable: !0\n                })) return;\n                e.draw(t.ctx), t.notifyPlugins(\"afterTooltipDraw\", i);\n            }\n        },\n        afterEvent (t, e) {\n            if (t.tooltip) {\n                const i = e.replay;\n                t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);\n            }\n        },\n        defaults: {\n            enabled: !0,\n            external: null,\n            position: \"average\",\n            backgroundColor: \"rgba(0,0,0,0.8)\",\n            titleColor: \"#fff\",\n            titleFont: {\n                weight: \"bold\"\n            },\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleAlign: \"left\",\n            bodyColor: \"#fff\",\n            bodySpacing: 2,\n            bodyFont: {},\n            bodyAlign: \"left\",\n            footerColor: \"#fff\",\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFont: {\n                weight: \"bold\"\n            },\n            footerAlign: \"left\",\n            padding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            boxHeight: (t, e)=>e.bodyFont.size,\n            boxWidth: (t, e)=>e.bodyFont.size,\n            multiKeyBackground: \"#fff\",\n            displayColors: !0,\n            boxPadding: 0,\n            borderColor: \"rgba(0,0,0,0)\",\n            borderWidth: 0,\n            animation: {\n                duration: 400,\n                easing: \"easeOutQuart\"\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"width\",\n                        \"height\",\n                        \"caretX\",\n                        \"caretY\"\n                    ]\n                },\n                opacity: {\n                    easing: \"linear\",\n                    duration: 200\n                }\n            },\n            callbacks: za\n        },\n        defaultRoutes: {\n            bodyFont: \"font\",\n            footerFont: \"font\",\n            titleFont: \"font\"\n        },\n        descriptors: {\n            _scriptable: (t)=>\"filter\" !== t && \"itemSort\" !== t && \"external\" !== t,\n            _indexable: !1,\n            callbacks: {\n                _scriptable: !1,\n                _indexable: !1\n            },\n            animation: {\n                _fallback: !1\n            },\n            animations: {\n                _fallback: \"animation\"\n            }\n        },\n        additionalOptionScopes: [\n            \"interaction\"\n        ]\n    };\n    return An.register(Yn, jo, fo, t), An.helpers = {\n        ...Wi\n    }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = bt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, \"undefined\" != typeof window && (window.Chart = An), An;\n});\n\n//# sourceMappingURL=walkthrough.4026550d.js.map\n","/*!\n * Chart.js v4.4.8\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){\"use strict\";var t=Object.freeze({__proto__:null,get Colors(){return Go},get Decimation(){return Qo},get Filler(){return ma},get Legend(){return ya},get SubTitle(){return ka},get Title(){return Ma},get Tooltip(){return Ba}});function e(){}const i=(()=>{let t=0;return()=>t++})();function s(t){return null==t}function n(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return\"[object\"===e.slice(0,7)&&\"Array]\"===e.slice(-6)}function o(t){return null!==t&&\"[object Object]\"===Object.prototype.toString.call(t)}function a(t){return(\"number\"==typeof t||t instanceof Number)&&isFinite(+t)}function r(t,e){return a(t)?t:e}function l(t,e){return void 0===t?e:t}const h=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100:+t/e,c=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100*e:+t;function d(t,e,i){if(t&&\"function\"==typeof t.call)return t.apply(i,e)}function u(t,e,i,s){let a,r,l;if(n(t))if(r=t.length,s)for(a=r-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<r;a++)e.call(i,t[a],a);else if(o(t))for(l=Object.keys(t),r=l.length,a=0;a<r;a++)e.call(i,t[l[a]],l[a])}function f(t,e){let i,s,n,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,s=t.length;i<s;++i)if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)return!1;return!0}function g(t){if(n(t))return t.map(g);if(o(t)){const e=Object.create(null),i=Object.keys(t),s=i.length;let n=0;for(;n<s;++n)e[i[n]]=g(t[i[n]]);return e}return t}function p(t){return-1===[\"__proto__\",\"prototype\",\"constructor\"].indexOf(t)}function m(t,e,i,s){if(!p(t))return;const n=e[t],a=i[t];o(n)&&o(a)?x(n,a,s):e[t]=g(a)}function x(t,e,i){const s=n(e)?e:[e],a=s.length;if(!o(t))return t;const r=(i=i||{}).merger||m;let l;for(let e=0;e<a;++e){if(l=s[e],!o(l))continue;const n=Object.keys(l);for(let e=0,s=n.length;e<s;++e)r(n[e],t,l,i)}return t}function b(t,e){return x(t,e,{merger:_})}function _(t,e,i){if(!p(t))return;const s=e[t],n=i[t];o(s)&&o(n)?b(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=g(n))}const y={\"\":t=>t,x:t=>t.x,y:t=>t.y};function v(t){const e=t.split(\".\"),i=[];let s=\"\";for(const t of e)s+=t,s.endsWith(\"\\\\\")?s=s.slice(0,-1)+\".\":(i.push(s),s=\"\");return i}function M(t,e){const i=y[e]||(y[e]=function(t){const e=v(t);return t=>{for(const i of e){if(\"\"===i)break;t=t&&t[i]}return t}}(e));return i(t)}function w(t){return t.charAt(0).toUpperCase()+t.slice(1)}const k=t=>void 0!==t,S=t=>\"function\"==typeof t,P=(t,e)=>{if(t.size!==e.size)return!1;for(const i of t)if(!e.has(i))return!1;return!0};function D(t){return\"mouseup\"===t.type||\"click\"===t.type||\"contextmenu\"===t.type}const C=Math.PI,O=2*C,A=O+C,T=Number.POSITIVE_INFINITY,L=C/180,E=C/2,R=C/4,I=2*C/3,z=Math.log10,F=Math.sign;function V(t,e,i){return Math.abs(t-e)<i}function B(t){const e=Math.round(t);t=V(t,e,t/1e3)?e:t;const i=Math.pow(10,Math.floor(z(t))),s=t/i;return(s<=1?1:s<=2?2:s<=5?5:10)*i}function W(t){const e=[],i=Math.sqrt(t);let s;for(s=1;s<i;s++)t%s==0&&(e.push(s),e.push(t/s));return i===(0|i)&&e.push(i),e.sort(((t,e)=>t-e)).pop(),e}function N(t){return!function(t){return\"symbol\"==typeof t||\"object\"==typeof t&&null!==t&&!(Symbol.toPrimitive in t||\"toString\"in t||\"valueOf\"in t)}(t)&&!isNaN(parseFloat(t))&&isFinite(t)}function H(t,e){const i=Math.round(t);return i-e<=t&&i+e>=t}function j(t,e,i){let s,n,o;for(s=0,n=t.length;s<n;s++)o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}function $(t){return t*(C/180)}function Y(t){return t*(180/C)}function U(t){if(!a(t))return;let e=1,i=0;for(;Math.round(t*e)/e!==t;)e*=10,i++;return i}function X(t,e){const i=e.x-t.x,s=e.y-t.y,n=Math.sqrt(i*i+s*s);let o=Math.atan2(s,i);return o<-.5*C&&(o+=O),{angle:o,distance:n}}function q(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function K(t,e){return(t-e+A)%O-C}function G(t){return(t%O+O)%O}function Z(t,e,i,s){const n=G(t),o=G(e),a=G(i),r=G(o-n),l=G(a-n),h=G(n-o),c=G(n-a);return n===o||n===a||s&&o===a||r>l&&h<c}function J(t,e,i){return Math.max(e,Math.min(i,t))}function Q(t){return J(t,-32768,32767)}function tt(t,e,i,s=1e-6){return t>=Math.min(e,i)-s&&t<=Math.max(e,i)+s}function et(t,e,i){i=i||(i=>t[i]<e);let s,n=t.length-1,o=0;for(;n-o>1;)s=o+n>>1,i(s)?o=s:n=s;return{lo:o,hi:n}}const it=(t,e,i,s)=>et(t,i,s?s=>{const n=t[s][e];return n<i||n===i&&t[s+1][e]===i}:s=>t[s][e]<i),st=(t,e,i)=>et(t,i,(s=>t[s][e]>=i));function nt(t,e,i){let s=0,n=t.length;for(;s<n&&t[s]<e;)s++;for(;n>s&&t[n-1]>i;)n--;return s>0||n<t.length?t.slice(s,n):t}const ot=[\"push\",\"pop\",\"shift\",\"splice\",\"unshift\"];function at(t,e){t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,\"_chartjs\",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),ot.forEach((e=>{const i=\"_onData\"+w(e),s=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value(...e){const n=s.apply(this,e);return t._chartjs.listeners.forEach((t=>{\"function\"==typeof t[i]&&t[i](...e)})),n}})})))}function rt(t,e){const i=t._chartjs;if(!i)return;const s=i.listeners,n=s.indexOf(e);-1!==n&&s.splice(n,1),s.length>0||(ot.forEach((e=>{delete t[e]})),delete t._chartjs)}function lt(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const ht=\"undefined\"==typeof window?function(t){return t()}:window.requestAnimationFrame;function ct(t,e){let i=[],s=!1;return function(...n){i=n,s||(s=!0,ht.call(window,(()=>{s=!1,t.apply(e,i)})))}}function dt(t,e){let i;return function(...s){return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}}const ut=t=>\"start\"===t?\"left\":\"end\"===t?\"right\":\"center\",ft=(t,e,i)=>\"start\"===t?e:\"end\"===t?i:(e+i)/2,gt=(t,e,i,s)=>t===(s?\"left\":\"right\")?i:\"center\"===t?(e+i)/2:e;function pt(t,e,i){const n=e.length;let o=0,a=n;if(t._sorted){const{iScale:r,vScale:l,_parsed:h}=t,c=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null,d=r.axis,{min:u,max:f,minDefined:g,maxDefined:p}=r.getUserBounds();if(g){if(o=Math.min(it(h,d,u).lo,i?n:it(e,d,r.getPixelForValue(u)).lo),c){const t=h.slice(0,o+1).reverse().findIndex((t=>!s(t[l.axis])));o-=Math.max(0,t)}o=J(o,0,n-1)}if(p){let t=Math.max(it(h,r.axis,f,!0).hi+1,i?0:it(e,d,r.getPixelForValue(f),!0).hi+1);if(c){const e=h.slice(t-1).findIndex((t=>!s(t[l.axis])));t+=Math.max(0,e)}a=J(t,o,n)-o}else a=n-o}return{start:o,count:a}}function mt(t){const{xScale:e,yScale:i,_scaleRanges:s}=t,n={xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};if(!s)return t._scaleRanges=n,!0;const o=s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;return Object.assign(s,n),o}class xt{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,s){const n=e.listeners[s],o=e.duration;n.forEach((s=>s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)})))}_refresh(){this._request||(this._running=!0,this._request=ht.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((i,s)=>{if(!i.running||!i.items.length)return;const n=i.items;let o,a=n.length-1,r=!1;for(;a>=0;--a)o=n[a],o._active?(o._total>i.duration&&(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());r&&(s.draw(),this._notify(s,i,t,\"progress\")),n.length||(i.running=!1,this._notify(s,i,t,\"complete\"),i.initial=!1),e+=n.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let s=i.length-1;for(;s>=0;--s)i[s].cancel();e.items=[],this._notify(t,e,Date.now(),\"complete\")}remove(t){return this._charts.delete(t)}}var bt=new xt;\n/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */function _t(t){return t+.5|0}const yt=(t,e,i)=>Math.max(Math.min(t,i),e);function vt(t){return yt(_t(2.55*t),0,255)}function Mt(t){return yt(_t(255*t),0,255)}function wt(t){return yt(_t(t/2.55)/100,0,1)}function kt(t){return yt(_t(100*t),0,100)}const St={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Pt=[...\"0123456789ABCDEF\"],Dt=t=>Pt[15&t],Ct=t=>Pt[(240&t)>>4]+Pt[15&t],Ot=t=>(240&t)>>4==(15&t);function At(t){var e=(t=>Ot(t.r)&&Ot(t.g)&&Ot(t.b)&&Ot(t.a))(t)?Dt:Ct;return t?\"#\"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):\"\")(t.a,e):void 0}const Tt=/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function Lt(t,e,i){const s=e*Math.min(i,1-i),n=(e,n=(e+t/30)%12)=>i-s*Math.max(Math.min(n-3,9-n,1),-1);return[n(0),n(8),n(4)]}function Et(t,e,i){const s=(s,n=(s+t/60)%6)=>i-i*e*Math.max(Math.min(n,4-n,1),0);return[s(5),s(3),s(1)]}function Rt(t,e,i){const s=Lt(t,1,.5);let n;for(e+i>1&&(n=1/(e+i),e*=n,i*=n),n=0;n<3;n++)s[n]*=1-e-i,s[n]+=e;return s}function It(t){const e=t.r/255,i=t.g/255,s=t.b/255,n=Math.max(e,i,s),o=Math.min(e,i,s),a=(n+o)/2;let r,l,h;return n!==o&&(h=n-o,l=a>.5?h/(2-n-o):h/(n+o),r=function(t,e,i,s,n){return t===n?(e-i)/s+(e<i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}function zt(t,e,i,s){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(Mt)}function Ft(t,e,i){return zt(Lt,t,e,i)}function Vt(t){return(t%360+360)%360}function Bt(t){const e=Tt.exec(t);let i,s=255;if(!e)return;e[5]!==i&&(s=e[6]?vt(+e[5]):Mt(+e[5]));const n=Vt(+e[2]),o=+e[3]/100,a=+e[4]/100;return i=\"hwb\"===e[1]?function(t,e,i){return zt(Rt,t,e,i)}(n,o,a):\"hsv\"===e[1]?function(t,e,i){return zt(Et,t,e,i)}(n,o,a):Ft(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}const Wt={x:\"dark\",Z:\"light\",Y:\"re\",X:\"blu\",W:\"gr\",V:\"medium\",U:\"slate\",A:\"ee\",T:\"ol\",S:\"or\",B:\"ra\",C:\"lateg\",D:\"ights\",R:\"in\",Q:\"turquois\",E:\"hi\",P:\"ro\",O:\"al\",N:\"le\",M:\"de\",L:\"yello\",F:\"en\",K:\"ch\",G:\"arks\",H:\"ea\",I:\"ightg\",J:\"wh\"},Nt={OiceXe:\"f0f8ff\",antiquewEte:\"faebd7\",aqua:\"ffff\",aquamarRe:\"7fffd4\",azuY:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"0\",blanKedOmond:\"ffebcd\",Xe:\"ff\",XeviTet:\"8a2be2\",bPwn:\"a52a2a\",burlywood:\"deb887\",caMtXe:\"5f9ea0\",KartYuse:\"7fff00\",KocTate:\"d2691e\",cSO:\"ff7f50\",cSnflowerXe:\"6495ed\",cSnsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"ffff\",xXe:\"8b\",xcyan:\"8b8b\",xgTMnPd:\"b8860b\",xWay:\"a9a9a9\",xgYF:\"6400\",xgYy:\"a9a9a9\",xkhaki:\"bdb76b\",xmagFta:\"8b008b\",xTivegYF:\"556b2f\",xSange:\"ff8c00\",xScEd:\"9932cc\",xYd:\"8b0000\",xsOmon:\"e9967a\",xsHgYF:\"8fbc8f\",xUXe:\"483d8b\",xUWay:\"2f4f4f\",xUgYy:\"2f4f4f\",xQe:\"ced1\",xviTet:\"9400d3\",dAppRk:\"ff1493\",dApskyXe:\"bfff\",dimWay:\"696969\",dimgYy:\"696969\",dodgerXe:\"1e90ff\",fiYbrick:\"b22222\",flSOwEte:\"fffaf0\",foYstWAn:\"228b22\",fuKsia:\"ff00ff\",gaRsbSo:\"dcdcdc\",ghostwEte:\"f8f8ff\",gTd:\"ffd700\",gTMnPd:\"daa520\",Way:\"808080\",gYF:\"8000\",gYFLw:\"adff2f\",gYy:\"808080\",honeyMw:\"f0fff0\",hotpRk:\"ff69b4\",RdianYd:\"cd5c5c\",Rdigo:\"4b0082\",ivSy:\"fffff0\",khaki:\"f0e68c\",lavFMr:\"e6e6fa\",lavFMrXsh:\"fff0f5\",lawngYF:\"7cfc00\",NmoncEffon:\"fffacd\",ZXe:\"add8e6\",ZcSO:\"f08080\",Zcyan:\"e0ffff\",ZgTMnPdLw:\"fafad2\",ZWay:\"d3d3d3\",ZgYF:\"90ee90\",ZgYy:\"d3d3d3\",ZpRk:\"ffb6c1\",ZsOmon:\"ffa07a\",ZsHgYF:\"20b2aa\",ZskyXe:\"87cefa\",ZUWay:\"778899\",ZUgYy:\"778899\",ZstAlXe:\"b0c4de\",ZLw:\"ffffe0\",lime:\"ff00\",limegYF:\"32cd32\",lRF:\"faf0e6\",magFta:\"ff00ff\",maPon:\"800000\",VaquamarRe:\"66cdaa\",VXe:\"cd\",VScEd:\"ba55d3\",VpurpN:\"9370db\",VsHgYF:\"3cb371\",VUXe:\"7b68ee\",VsprRggYF:\"fa9a\",VQe:\"48d1cc\",VviTetYd:\"c71585\",midnightXe:\"191970\",mRtcYam:\"f5fffa\",mistyPse:\"ffe4e1\",moccasR:\"ffe4b5\",navajowEte:\"ffdead\",navy:\"80\",Tdlace:\"fdf5e6\",Tive:\"808000\",TivedBb:\"6b8e23\",Sange:\"ffa500\",SangeYd:\"ff4500\",ScEd:\"da70d6\",pOegTMnPd:\"eee8aa\",pOegYF:\"98fb98\",pOeQe:\"afeeee\",pOeviTetYd:\"db7093\",papayawEp:\"ffefd5\",pHKpuff:\"ffdab9\",peru:\"cd853f\",pRk:\"ffc0cb\",plum:\"dda0dd\",powMrXe:\"b0e0e6\",purpN:\"800080\",YbeccapurpN:\"663399\",Yd:\"ff0000\",Psybrown:\"bc8f8f\",PyOXe:\"4169e1\",saddNbPwn:\"8b4513\",sOmon:\"fa8072\",sandybPwn:\"f4a460\",sHgYF:\"2e8b57\",sHshell:\"fff5ee\",siFna:\"a0522d\",silver:\"c0c0c0\",skyXe:\"87ceeb\",UXe:\"6a5acd\",UWay:\"708090\",UgYy:\"708090\",snow:\"fffafa\",sprRggYF:\"ff7f\",stAlXe:\"4682b4\",tan:\"d2b48c\",teO:\"8080\",tEstN:\"d8bfd8\",tomato:\"ff6347\",Qe:\"40e0d0\",viTet:\"ee82ee\",JHt:\"f5deb3\",wEte:\"ffffff\",wEtesmoke:\"f5f5f5\",Lw:\"ffff00\",LwgYF:\"9acd32\"};let Ht;function jt(t){Ht||(Ht=function(){const t={},e=Object.keys(Nt),i=Object.keys(Wt);let s,n,o,a,r;for(s=0;s<e.length;s++){for(a=r=e[s],n=0;n<i.length;n++)o=i[n],r=r.replace(o,Wt[o]);o=parseInt(Nt[a],16),t[r]=[o>>16&255,o>>8&255,255&o]}return t}(),Ht.transparent=[0,0,0,0]);const e=Ht[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const $t=/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;const Yt=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ut=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function Xt(t,e,i){if(t){let s=It(t);s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),t.r=s[0],t.g=s[1],t.b=s[2]}}function qt(t,e){return t?Object.assign(e||{},t):t}function Kt(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(e.a),e}function Gt(t){return\"r\"===t.charAt(0)?function(t){const e=$t.exec(t);let i,s,n,o=255;if(e){if(e[7]!==i){const t=+e[7];o=e[8]?vt(t):yt(255*t,0,255)}return i=+e[1],s=+e[3],n=+e[5],i=255&(e[2]?vt(i):yt(i,0,255)),s=255&(e[4]?vt(s):yt(s,0,255)),n=255&(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}}(t):Bt(t)}class Zt{constructor(t){if(t instanceof Zt)return t;const e=typeof t;let i;var s,n,o;\"object\"===e?i=Kt(t):\"string\"===e&&(o=(s=t).length,\"#\"===s[0]&&(4===o||5===o?n={r:255&17*St[s[1]],g:255&17*St[s[2]],b:255&17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!==o&&9!==o||(n={r:St[s[1]]<<4|St[s[2]],g:St[s[3]]<<4|St[s[4]],b:St[s[5]]<<4|St[s[6]],a:9===o?St[s[7]]<<4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=qt(this._rgb);return t&&(t.a=wt(t.a)),t}set rgb(t){this._rgb=Kt(t)}rgbString(){return this._valid?(t=this._rgb)&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;var t}hexString(){return this._valid?At(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=It(t),i=e[0],s=kt(e[1]),n=kt(e[2]);return t.a<255?`hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,s=t.rgb;let n;const o=e===n?.5:e,a=2*o-1,r=i.a-s.a,l=((a*r==-1?a:(a+r)/(1+a*r))+1)/2;n=1-l,i.r=255&l*i.r+n*s.r+.5,i.g=255&l*i.g+n*s.g+.5,i.b=255&l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,i){const s=Ut(wt(t.r)),n=Ut(wt(t.g)),o=Ut(wt(t.b));return{r:Mt(Yt(s+i*(Ut(wt(e.r))-s))),g:Mt(Yt(n+i*(Ut(wt(e.g))-n))),b:Mt(Yt(o+i*(Ut(wt(e.b))-o))),a:t.a+i*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new Zt(this.rgb)}alpha(t){return this._rgb.a=Mt(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=_t(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Xt(this._rgb,2,t),this}darken(t){return Xt(this._rgb,2,-t),this}saturate(t){return Xt(this._rgb,1,t),this}desaturate(t){return Xt(this._rgb,1,-t),this}rotate(t){return function(t,e){var i=It(t);i[0]=Vt(i[0]+e),i=Ft(i),t.r=i[0],t.g=i[1],t.b=i[2]}(this._rgb,t),this}}function Jt(t){if(t&&\"object\"==typeof t){const e=t.toString();return\"[object CanvasPattern]\"===e||\"[object CanvasGradient]\"===e}return!1}function Qt(t){return Jt(t)?t:new Zt(t)}function te(t){return Jt(t)?t:new Zt(t).saturate(.5).darken(.1).hexString()}const ee=[\"x\",\"y\",\"borderWidth\",\"radius\",\"tension\"],ie=[\"color\",\"borderColor\",\"backgroundColor\"];const se=new Map;function ne(t,e,i){return function(t,e){e=e||{};const i=t+JSON.stringify(e);let s=se.get(i);return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}(e,i).format(t)}const oe={values:t=>n(t)?t:\"\"+t,numeric(t,e,i){if(0===t)return\"0\";const s=this.chart.options.locale;let n,o=t;if(i.length>1){const e=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(e<1e-4||e>1e15)&&(n=\"scientific\"),o=function(t,e){let i=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(i)>=1&&t!==Math.floor(t)&&(i=t-Math.floor(t));return i}(t,i)}const a=z(Math.abs(o)),r=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};return Object.assign(l,this.options.ticks.format),ne(t,s,l)},logarithmic(t,e,i){if(0===t)return\"0\";const s=i[e].significand||t/Math.pow(10,Math.floor(z(t)));return[1,2,3,5,10,15].includes(s)||e>.8*i.length?oe.numeric.call(this,t,e,i):\"\"}};var ae={formatters:oe};const re=Object.create(null),le=Object.create(null);function he(t,e){if(!e)return t;const i=e.split(\".\");for(let e=0,s=i.length;e<s;++e){const s=i[e];t=t[s]||(t[s]=Object.create(null))}return t}function ce(t,e,i){return\"string\"==typeof e?x(he(t,e),i):x(he(t,\"\"),e)}class de{constructor(t,e){this.animation=void 0,this.backgroundColor=\"rgba(0,0,0,0.1)\",this.borderColor=\"rgba(0,0,0,0.1)\",this.color=\"#666\",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=[\"mousemove\",\"mouseout\",\"click\",\"touchstart\",\"touchmove\"],this.font={family:\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",size:12,style:\"normal\",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>te(e.backgroundColor),this.hoverBorderColor=(t,e)=>te(e.borderColor),this.hoverColor=(t,e)=>te(e.color),this.indexAxis=\"x\",this.interaction={mode:\"nearest\",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return ce(this,t,e)}get(t){return he(this,t)}describe(t,e){return ce(le,t,e)}override(t,e){return ce(re,t,e)}route(t,e,i,s){const n=he(this,t),a=he(this,i),r=\"_\"+e;Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[r],e=a[s];return o(t)?Object.assign({},e,t):l(t,e)},set(t){this[r]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ue=new de({_scriptable:t=>!t.startsWith(\"on\"),_indexable:t=>\"events\"!==t,hover:{_fallback:\"interaction\"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set(\"animation\",{delay:void 0,duration:1e3,easing:\"easeOutQuart\",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe(\"animation\",{_fallback:!1,_indexable:!1,_scriptable:t=>\"onProgress\"!==t&&\"onComplete\"!==t&&\"fn\"!==t}),t.set(\"animations\",{colors:{type:\"color\",properties:ie},numbers:{type:\"number\",properties:ee}}),t.describe(\"animations\",{_fallback:\"animation\"}),t.set(\"transitions\",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:\"transparent\"},visible:{type:\"boolean\",duration:0}}},hide:{animations:{colors:{to:\"transparent\"},visible:{type:\"boolean\",easing:\"linear\",fn:t=>0|t}}}})},function(t){t.set(\"layout\",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set(\"scale\",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:\"ticks\",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:\"\",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:\"\",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ae.formatters.values,minor:{},major:{},align:\"center\",crossAlign:\"near\",showLabelBackdrop:!1,backdropColor:\"rgba(255, 255, 255, 0.75)\",backdropPadding:2}}),t.route(\"scale.ticks\",\"color\",\"\",\"color\"),t.route(\"scale.grid\",\"color\",\"\",\"borderColor\"),t.route(\"scale.border\",\"color\",\"\",\"borderColor\"),t.route(\"scale.title\",\"color\",\"\",\"color\"),t.describe(\"scale\",{_fallback:!1,_scriptable:t=>!t.startsWith(\"before\")&&!t.startsWith(\"after\")&&\"callback\"!==t&&\"parser\"!==t,_indexable:t=>\"borderDash\"!==t&&\"tickBorderDash\"!==t&&\"dash\"!==t}),t.describe(\"scales\",{_fallback:\"scale\"}),t.describe(\"scale.ticks\",{_scriptable:t=>\"backdropPadding\"!==t&&\"callback\"!==t,_indexable:t=>\"backdropPadding\"!==t})}]);function fe(){return\"undefined\"!=typeof window&&\"undefined\"!=typeof document}function ge(t){let e=t.parentNode;return e&&\"[object ShadowRoot]\"===e.toString()&&(e=e.host),e}function pe(t,e,i){let s;return\"string\"==typeof t?(s=parseInt(t,10),-1!==t.indexOf(\"%\")&&(s=s/100*e.parentNode[i])):s=t,s}const me=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);function xe(t,e){return me(t).getPropertyValue(e)}const be=[\"top\",\"right\",\"bottom\",\"left\"];function _e(t,e,i){const s={};i=i?\"-\"+i:\"\";for(let n=0;n<4;n++){const o=be[n];s[o]=parseFloat(t[e+\"-\"+o+i])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const ye=(t,e,i)=>(t>0||e>0)&&(!i||!i.shadowRoot);function ve(t,e){if(\"native\"in t)return t;const{canvas:i,currentDevicePixelRatio:s}=e,n=me(i),o=\"border-box\"===n.boxSizing,a=_e(n,\"padding\"),r=_e(n,\"border\",\"width\"),{x:l,y:h,box:c}=function(t,e){const i=t.touches,s=i&&i.length?i[0]:t,{offsetX:n,offsetY:o}=s;let a,r,l=!1;if(ye(n,o,t.target))a=n,r=o;else{const t=e.getBoundingClientRect();a=s.clientX-t.left,r=s.clientY-t.top,l=!0}return{x:a,y:r,box:l}}(t,i),d=a.left+(c&&r.left),u=a.top+(c&&r.top);let{width:f,height:g}=e;return o&&(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}const Me=t=>Math.round(10*t)/10;function we(t,e,i,s){const n=me(t),o=_e(n,\"margin\"),a=pe(n.maxWidth,t,\"clientWidth\")||T,r=pe(n.maxHeight,t,\"clientHeight\")||T,l=function(t,e,i){let s,n;if(void 0===e||void 0===i){const o=t&&ge(t);if(o){const t=o.getBoundingClientRect(),a=me(o),r=_e(a,\"border\",\"width\"),l=_e(a,\"padding\");e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=pe(a.maxWidth,o,\"clientWidth\"),n=pe(a.maxHeight,o,\"clientHeight\")}else e=t.clientWidth,i=t.clientHeight}return{width:e,height:i,maxWidth:s||T,maxHeight:n||T}}(t,e,i);let{width:h,height:c}=l;if(\"content-box\"===n.boxSizing){const t=_e(n,\"border\",\"width\"),e=_e(n,\"padding\");h-=e.width+t.width,c-=e.height+t.height}h=Math.max(0,h-o.width),c=Math.max(0,s?h/s:c-o.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&&!c&&(c=Me(h/2));return(void 0!==e||void 0!==i)&&s&&l.height&&c>l.height&&(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}function ke(t,e,i){const s=e||1,n=Math.floor(t.height*s),o=Math.floor(t.width*s);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const a=t.canvas;return a.style&&(i||!a.style.height&&!a.style.width)&&(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&&(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}const Se=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};fe()&&(window.addEventListener(\"test\",null,e),window.removeEventListener(\"test\",null,e))}catch(t){}return t}();function Pe(t,e){const i=xe(t,e),s=i&&i.match(/^(\\d+)(\\.\\d+)?px$/);return s?+s[1]:void 0}function De(t){return!t||s(t.size)||s(t.family)?null:(t.style?t.style+\" \":\"\")+(t.weight?t.weight+\" \":\"\")+t.size+\"px \"+t.family}function Ce(t,e,i,s,n){let o=e[n];return o||(o=e[n]=t.measureText(n).width,i.push(n)),o>s&&(s=o),s}function Oe(t,e,i,s){let o=(s=s||{}).data=s.data||{},a=s.garbageCollect=s.garbageCollect||[];s.font!==e&&(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;let r=0;const l=i.length;let h,c,d,u,f;for(h=0;h<l;h++)if(u=i[h],null==u||n(u)){if(n(u))for(c=0,d=u.length;c<d;c++)f=u[c],null==f||n(f)||(r=Ce(t,o,a,r,f))}else r=Ce(t,o,a,r,u);t.restore();const g=a.length/2;if(g>i.length){for(h=0;h<g;h++)delete o[a[h]];a.splice(0,g)}return r}function Ae(t,e,i){const s=t.currentDevicePixelRatio,n=0!==i?Math.max(i/2,.5):0;return Math.round((e-n)*s)/s+n}function Te(t,e){(e||t)&&((e=e||t.getContext(\"2d\")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}function Le(t,e,i,s){Ee(t,e,i,s,null)}function Ee(t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=e.pointStyle,g=e.rotation,p=e.radius;let m=(g||0)*L;if(f&&\"object\"==typeof f&&(o=f.toString(),\"[object HTMLImageElement]\"===o||\"[object HTMLCanvasElement]\"===o))return t.save(),t.translate(i,s),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();if(!(isNaN(p)||p<=0)){switch(t.beginPath(),f){default:n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();break;case\"triangle\":c=n?n/2:p,t.moveTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();break;case\"rectRounded\":h=.516*p,l=p-h,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(i-d,s-r,h,m-C,m-E),t.arc(i+u,s-a,h,m-E,m),t.arc(i+d,s+r,h,m,m+E),t.arc(i-u,s+a,h,m+E,m+C),t.closePath();break;case\"rect\":if(!g){l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);break}m+=R;case\"rectRot\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+u,s-a),t.lineTo(i+d,s+r),t.lineTo(i-u,s+a),t.closePath();break;case\"crossRot\":m+=R;case\"cross\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"star\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"line\":a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);break;case\"dash\":t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function Re(t,e,i){return i=i||.5,!e||t&&t.x>e.left-i&&t.x<e.right+i&&t.y>e.top-i&&t.y<e.bottom+i}function Ie(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function ze(t){t.restore()}function Fe(t,e,i,s,n){if(!e)return t.lineTo(i.x,i.y);if(\"middle\"===n){const s=(e.x+i.x)/2;t.lineTo(s,e.y),t.lineTo(s,i.y)}else\"after\"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}function Ve(t,e,i,s){if(!e)return t.lineTo(i.x,i.y);t.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}function Be(t,e,i,s,n){if(n.strikethrough||n.underline){const o=t.measureText(s),a=e-o.actualBoundingBoxLeft,r=e+o.actualBoundingBoxRight,l=i-o.actualBoundingBoxAscent,h=i+o.actualBoundingBoxDescent,c=n.strikethrough?(l+h)/2:h;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}}function We(t,e){const i=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}function Ne(t,e,i,o,a,r={}){const l=n(e)?e:[e],h=r.strokeWidth>0&&\"\"!==r.strokeColor;let c,d;for(t.save(),t.font=a.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,r),c=0;c<l.length;++c)d=l[c],r.backdrop&&We(t,r.backdrop),h&&(r.strokeColor&&(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);t.restore()}function He(t,e){const{x:i,y:s,w:n,h:o,radius:a}=e;t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,1.5*C,C,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,E,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-E,!0),t.lineTo(i+a.topLeft,s)}function je(t,e=[\"\"],i,s,n=(()=>t[0])){const o=i||t;void 0===s&&(s=ti(\"_fallback\",t));const a={[Symbol.toStringTag]:\"Object\",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:i=>je([i,...t],e,o,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete e._keys,delete t[0][i],!0),get:(i,s)=>qe(i,s,(()=>function(t,e,i,s){let n;for(const o of e)if(n=ti(Ue(o,t),i),void 0!==n)return Xe(t,n)?Je(i,s,t,n):n}(s,e,t,i))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>ei(t).includes(e),ownKeys:t=>ei(t),set(t,e,i){const s=t._storage||(t._storage=n());return t[e]=s[e]=i,delete t._keys,!0}})}function $e(t,e,i,s){const a={_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:e=>$e(t,e,i,s),override:n=>$e(t.override(n),e,i,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete t[i],!0),get:(t,e,i)=>qe(t,e,(()=>function(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=t;let h=s[e];S(h)&&l.isScriptable(e)&&(h=function(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=i;if(r.has(t))throw new Error(\"Recursion detected: \"+Array.from(r).join(\"->\")+\"->\"+t);r.add(t);let l=e(o,a||s);r.delete(t),Xe(t,l)&&(l=Je(n._scopes,n,t,l));return l}(e,h,t,i));n(h)&&h.length&&(h=function(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=i;if(void 0!==a.index&&s(t))return e[a.index%e.length];if(o(e[0])){const i=e,s=n._scopes.filter((t=>t!==i));e=[];for(const o of i){const i=Je(s,n,t,o);e.push($e(i,a,r&&r[t],l))}}return e}(e,h,t,l.isIndexable));Xe(e,h)&&(h=$e(h,a,r&&r[e],l));return h}(t,e,i))),getOwnPropertyDescriptor:(e,i)=>e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,i)=>Reflect.has(t,i),ownKeys:()=>Reflect.ownKeys(t),set:(e,i,s)=>(t[i]=s,delete e[i],!0)})}function Ye(t,e={scriptable:!0,indexable:!0}){const{_scriptable:i=e.scriptable,_indexable:s=e.indexable,_allKeys:n=e.allKeys}=t;return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:()=>i,isIndexable:S(s)?s:()=>s}}const Ue=(t,e)=>t?t+w(e):e,Xe=(t,e)=>o(e)&&\"adapters\"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function qe(t,e,i){if(Object.prototype.hasOwnProperty.call(t,e)||\"constructor\"===e)return t[e];const s=i();return t[e]=s,s}function Ke(t,e,i){return S(t)?t(e,i):t}const Ge=(t,e)=>!0===t?e:\"string\"==typeof t?M(e,t):void 0;function Ze(t,e,i,s,n){for(const o of e){const e=Ge(i,o);if(e){t.add(e);const o=Ke(e._fallback,i,n);if(void 0!==o&&o!==i&&o!==s)return o}else if(!1===e&&void 0!==s&&i!==s)return null}return!1}function Je(t,e,i,s){const a=e._rootScopes,r=Ke(e._fallback,i,s),l=[...t,...a],h=new Set;h.add(s);let c=Qe(h,l,i,r||i,s);return null!==c&&((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&&je(Array.from(h),[\"\"],a,r,(()=>function(t,e,i){const s=t._getTarget();e in s||(s[e]={});const a=s[e];if(n(a)&&o(i))return i;return a||{}}(e,i,s))))}function Qe(t,e,i,s,n){for(;i;)i=Ze(t,e,i,s,n);return i}function ti(t,e){for(const i of e){if(!i)continue;const e=i[t];if(void 0!==e)return e}}function ei(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const i of t)for(const t of Object.keys(i).filter((t=>!t.startsWith(\"_\"))))e.add(t);return Array.from(e)}(t._scopes)),e}function ii(t,e,i,s){const{iScale:n}=t,{key:o=\"r\"}=this._parsing,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};return a}const si=Number.EPSILON||1e-14,ni=(t,e)=>e<t.length&&!t[e].skip&&t[e],oi=t=>\"x\"===t?\"y\":\"x\";function ai(t,e,i,s){const n=t.skip?e:t,o=e,a=i.skip?e:i,r=q(o,n),l=q(a,o);let h=r/(r+l),c=l/(r+l);h=isNaN(h)?0:h,c=isNaN(c)?0:c;const d=s*h,u=s*c;return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}function ri(t,e=\"x\"){const i=oi(e),s=t.length,n=Array(s).fill(0),o=Array(s);let a,r,l,h=ni(t,0);for(a=0;a<s;++a)if(r=l,l=h,h=ni(t,a+1),l){if(h){const t=h[e]-l[e];n[a]=0!==t?(h[i]-l[i])/t:0}o[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}!function(t,e,i){const s=t.length;let n,o,a,r,l,h=ni(t,0);for(let c=0;c<s-1;++c)l=h,h=ni(t,c+1),l&&h&&(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r<=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}(t,n,o),function(t,e,i=\"x\"){const s=oi(i),n=t.length;let o,a,r,l=ni(t,0);for(let h=0;h<n;++h){if(a=r,r=l,l=ni(t,h+1),!r)continue;const n=r[i],c=r[s];a&&(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&&(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}}(t,o,e)}function li(t,e,i){return Math.max(Math.min(t,i),e)}function hi(t,e,i,s,n){let o,a,r,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),\"monotone\"===e.cubicInterpolationMode)ri(t,n);else{let i=s?t[t.length-1]:t[0];for(o=0,a=t.length;o<a;++o)r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}e.capBezierPoints&&function(t,e){let i,s,n,o,a,r=Re(t[0],e);for(i=0,s=t.length;i<s;++i)a=o,o=r,r=i<s-1&&Re(t[i+1],e),o&&(n=t[i],a&&(n.cp1x=li(n.cp1x,e.left,e.right),n.cp1y=li(n.cp1y,e.top,e.bottom)),r&&(n.cp2x=li(n.cp2x,e.left,e.right),n.cp2y=li(n.cp2y,e.top,e.bottom)))}(t,i)}const ci=t=>0===t||1===t,di=(t,e,i)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),ui=(t,e,i)=>Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,fi={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*E),easeOutSine:t=>Math.sin(t*E),easeInOutSine:t=>-.5*(Math.cos(C*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>ci(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>ci(t)?t:di(t,.075,.3),easeOutElastic:t=>ci(t)?t:ui(t,.075,.3),easeInOutElastic(t){const e=.1125;return ci(t)?t:t<.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-fi.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},easeInOutBounce:t=>t<.5?.5*fi.easeInBounce(2*t):.5*fi.easeOutBounce(2*t-1)+.5};function gi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}function pi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:\"middle\"===s?i<.5?t.y:e.y:\"after\"===s?i<1?t.y:e.y:i>0?e.y:t.y}}function mi(t,e,i,s){const n={x:t.cp2x,y:t.cp2y},o={x:e.cp1x,y:e.cp1y},a=gi(t,n,i),r=gi(n,o,i),l=gi(o,e,i),h=gi(a,r,i),c=gi(r,l,i);return gi(h,c,i)}const xi=/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,bi=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function _i(t,e){const i=(\"\"+t).match(xi);if(!i||\"normal\"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case\"px\":return t;case\"%\":t/=100}return e*t}const yi=t=>+t||0;function vi(t,e){const i={},s=o(e),n=s?Object.keys(e):e,a=o(t)?s?i=>l(t[i],t[e[i]]):e=>t[e]:()=>t;for(const t of n)i[t]=yi(a(t));return i}function Mi(t){return vi(t,{top:\"y\",right:\"x\",bottom:\"y\",left:\"x\"})}function wi(t){return vi(t,[\"topLeft\",\"topRight\",\"bottomLeft\",\"bottomRight\"])}function ki(t){const e=Mi(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Si(t,e){t=t||{},e=e||ue.font;let i=l(t.size,e.size);\"string\"==typeof i&&(i=parseInt(i,10));let s=l(t.style,e.style);s&&!(\"\"+s).match(bi)&&(console.warn('Invalid font style specified: \"'+s+'\"'),s=void 0);const n={family:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:\"\"};return n.string=De(n),n}function Pi(t,e,i,s){let o,a,r,l=!0;for(o=0,a=t.length;o<a;++o)if(r=t[o],void 0!==r&&(void 0!==e&&\"function\"==typeof r&&(r=r(e),l=!1),void 0!==i&&n(r)&&(r=r[i%r.length],l=!1),void 0!==r))return s&&!l&&(s.cacheable=!1),r}function Di(t,e,i){const{min:s,max:n}=t,o=c(e,(n-s)/2),a=(t,e)=>i&&0===t?0:t+e;return{min:a(s,-Math.abs(o)),max:a(n,o)}}function Ci(t,e){return Object.assign(Object.create(t),e)}function Oi(t,e,i){return t?function(t,e){return{x:i=>t+t+e-i,setWidth(t){e=t},textAlign:t=>\"center\"===t?t:\"right\"===t?\"left\":\"right\",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,i):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Ai(t,e){let i,s;\"ltr\"!==e&&\"rtl\"!==e||(i=t.canvas.style,s=[i.getPropertyValue(\"direction\"),i.getPropertyPriority(\"direction\")],i.setProperty(\"direction\",e,\"important\"),t.prevTextDirection=s)}function Ti(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty(\"direction\",e[0],e[1]))}function Li(t){return\"angle\"===t?{between:Z,compare:K,normalize:G}:{between:tt,compare:(t,e)=>t-e,normalize:t=>t}}function Ei({start:t,end:e,count:i,loop:s,style:n}){return{start:t%i,end:e%i,loop:s&&(e-t+1)%i==0,style:n}}function Ri(t,e,i){if(!i)return[t];const{property:s,start:n,end:o}=i,a=e.length,{compare:r,between:l,normalize:h}=Li(s),{start:c,end:d,loop:u,style:f}=function(t,e,i){const{property:s,start:n,end:o}=i,{between:a,normalize:r}=Li(s),l=e.length;let h,c,{start:d,end:u,loop:f}=t;if(f){for(d+=l,u+=l,h=0,c=l;h<c&&a(r(e[d%l][s]),n,o);++h)d--,u--;d%=l,u%=l}return u<d&&(u+=l),{start:d,end:u,loop:f,style:t.style}}(t,e,i),g=[];let p,m,x,b=!1,_=null;const y=()=>b||l(n,x,p)&&0!==r(n,x),v=()=>!b||0===r(o,p)||l(o,x,p);for(let t=c,i=c;t<=d;++t)m=e[t%a],m.skip||(p=h(m[s]),p!==x&&(b=l(p,n,o),null===_&&y()&&(_=0===r(p,n)?t:i),null!==_&&v()&&(g.push(Ei({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,x=p));return null!==_&&g.push(Ei({start:_,end:d,loop:u,count:a,style:f})),g}function Ii(t,e){const i=[],s=t.segments;for(let n=0;n<s.length;n++){const o=Ri(s[n],t.points,e);o.length&&i.push(...o)}return i}function zi(t,e){const i=t.points,s=t.options.spanGaps,n=i.length;if(!n)return[];const o=!!t._loop,{start:a,end:r}=function(t,e,i,s){let n=0,o=e-1;if(i&&!s)for(;n<e&&!t[n].skip;)n++;for(;n<e&&t[n].skip;)n++;for(n%=e,i&&(o+=n);o>n&&t[o%e].skip;)o--;return o%=e,{start:n,end:o}}(i,n,o,s);if(!0===s)return Fi(t,[{start:a,end:r,loop:o}],i,e);return Fi(t,function(t,e,i,s){const n=t.length,o=[];let a,r=e,l=t[e];for(a=e+1;a<=i;++a){const i=t[a%n];i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&&(e=a)),l=i}return null!==r&&o.push({start:e%n,end:r%n,loop:s}),o}(i,a,r<a?r+n:r,!!t._fullLoop&&0===a&&r===n-1),i,e)}function Fi(t,e,i,s){return s&&s.setContext&&i?function(t,e,i,s){const n=t._chart.getContext(),o=Vi(t.options),{_datasetIndex:a,options:{spanGaps:r}}=t,l=i.length,h=[];let c=o,d=e[0].start,u=d;function f(t,e,s,n){const o=r?-1:1;if(t!==e){for(t+=l;i[t%l].skip;)t-=o;for(;i[e%l].skip;)e+=o;t%l!=e%l&&(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}}for(const t of e){d=r?d:t.start;let e,o=i[d%l];for(u=d+1;u<=t.end;u++){const r=i[u%l];e=Vi(s.setContext(Ci(n,{type:\"segment\",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&&f(d,u-1,t.loop,c),o=r,c=e}d<u-1&&f(d,u-1,t.loop,c)}return h}(t,e,i,s):e}function Vi(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function Bi(t,e){if(!e)return!1;const i=[],s=function(t,e){return Jt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e};return JSON.stringify(t,s)!==JSON.stringify(e,s)}var Wi=Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:Z,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:function(t,e,i,s){void 0!==e&&console.warn(t+': \"'+i+'\" is deprecated. Please use \"'+s+'\" instead')},_descriptors:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:J,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation:pi,_steppedLineTo:Fe,_textX:gt,_toLeftRightCenter:ut,_updateBezierControlPoints:hi,addRoundedRectPath:He,almostEquals:V,almostWhole:H,callback:d,clearCanvas:Te,clipArea:Ie,clone:g,color:Qt,createContext:Ci,debounce:dt,defined:k,distanceBetweenPoints:q,drawPoint:Le,drawPointLegend:Ee,each:u,easingEffects:fi,finiteOrDefault:r,fontString:function(t,e,i){return e+\" \"+t+\"px \"+i},formatNumber:ne,getAngleFromPoint:X,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:xe,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Jt,listenArrayEvents:at,log10:z,merge:x,mergeIf:b,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve:Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});function Ni(t,e,i,n){const{controller:o,data:a,_sorted:r}=t,l=o._cachedMeta.iScale,h=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null;if(l&&e===l.axis&&\"r\"!==e&&r&&a.length){const r=l._reversePixels?st:it;if(!n){const n=r(a,e,i);if(h){const{vScale:e}=o._cachedMeta,{_parsed:i}=t,a=i.slice(0,n.lo+1).reverse().findIndex((t=>!s(t[e.axis])));n.lo-=Math.max(0,a);const r=i.slice(n.hi).findIndex((t=>!s(t[e.axis])));n.hi+=Math.max(0,r)}return n}if(o._sharedOptions){const t=a[0],s=\"function\"==typeof t.getRange&&t.getRange(e);if(s){const t=r(a,e,i-s),n=r(a,e,i+s);return{lo:t.lo,hi:n.hi}}}}return{lo:0,hi:a.length-1}}function Hi(t,e,i,s,n){const o=t.getSortedVisibleDatasetMetas(),a=i[e];for(let t=0,i=o.length;t<i;++t){const{index:i,data:r}=o[t],{lo:l,hi:h}=Ni(o[t],e,a,n);for(let t=l;t<=h;++t){const e=r[t];e.skip||s(e,i,t)}}}function ji(t,e,i,s,n){const o=[];if(!n&&!t.isPointInArea(e))return o;return Hi(t,i,e,(function(i,a,r){(n||Re(i,t.chartArea,0))&&i.inRange(e.x,e.y,s)&&o.push({element:i,datasetIndex:a,index:r})}),!0),o}function $i(t,e,i,s,n,o){let a=[];const r=function(t){const e=-1!==t.indexOf(\"x\"),i=-1!==t.indexOf(\"y\");return function(t,s){const n=e?Math.abs(t.x-s.x):0,o=i?Math.abs(t.y-s.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}(i);let l=Number.POSITIVE_INFINITY;return Hi(t,i,e,(function(i,h,c){const d=i.inRange(e.x,e.y,n);if(s&&!d)return;const u=i.getCenterPoint(n);if(!(!!o||t.isPointInArea(u))&&!d)return;const f=r(e,u);f<l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&&a.push({element:i,datasetIndex:h,index:c})})),a}function Yi(t,e,i,s,n,o){return o||t.isPointInArea(e)?\"r\"!==i||s?$i(t,e,i,s,n,o):function(t,e,i,s){let n=[];return Hi(t,i,e,(function(t,i,o){const{startAngle:a,endAngle:r}=t.getProps([\"startAngle\",\"endAngle\"],s),{angle:l}=X(t,{x:e.x,y:e.y});Z(l,a,r)&&n.push({element:t,datasetIndex:i,index:o})})),n}(t,e,i,n):[]}function Ui(t,e,i,s,n){const o=[],a=\"x\"===i?\"inXRange\":\"inYRange\";let r=!1;return Hi(t,i,e,((t,s,l)=>{t[a]&&t[a](e[i],n)&&(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))})),s&&!r?[]:o}var Xi={evaluateInteractionItems:Hi,modes:{index(t,e,i,s){const n=ve(e,t),o=i.axis||\"x\",a=i.includeInvisible||!1,r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a),l=[];return r.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index,i=t.data[e];i&&!i.skip&&l.push({element:i,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;let r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a);if(r.length>0){const e=r[0].datasetIndex,i=t.getDatasetMeta(e).data;r=[];for(let t=0;t<i.length;++t)r.push({element:i[t],datasetIndex:e,index:t})}return r},point:(t,e,i,s)=>ji(t,ve(e,t),i.axis||\"xy\",s,i.includeInvisible||!1),nearest(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;return Yi(t,n,o,i.intersect,s,a)},x:(t,e,i,s)=>Ui(t,ve(e,t),\"x\",i.intersect,s),y:(t,e,i,s)=>Ui(t,ve(e,t),\"y\",i.intersect,s)}};const qi=[\"left\",\"top\",\"right\",\"bottom\"];function Ki(t,e){return t.filter((t=>t.pos===e))}function Gi(t,e){return t.filter((t=>-1===qi.indexOf(t.pos)&&t.box.axis===e))}function Zi(t,e){return t.sort(((t,i)=>{const s=e?i:t,n=e?t:i;return s.weight===n.weight?s.index-n.index:s.weight-n.weight}))}function Ji(t,e){const i=function(t){const e={};for(const i of t){const{stack:t,pos:s,stackWeight:n}=i;if(!t||!qi.includes(s))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=n}return e}(t),{vBoxMaxWidth:s,hBoxMaxHeight:n}=e;let o,a,r;for(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box,l=i[r.stack],h=l&&r.stackWeight/l.weight;r.horizontal?(r.width=h?h*s:a&&e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&&e.availableHeight)}return i}function Qi(t,e,i,s){return Math.max(t[i],e[i])+Math.max(t[s],e[s])}function ts(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function es(t,e,i,s){const{pos:n,box:a}=i,r=t.maxPadding;if(!o(n)){i.size&&(t[n]-=i.size);const e=s[i.stack]||{size:0,count:1};e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}a.getPadding&&ts(r,a.getPadding());const l=Math.max(0,e.outerWidth-Qi(r,t,\"left\",\"right\")),h=Math.max(0,e.outerHeight-Qi(r,t,\"top\",\"bottom\")),c=l!==t.w,d=h!==t.h;return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}function is(t,e){const i=e.maxPadding;function s(t){const s={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{s[t]=Math.max(e[t],i[t])})),s}return s(t?[\"left\",\"right\"]:[\"top\",\"bottom\"])}function ss(t,e,i,s){const n=[];let o,a,r,l,h,c;for(o=0,a=t.length,h=0;o<a;++o){r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,is(r.horizontal,e));const{same:a,other:d}=es(e,i,r,s);h|=a&&n.length,c=c||d,l.fullSize||n.push(r)}return h&&ss(n,e,i,s)||c}function ns(t,e,i,s,n){t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}function os(t,e,i,s){const n=i.padding;let{x:o,y:a}=e;for(const r of t){const t=r.box,l=s[r.stack]||{count:1,placed:0,weight:1},h=r.stackWeight/l.weight||1;if(r.horizontal){const s=e.w*h,o=l.size||t.height;k(l.start)&&(a=l.start),t.fullSize?ns(t,n.left,a,i.outerWidth-n.right-n.left,o):ns(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}else{const s=e.h*h,a=l.size||t.width;k(l.start)&&(o=l.start),t.fullSize?ns(t,o,n.top,a,i.outerHeight-n.bottom-n.top):ns(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}}e.x=o,e.y=a}var as={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||\"top\",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure(t,e,i){e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight},update(t,e,i,s){if(!t)return;const n=ki(t.options.layout.padding),o=Math.max(e-n.width,0),a=Math.max(i-n.height,0),r=function(t){const e=function(t){const e=[];let i,s,n,o,a,r;for(i=0,s=(t||[]).length;i<s;++i)n=t[i],({position:o,options:{stack:a,stackWeight:r=1}}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r});return e}(t),i=Zi(e.filter((t=>t.box.fullSize)),!0),s=Zi(Ki(e,\"left\"),!0),n=Zi(Ki(e,\"right\")),o=Zi(Ki(e,\"top\"),!0),a=Zi(Ki(e,\"bottom\")),r=Gi(e,\"x\"),l=Gi(e,\"y\");return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ki(e,\"chartArea\"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}(t.boxes),l=r.vertical,h=r.horizontal;u(t.boxes,(t=>{\"function\"==typeof t.beforeLayout&&t.beforeLayout()}));const c=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),f=Object.assign({},n);ts(f,ki(s));const g=Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),p=Ji(l.concat(h),d);ss(r.fullSize,g,d,p),ss(l,g,d,p),ss(h,g,d,p)&&ss(l,g,d,p),function(t){const e=t.maxPadding;function i(i){const s=Math.max(e[i]-t[i],0);return t[i]+=s,s}t.y+=i(\"top\"),t.x+=i(\"left\"),i(\"right\"),i(\"bottom\")}(g),os(r.leftAndTop,g,d,p),g.x+=g.w,g.y+=g.h,os(r.rightAndBottom,g,d,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},u(r.chartArea,(e=>{const i=e.box;Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}))}};class rs{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,s){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){return!0}updateConfig(t){}}class ls extends rs{acquireContext(t){return t&&t.getContext&&t.getContext(\"2d\")||null}updateConfig(t){t.options.animation=!1}}const hs=\"$chartjs\",cs={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\",pointerenter:\"mouseenter\",pointerdown:\"mousedown\",pointermove:\"mousemove\",pointerup:\"mouseup\",pointerleave:\"mouseout\",pointerout:\"mouseout\"},ds=t=>null===t||\"\"===t;const us=!!Se&&{passive:!0};function fs(t,e,i){t&&t.canvas&&t.canvas.removeEventListener(e,i,us)}function gs(t,e){for(const i of t)if(i===e||i.contains(e))return!0}function ps(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.addedNodes,s),e=e&&!gs(i.removedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}function ms(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.removedNodes,s),e=e&&!gs(i.addedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}const xs=new Map;let bs=0;function _s(){const t=window.devicePixelRatio;t!==bs&&(bs=t,xs.forEach(((e,i)=>{i.currentDevicePixelRatio!==t&&e()})))}function ys(t,e,i){const s=t.canvas,n=s&&ge(s);if(!n)return;const o=ct(((t,e)=>{const s=n.clientWidth;i(t,e),s<n.clientWidth&&i()}),window),a=new ResizeObserver((t=>{const e=t[0],i=e.contentRect.width,s=e.contentRect.height;0===i&&0===s||o(i,s)}));return a.observe(n),function(t,e){xs.size||window.addEventListener(\"resize\",_s),xs.set(t,e)}(t,o),a}function vs(t,e,i){i&&i.disconnect(),\"resize\"===e&&function(t){xs.delete(t),xs.size||window.removeEventListener(\"resize\",_s)}(t)}function Ms(t,e,i){const s=t.canvas,n=ct((e=>{null!==t.ctx&&i(function(t,e){const i=cs[t.type]||t.type,{x:s,y:n}=ve(t,e);return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}(e,t))}),t);return function(t,e,i){t&&t.addEventListener(e,i,us)}(s,e,n),n}class ws extends rs{acquireContext(t,e){const i=t&&t.getContext&&t.getContext(\"2d\");return i&&i.canvas===t?(function(t,e){const i=t.style,s=t.getAttribute(\"height\"),n=t.getAttribute(\"width\");if(t[hs]={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||\"block\",i.boxSizing=i.boxSizing||\"border-box\",ds(n)){const e=Pe(t,\"width\");void 0!==e&&(t.width=e)}if(ds(s))if(\"\"===t.style.height)t.height=t.width/(e||2);else{const e=Pe(t,\"height\");void 0!==e&&(t.height=e)}}(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[hs])return!1;const i=e[hs].initial;[\"height\",\"width\"].forEach((t=>{const n=i[t];s(n)?e.removeAttribute(t):e.setAttribute(t,n)}));const n=i.style||{};return Object.keys(n).forEach((t=>{e.style[t]=n[t]})),e.width=e.width,delete e[hs],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),n={attach:ps,detach:ms,resize:ys}[e]||Ms;s[e]=n(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:vs,detach:vs,resize:vs}[e]||fs)(t,e,s),i[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,s){return we(t,e,i,s)}isAttached(t){const e=t&&ge(t);return!(!e||!e.isConnected)}}function ks(t){return!fe()||\"undefined\"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?ls:ws}var Ss=Object.freeze({__proto__:null,BasePlatform:rs,BasicPlatform:ls,DomPlatform:ws,_detectPlatform:ks});const Ps=\"transparent\",Ds={boolean:(t,e,i)=>i>.5?e:t,color(t,e,i){const s=Qt(t||Ps),n=s.valid&&Qt(e||Ps);return n&&n.valid?n.mix(s,i).hexString():e},number:(t,e,i)=>t+(e-t)*i};class Cs{constructor(t,e,i,s){const n=e[i];s=Pi([t.to,s,n,t.from]);const o=Pi([t.from,n,s]);this._active=!0,this._fn=t.fn||Ds[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const s=this._target[this._prop],n=i-this._start,o=this._duration-n;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,n=this._from,o=this._loop,a=this._to;let r;if(this._active=n!==a&&(o||e<i),!this._active)return this._target[s]=a,void this._notify(!0);e<0?this._target[s]=n:(r=e/i%2,r=o&&r>1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,i)=>{t.push({res:e,rej:i})}))}_notify(t){const e=t?\"res\":\"rej\",i=this._promises||[];for(let t=0;t<i.length;t++)i[t][e]()}}class Os{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!o(t))return;const e=Object.keys(ue.animation),i=this._properties;Object.getOwnPropertyNames(t).forEach((s=>{const a=t[s];if(!o(a))return;const r={};for(const t of e)r[t]=a[t];(n(a.properties)&&a.properties||[s]).forEach((t=>{t!==s&&i.has(t)||i.set(t,r)}))}))}_animateOptions(t,e){const i=e.options,s=function(t,e){if(!e)return;let i=t.options;if(!i)return void(t.options=e);i.$shared&&(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));return i}(t,i);if(!s)return[];const n=this._createAnimations(s,i);return i.$shared&&function(t,e){const i=[],s=Object.keys(e);for(let e=0;e<s.length;e++){const n=t[s[e]];n&&n.active()&&i.push(n.wait())}return Promise.all(i)}(t.options.$animations,i).then((()=>{t.options=i}),(()=>{})),n}_createAnimations(t,e){const i=this._properties,s=[],n=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];if(\"$\"===l.charAt(0))continue;if(\"options\"===l){s.push(...this._animateOptions(t,e));continue}const h=e[l];let c=n[l];const d=i.get(l);if(c){if(d&&c.active()){c.update(d,h,a);continue}c.cancel()}d&&d.duration?(n[l]=c=new Cs(d,t,l,h),s.push(c)):t[l]=h}return s}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const i=this._createAnimations(t,e);return i.length?(bt.add(this._chart,i),!0):void 0}}function As(t,e){const i=t&&t.options||{},s=i.reverse,n=void 0===i.min?e:0,o=void 0===i.max?e:0;return{start:s?o:n,end:s?n:o}}function Ts(t,e){const i=[],s=t._getSortedDatasetMetas(e);let n,o;for(n=0,o=s.length;n<o;++n)i.push(s[n].index);return i}function Ls(t,e,i,s={}){const n=t.keys,o=\"single\"===s.mode;let r,l,h,c;if(null===e)return;let d=!1;for(r=0,l=n.length;r<l;++r){if(h=+n[r],h===i){if(d=!0,s.all)continue;break}c=t.values[h],a(c)&&(o||0===e||F(e)===F(c))&&(e+=c)}return d||s.all?e:0}function Es(t,e){const i=t&&t.options.stacked;return i||void 0===i&&void 0!==e.stack}function Rs(t,e,i){const s=t[e]||(t[e]={});return s[i]||(s[i]={})}function Is(t,e,i,s){for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=t[n.index];if(i&&e>0||!i&&e<0)return n.index}return null}function zs(t,e){const{chart:i,_cachedMeta:s}=t,n=i._stacks||(i._stacks={}),{iScale:o,vScale:a,index:r}=s,l=o.axis,h=a.axis,c=function(t,e,i){return`${t.id}.${e.id}.${i.stack||i.type}`}(o,a,s),d=e.length;let u;for(let t=0;t<d;++t){const i=e[t],{[l]:o,[h]:d}=i;u=(i._stacks||(i._stacks={}))[h]=Rs(n,c,o),u[r]=d,u._top=Is(u,a,!0,s.type),u._bottom=Is(u,a,!1,s.type);(u._visualValues||(u._visualValues={}))[r]=d}}function Fs(t,e){const i=t.scales;return Object.keys(i).filter((t=>i[t].axis===e)).shift()}function Vs(t,e){const i=t.controller.index,s=t.vScale&&t.vScale.axis;if(s){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[s]||void 0===e[s][i])return;delete e[s][i],void 0!==e[s]._visualValues&&void 0!==e[s]._visualValues[i]&&delete e[s]._visualValues[i]}}}const Bs=t=>\"reset\"===t||\"none\"===t,Ws=(t,e)=>e?t:Object.assign({},t);class Ns{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Es(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled(\"filler\")&&console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\")}updateIndex(t){this.index!==t&&Vs(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(t,e,i,s)=>\"x\"===t?e:\"r\"===t?s:i,n=e.xAxisID=l(i.xAxisID,Fs(t,\"x\")),o=e.yAxisID=l(i.yAxisID,Fs(t,\"y\")),a=e.rAxisID=l(i.rAxisID,Fs(t,\"r\")),r=e.indexAxis,h=e.iAxisID=s(r,n,o,a),c=e.vAxisID=s(r,o,n,a);e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update(\"reset\")}_destroy(){const t=this._cachedMeta;this._data&&rt(this._data,this),t._stacked&&Vs(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;if(o(e)){const t=this._cachedMeta;this._data=function(t,e){const{iScale:i,vScale:s}=e,n=\"x\"===i.axis?\"x\":\"y\",o=\"x\"===s.axis?\"x\":\"y\",a=Object.keys(t),r=new Array(a.length);let l,h,c;for(l=0,h=a.length;l<h;++l)c=a[l],r[l]={[n]:c,[o]:t[c]};return r}(e,t)}else if(i!==e){if(i){rt(i,this);const t=this._cachedMeta;Vs(t),t._parsed=[]}e&&Object.isExtensible(e)&&at(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const n=e._stacked;e._stacked=Es(e.vScale,e),e.stack!==i.stack&&(s=!0,Vs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&&(zs(this,e._parsed),e._stacked=Es(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:a,_stacked:r}=i,l=a.axis;let h,c,d,u=0===t&&e===s.length||i._sorted,f=t>0&&i._parsed[t-1];if(!1===this._parsing)i._parsed=s,i._sorted=!0,d=s;else{d=n(s[t])?this.parseArrayData(i,s,t,e):o(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);const a=()=>null===c[l]||f&&c[l]<f[l];for(h=0;h<e;++h)i._parsed[h+t]=c=d[h],u&&(a()&&(u=!1),f=c);i._sorted=u}r&&zs(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=t,a=n.axis,r=o.axis,l=n.getLabels(),h=n===o,c=new Array(s);let d,u,f;for(d=0,u=s;d<u;++d)f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};return c}parseArrayData(t,e,i,s){const{xScale:n,yScale:o}=t,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};return a}parseObjectData(t,e,i,s){const{xScale:n,yScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=new Array(s);let h,c,d,u;for(h=0,c=s;h<c;++h)d=h+i,u=e[d],l[h]={x:n.parse(M(u,a),d),y:o.parse(M(u,r),d)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,i){const s=this.chart,n=this._cachedMeta,o=e[t.axis];return Ls({keys:Ts(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}updateRangeFromParsed(t,e,i,s){const n=i[e.axis];let o=null===n?NaN:n;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=Ls(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,n=i._sorted&&t===i.iScale,o=s.length,r=this._getOtherScale(t),l=((t,e,i)=>t&&!e.hidden&&e._stacked&&{keys:Ts(i,!0),values:null})(e,i,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:d}=function(t){const{min:e,max:i,minDefined:s,maxDefined:n}=t.getUserBounds();return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}(r);let u,f;function g(){f=s[u];const e=f[r.axis];return!a(f[t.axis])||c>e||d<e}for(u=0;u<o&&(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);if(n)for(u=o-1;u>=0;--u)if(!g()){this.updateRangeFromParsed(h,t,f,l);break}return h}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s][t.axis],a(o)&&i.push(o);return i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,n=this.getParsed(t);return{label:i?\"\"+i.getLabelForValue(n[i.axis]):\"\",value:s?\"\"+s.getLabelForValue(n[s.axis]):\"\"}}_update(t){const e=this._cachedMeta;this.update(t||\"default\"),e._clip=function(t){let e,i,s,n;return o(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}(l(this.options.clip,function(t,e,i){if(!1===i)return!1;const s=As(t,i),n=As(e,i);return{top:n.end,right:s.end,bottom:n.start,left:s.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],n=e.chartArea,o=[],a=this._drawStart||0,r=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,n,a,r),h=a;h<a+r;++h){const e=s[h];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(h=0;h<o.length;++h)o[h].draw(t,n)}getStyle(t,e){const i=e?\"active\":\"default\";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let n;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){return Ci(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:\"default\",type:\"data\"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}else n=this.$context||(this.$context=function(t,e){return Ci(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:\"default\",type:\"dataset\"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;return n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e=\"default\",i){const s=\"active\"===e,n=this._cachedDataOpts,o=t+\"-\"+e,a=n[o],r=this.enableOptionSharing&&k(i);if(a)return Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,\"hover\",t,\"\"]:[t,\"\"],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getContext(i,s,e)),c);return f.$shared&&(f.$shared=r,n[o]=Object.freeze(Ws(f,r))),f}_resolveAnimations(t,e,i){const s=this.chart,n=this._cachedDataOpts,o=`animation-${e}`,a=n[o];if(a)return a;let r;if(!1!==s.options.animation){const s=this.chart.config,n=s.datasetAnimationScopeKeys(this._type,e),o=s.getOptionScopes(this.getDataset(),n);r=s.createResolver(o,this.getContext(t,i,e))}const l=new Os(s,r&&r.animations);return r&&r._cacheable&&(n[o]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||Bs(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const i=this.resolveDataElementOptions(t,e),s=this._sharedOptions,n=this.getSharedOptions(i),o=this.includeOptions(e,n)||n!==s;return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}updateElement(t,e,i,s){Bs(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!Bs(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const n=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[t,e,i]of this._syncList)this[t](e,i);this._syncList=[];const s=i.length,n=e.length,o=Math.min(n,s);o&&this.parse(0,o),n>s?this._insertElements(s,n-s,t):n<s&&this._removeElements(n,s-n)}_insertElements(t,e,i=!0){const s=this._cachedMeta,n=s.data,o=t+e;let a;const r=t=>{for(t.length+=e,a=t.length-1;a>=o;a--)t[a]=t[a-e]};for(r(n),a=t;a<o;++a)n[a]=new this.dataElementType;this._parsing&&r(s._parsed),this.parse(t,e),i&&this.updateElements(n,t,e,\"reset\")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;if(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&Vs(i,s)}i.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync([\"_insertElements\",this.getDataset().data.length-t,t])}_onDataPop(){this._sync([\"_removeElements\",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync([\"_removeElements\",0,1])}_onDataSplice(t,e){e&&this._sync([\"_removeElements\",t,e]);const i=arguments.length-2;i&&this._sync([\"_insertElements\",t,i])}_onDataUnshift(){this._sync([\"_insertElements\",0,arguments.length])}}class Hs{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}hasValue(){return N(this.x)&&N(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const s={};return t.forEach((t=>{s[t]=i[t]&&i[t].active()?i[t]._to:this[t]})),s}}function js(t,e){const i=t.options.ticks,n=function(t){const e=t.options.offset,i=t._tickSize(),s=t._length/i+(e?0:1),n=t._maxLength/i;return Math.floor(Math.min(s,n))}(t),o=Math.min(i.maxTicksLimit||n,n),a=i.major.enabled?function(t){const e=[];let i,s;for(i=0,s=t.length;i<s;i++)t[i].major&&e.push(i);return e}(e):[],r=a.length,l=a[0],h=a[r-1],c=[];if(r>o)return function(t,e,i,s){let n,o=0,a=i[0];for(s=Math.ceil(s),n=0;n<t.length;n++)n===a&&(e.push(t[n]),o++,a=i[o*s])}(e,c,a,r/o),c;const d=function(t,e,i){const s=function(t){const e=t.length;let i,s;if(e<2)return!1;for(s=t[0],i=1;i<e;++i)if(t[i]-t[i-1]!==s)return!1;return s}(t),n=e.length/i;if(!s)return Math.max(n,1);const o=W(s);for(let t=0,e=o.length-1;t<e;t++){const e=o[t];if(e>n)return e}return Math.max(n,1)}(a,e,o);if(r>0){let t,i;const n=r>1?Math.round((h-l)/(r-1)):null;for($s(e,c,d,s(n)?0:l-n,l),t=0,i=r-1;t<i;t++)$s(e,c,d,a[t],a[t+1]);return $s(e,c,d,h,s(n)?e.length:h+n),c}return $s(e,c,d),c}function $s(t,e,i,s,n){const o=l(s,0),a=Math.min(l(n,t.length),t.length);let r,h,c,d=0;for(i=Math.ceil(i),n&&(r=n-s,i=r/Math.floor(r/i)),c=o;c<0;)d++,c=Math.round(o+d*i);for(h=Math.max(o,0);h<a;h++)h===c&&(e.push(t[h]),d++,c=Math.round(o+d*i))}const Ys=(t,e,i)=>\"top\"===e||\"left\"===e?t[e]+i:t[e]-i,Us=(t,e)=>Math.min(e||t,t);function Xs(t,e){const i=[],s=t.length/e,n=t.length;let o=0;for(;o<n;o+=s)i.push(t[Math.floor(o)]);return i}function qs(t,e,i){const s=t.ticks.length,n=Math.min(e,s-1),o=t._startPixel,a=t._endPixel,r=1e-6;let l,h=t.getPixelForTick(n);if(!(i&&(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n<e?l:-l,h<o-r||h>a+r)))return h}function Ks(t){return t.drawTicks?t.tickLength:0}function Gs(t,e){if(!t.display)return 0;const i=Si(t.font,e),s=ki(t.padding);return(n(t.text)?t.text.length:1)*i.lineHeight+s.height}function Zs(t,e,i){let s=ut(t);return(i&&\"right\"!==e||!i&&\"right\"===e)&&(s=(t=>\"left\"===t?\"right\":\"right\"===t?\"left\":t)(s)),s}class Js extends Hs{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=r(t,Number.POSITIVE_INFINITY),e=r(e,Number.NEGATIVE_INFINITY),i=r(i,Number.POSITIVE_INFINITY),s=r(s,Number.NEGATIVE_INFINITY),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}getMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=this.getUserBounds();if(n&&o)return{min:i,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r)e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));return i=o&&i>s?s:i,s=n&&i>s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){d(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Di(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?Xs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||\"auto\"===o.source)&&(this.ticks=js(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,i=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){d(this.options.afterUpdate,[this])}beforeSetDimensions(){d(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){d(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}beforeDataLimits(){this._callHooks(\"beforeDataLimits\")}determineDataLimits(){}afterDataLimits(){this._callHooks(\"afterDataLimits\")}beforeBuildTicks(){this._callHooks(\"beforeBuildTicks\")}buildTicks(){return[]}afterBuildTicks(){this._callHooks(\"afterBuildTicks\")}beforeTickToLabelConversion(){d(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,s,n;for(i=0,s=t.length;i<s;i++)n=t[i],n.label=d(e.callback,[n.value,i,t],this)}afterTickToLabelConversion(){d(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){d(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=Us(this.ticks.length,t.ticks.maxTicksLimit),s=e.minRotation||0,n=e.maxRotation;let o,a,r,l=s;if(!this._isVisible()||!e.display||s>=n||i<=1||!this.isHorizontal())return void(this.labelRotation=s);const h=this._getLabelSizes(),c=h.widest.width,d=h.highest.height,u=J(this.chart.width-c,0,this.maxWidth);o=t.offset?this.maxWidth/i:u/(i-1),c+6>o&&(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ks(t.grid)-e.padding-Gs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin(J((h.highest.height+6)/o,-1,1)),Math.asin(J(a/r,-1,1))-Math.asin(J(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}afterCalculateLabelRotation(){d(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){d(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:n}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const o=Gs(s,e.options.font);if(a?(t.width=this.maxWidth,t.height=Ks(n)+o):(t.height=this.maxHeight,t.width=Ks(n)+o),i.display&&this.ticks.length){const{first:e,last:s,widest:n,highest:o}=this._getLabelSizes(),r=2*i.padding,l=$(this.labelRotation),h=Math.cos(l),c=Math.sin(l);if(a){const e=i.mirror?0:c*n.width+h*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=i.mirror?0:h*n.width+c*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,s,c,h)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=this.options,r=0!==this.labelRotation,l=\"top\"!==a&&\"x\"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let c=0,d=0;r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):\"start\"===n?d=e.width:\"end\"===n?c=t.width:\"inner\"!==n&&(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let i=e.height/2,s=t.height/2;\"start\"===n?(i=0,s=t.height):\"end\"===n&&(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){d(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return\"top\"===e||\"bottom\"===e||\"x\"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)s(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Xs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=this,r=[],l=[],h=Math.floor(e/Us(e,i));let c,d,f,g,p,m,x,b,_,y,v,M=0,w=0;for(c=0;c<e;c+=h){if(g=t[c].label,p=this._resolveTickFontOptions(c),o.font=m=p.string,x=a[m]=a[m]||{data:{},gc:[]},b=p.lineHeight,_=y=0,s(g)||n(g)){if(n(g))for(d=0,f=g.length;d<f;++d)v=g[d],s(v)||n(v)||(_=Ce(o,x.data,x.gc,_,v),y+=b)}else _=Ce(o,x.data,x.gc,_,g),y=b;r.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}!function(t,e){u(t,(t=>{const i=t.gc,s=i.length/2;let n;if(s>e){for(n=0;n<s;++n)delete t.data[i[n]];i.splice(0,s)}}))}(a,e);const k=r.indexOf(M),S=l.indexOf(w),P=t=>({width:r[t]||0,height:l[t]||0});return{first:P(0),last:P(e-1),widest:P(k),highest:P(S),widths:r,heights:l}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Q(this._alignToPixels?Ae(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=function(t,e,i){return Ci(t,{tick:i,index:e,type:\"tick\"})}(this.getContext(),t,i))}return this.$context||(this.$context=Ci(this.chart.getContext(),{scale:this,type:\"scale\"}))}_tickSize(){const t=this.options.ticks,e=$(this.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),n=this._getLabelSizes(),o=t.autoSkipPadding||0,a=n?n.widest.width+o:0,r=n?n.highest.height+o:0;return this.isHorizontal()?r*i>a*s?a/i:r/s:r*s<a*i?r/i:a/s}_isVisible(){const t=this.options.display;return\"auto\"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:n,position:a,border:r}=s,h=n.offset,c=this.isHorizontal(),d=this.ticks.length+(h?1:0),u=Ks(n),f=[],g=r.setContext(this.getContext()),p=g.display?g.width:0,m=p/2,x=function(t){return Ae(i,t,p)};let b,_,y,v,M,w,k,S,P,D,C,O;if(\"top\"===a)b=x(this.bottom),w=this.bottom-u,S=b-m,D=x(t.top)+m,O=t.bottom;else if(\"bottom\"===a)b=x(this.top),D=t.top,O=x(t.bottom)-m,w=b+m,S=this.top+u;else if(\"left\"===a)b=x(this.right),M=this.right-u,k=b-m,P=x(t.left)+m,C=t.right;else if(\"right\"===a)b=x(this.left),P=t.left,C=x(t.right)-m,M=b+m,k=this.left+u;else if(\"x\"===e){if(\"center\"===a)b=x((t.top+t.bottom)/2+.5);else if(o(a)){const t=Object.keys(a)[0],e=a[t];b=x(this.chart.scales[t].getPixelForValue(e))}D=t.top,O=t.bottom,w=b+m,S=w+u}else if(\"y\"===e){if(\"center\"===a)b=x((t.left+t.right)/2);else if(o(a)){const t=Object.keys(a)[0],e=a[t];b=x(this.chart.scales[t].getPixelForValue(e))}M=b-m,k=M-u,P=t.left,C=t.right}const A=l(s.ticks.maxTicksLimit,d),T=Math.max(1,Math.ceil(d/A));for(_=0;_<d;_+=T){const t=this.getContext(_),e=n.setContext(t),s=r.setContext(t),o=e.lineWidth,a=e.color,l=s.dash||[],d=s.dashOffset,u=e.tickWidth,g=e.tickColor,p=e.tickBorderDash||[],m=e.tickBorderDashOffset;y=qs(this,_,h),void 0!==y&&(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}return this._ticksLength=d,this._borderValue=b,f}_computeLabelItems(t){const e=this.axis,i=this.options,{position:s,ticks:a}=i,r=this.isHorizontal(),l=this.ticks,{align:h,crossAlign:c,padding:d,mirror:u}=a,f=Ks(i.grid),g=f+d,p=u?-d:g,m=-$(this.labelRotation),x=[];let b,_,y,v,M,w,k,S,P,D,C,O,A=\"middle\";if(\"top\"===s)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if(\"bottom\"===s)w=this.top+p,k=this._getXAxisLabelAlignment();else if(\"left\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"right\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"x\"===e){if(\"center\"===s)w=(t.top+t.bottom)/2+g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];w=this.chart.scales[t].getPixelForValue(e)+g}k=this._getXAxisLabelAlignment()}else if(\"y\"===e){if(\"center\"===s)M=(t.left+t.right)/2-g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];M=this.chart.scales[t].getPixelForValue(e)}k=this._getYAxisLabelAlignment(f).textAlign}\"y\"===e&&(\"start\"===h?A=\"top\":\"end\"===h&&(A=\"bottom\"));const T=this._getLabelSizes();for(b=0,_=l.length;b<_;++b){y=l[b],v=y.label;const t=a.setContext(this.getContext(b));S=this.getPixelForTick(b)+a.labelOffset,P=this._resolveTickFontOptions(b),D=P.lineHeight,C=n(v)?v.length:1;const e=C/2,i=t.color,o=t.textStrokeColor,h=t.textStrokeWidth;let d,f=k;if(r?(M=S,\"inner\"===k&&(f=b===_-1?this.options.reverse?\"left\":\"right\":0===b?this.options.reverse?\"right\":\"left\":\"center\"),O=\"top\"===s?\"near\"===c||0!==m?-C*D+D/2:\"center\"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:\"near\"===c||0!==m?D/2:\"center\"===c?T.highest.height/2-e*D:T.highest.height-C*D,u&&(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=ki(t.backdropPadding),i=T.heights[b],s=T.widths[b];let n=O-e.top,o=0-e.left;switch(A){case\"middle\":n-=i/2;break;case\"bottom\":n-=i}switch(k){case\"center\":o-=s/2;break;case\"right\":o-=s;break;case\"inner\":b===_-1?o-=s:b>0&&(o-=s/2)}d={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}x.push({label:v,font:P,textOffset:O,options:{rotation:m,color:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,translation:[M,w],backdrop:d}})}return x}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-$(this.labelRotation))return\"top\"===t?\"left\":\"right\";let i=\"center\";return\"start\"===e.align?i=\"left\":\"end\"===e.align?i=\"right\":\"inner\"===e.align&&(i=\"inner\"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=this.options,o=t+n,a=this._getLabelSizes().widest.width;let r,l;return\"left\"===e?s?(l=this.right+n,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l+=a)):(l=this.right-o,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l=this.left)):\"right\"===e?s?(l=this.left+n,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l-=a)):(l=this.left+o,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l=this.right)):r=\"right\",{textAlign:r,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return\"left\"===e||\"right\"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:\"top\"===e||\"bottom\"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const i=this.ticks.findIndex((e=>e.value===t));if(i>=0){return e.setContext(this.getContext(i)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const a=(t,e,s)=>{s.width&&s.color&&(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())};if(e.display)for(n=0,o=s.length;n<o;++n){const t=s[n];e.drawOnChartArea&&a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=this,n=i.setContext(this.getContext()),o=i.display?n.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,r=this._borderValue;let l,h,c,d;this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,i=this._computeLabelArea();i&&Ie(e,i);const s=this.getLabelItems(t);for(const t of s){const i=t.options,s=t.font;Ne(e,t.label,0,t.textOffset,s,i)}i&&ze(e)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;if(!i.display)return;const a=Si(i.font),r=ki(i.padding),l=i.align;let h=a.lineHeight/2;\"bottom\"===e||\"center\"===e||o(e)?(h+=r.bottom,n(i.text)&&(h+=a.lineHeight*(i.text.length-1))):h+=r.top;const{titleX:c,titleY:d,maxWidth:u,rotation:f}=function(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=t,{chartArea:c,scales:d}=h;let u,f,g,p=0;const m=r-n,x=l-a;if(t.isHorizontal()){if(f=ft(s,a,l),o(i)){const t=Object.keys(i)[0],s=i[t];g=d[t].getPixelForValue(s)+m-e}else g=\"center\"===i?(c.bottom+c.top)/2+m-e:Ys(t,i,e);u=l-a}else{if(o(i)){const t=Object.keys(i)[0],s=i[t];f=d[t].getPixelForValue(s)-x+e}else f=\"center\"===i?(c.left+c.right)/2-x+e:Ys(t,i,e);g=ft(s,r,n),p=\"left\"===i?-E:E}return{titleX:f,titleY:g,maxWidth:u,rotation:p}}(this,h,e,l);Ne(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Zs(l,e,s),textBaseline:\"middle\",translation:[c,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=l(t.grid&&t.grid.z,-1),s=l(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Js.prototype.draw?[{z:i,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+\"AxisID\",s=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[i]!==this.id||t&&o.type!==t||s.push(o)}return s}_resolveTickFontOptions(t){return Si(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Qs{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(function(t){return\"id\"in t&&\"defaults\"in t})(e)&&(i=this.register(e));const s=this.items,n=t.id,o=this.scope+\".\"+n;if(!n)throw new Error(\"class does not have id: \"+t);return n in s||(s[n]=t,function(t,e,i){const s=x(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);ue.set(e,s),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((i=>{const s=i.split(\".\"),n=s.pop(),o=[t].concat(s).join(\".\"),a=e[i].split(\".\"),r=a.pop(),l=a.join(\".\");ue.route(o,n,l,r)}))}(e,t.defaultRoutes);t.descriptors&&ue.describe(e,t.descriptors)}(t,o,i),this.override&&ue.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i in e&&delete e[i],s&&i in ue[s]&&(delete ue[s][i],this.override&&delete re[i])}}class tn{constructor(){this.controllers=new Qs(Ns,\"datasets\",!0),this.elements=new Qs(Hs,\"elements\"),this.plugins=new Qs(Object,\"plugins\"),this.scales=new Qs(Js,\"scales\"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each(\"register\",t)}remove(...t){this._each(\"unregister\",t)}addControllers(...t){this._each(\"register\",t,this.controllers)}addElements(...t){this._each(\"register\",t,this.elements)}addPlugins(...t){this._each(\"register\",t,this.plugins)}addScales(...t){this._each(\"register\",t,this.scales)}getController(t){return this._get(t,this.controllers,\"controller\")}getElement(t){return this._get(t,this.elements,\"element\")}getPlugin(t){return this._get(t,this.plugins,\"plugin\")}getScale(t){return this._get(t,this.scales,\"scale\")}removeControllers(...t){this._each(\"unregister\",t,this.controllers)}removeElements(...t){this._each(\"unregister\",t,this.elements)}removePlugins(...t){this._each(\"unregister\",t,this.plugins)}removeScales(...t){this._each(\"unregister\",t,this.scales)}_each(t,e,i){[...e].forEach((e=>{const s=i||this._getRegistryForType(e);i||s.isForType(e)||s===this.plugins&&e.id?this._exec(t,s,e):u(e,(e=>{const s=i||this._getRegistryForType(e);this._exec(t,s,e)}))}))}_exec(t,e,i){const s=w(t);d(i[\"before\"+s],[],i),e[t](i),d(i[\"after\"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(void 0===s)throw new Error('\"'+t+'\" is not a registered '+i+\".\");return s}}var en=new tn;class sn{constructor(){this._init=[]}notify(t,e,i,s){\"beforeInit\"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,\"install\"));const n=s?this._descriptors(t).filter(s):this._descriptors(t),o=this._notify(n,t,e,i);return\"afterDestroy\"===e&&(this._notify(n,t,\"stop\"),this._notify(this._init,t,\"uninstall\")),o}_notify(t,e,i,s){s=s||{};for(const n of t){const t=n.plugin;if(!1===d(t[i],[e,s,n.options],t)&&s.cancelable)return!1}return!0}invalidate(){s(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,s=l(i.options&&i.options.plugins,{}),n=function(t){const e={},i=[],s=Object.keys(en.plugins.items);for(let t=0;t<s.length;t++)i.push(en.getPlugin(s[t]));const n=t.plugins||[];for(let t=0;t<n.length;t++){const s=n[t];-1===i.indexOf(s)&&(i.push(s),e[s.id]=!0)}return{plugins:i,localIds:e}}(i);return!1!==s||e?function(t,{plugins:e,localIds:i},s,n){const o=[],a=t.getContext();for(const r of e){const e=r.id,l=nn(s[e],n);null!==l&&o.push({plugin:r,options:on(t.config,{plugin:r,local:i[e]},l,a)})}return o}(t,n,s,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,s=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(s(e,i),t,\"stop\"),this._notify(s(i,e),t,\"start\")}}function nn(t,e){return e||!1!==t?!0===t?{}:t:null}function on(t,{plugin:e,local:i},s,n){const o=t.pluginScopeKeys(e),a=t.getOptionScopes(s,o);return i&&e.defaults&&a.push(e.defaults),t.createResolver(a,n,[\"\"],{scriptable:!1,indexable:!1,allKeys:!0})}function an(t,e){const i=ue.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||\"x\"}function rn(t){if(\"x\"===t||\"y\"===t||\"r\"===t)return t}function ln(t,...e){if(rn(t))return t;for(const s of e){const e=s.axis||(\"top\"===(i=s.position)||\"bottom\"===i?\"x\":\"left\"===i||\"right\"===i?\"y\":void 0)||t.length>1&&rn(t[0].toLowerCase());if(e)return e}var i;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function hn(t,e,i){if(i[e+\"AxisID\"]===t)return{axis:e}}function cn(t,e){const i=re[t.type]||{scales:{}},s=e.scales||{},n=an(t.type,e),a=Object.create(null);return Object.keys(s).forEach((e=>{const r=s[e];if(!o(r))return console.error(`Invalid scale configuration for scale: ${e}`);if(r._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const l=ln(e,r,function(t,e){if(e.data&&e.data.datasets){const i=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(i.length)return hn(t,\"x\",i[0])||hn(t,\"y\",i[0])}return{}}(e,t),ue.scales[r.type]),h=function(t,e){return t===e?\"_index_\":\"_value_\"}(l,n),c=i.scales||{};a[e]=b(Object.create(null),[{axis:l},r,c[l],c[h]])})),t.data.datasets.forEach((i=>{const n=i.type||t.type,o=i.indexAxis||an(n,e),r=(re[n]||{}).scales||{};Object.keys(r).forEach((t=>{const e=function(t,e){let i=t;return\"_index_\"===t?i=e:\"_value_\"===t&&(i=\"x\"===e?\"y\":\"x\"),i}(t,o),n=i[e+\"AxisID\"]||e;a[n]=a[n]||Object.create(null),b(a[n],[{axis:e},s[n],r[t]])}))})),Object.keys(a).forEach((t=>{const e=a[t];b(e,[ue.scales[e.type],ue.scale])})),a}function dn(t){const e=t.options||(t.options={});e.plugins=l(e.plugins,{}),e.scales=cn(t,e)}function un(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const fn=new Map,gn=new Set;function pn(t,e){let i=fn.get(t);return i||(i=e(),fn.set(t,i),gn.add(i)),i}const mn=(t,e,i)=>{const s=M(e,i);void 0!==s&&t.add(s)};class xn{constructor(t){this._config=function(t){return(t=t||{}).data=un(t.data),dn(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=un(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),dn(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return pn(t,(()=>[[`datasets.${t}`,\"\"]]))}datasetAnimationScopeKeys(t,e){return pn(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,\"\"]]))}datasetElementScopeKeys(t,e){return pn(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,\"\"]]))}pluginScopeKeys(t){const e=t.id;return pn(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const i=this._scopeCache;let s=i.get(t);return s&&!e||(s=new Map,i.set(t,s)),s}getOptionScopes(t,e,i){const{options:s,type:n}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const r=new Set;e.forEach((e=>{t&&(r.add(t),e.forEach((e=>mn(r,t,e)))),e.forEach((t=>mn(r,s,t))),e.forEach((t=>mn(r,re[n]||{},t))),e.forEach((t=>mn(r,ue,t))),e.forEach((t=>mn(r,le,t)))}));const l=Array.from(r);return 0===l.length&&l.push(Object.create(null)),gn.has(e)&&o.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,re[e]||{},ue.datasets[e]||{},{type:e},ue,le]}resolveNamedOptions(t,e,i,s=[\"\"]){const o={$shared:!0},{resolver:a,subPrefixes:r}=bn(this._resolverCache,t,s);let l=a;if(function(t,e){const{isScriptable:i,isIndexable:s}=Ye(t);for(const o of e){const e=i(o),a=s(o),r=(a||e)&&t[o];if(e&&(S(r)||_n(r))||a&&n(r))return!0}return!1}(a,e)){o.$shared=!1;l=$e(a,i=S(i)?i():i,this.createResolver(t,i,r))}for(const t of e)o[t]=l[t];return o}createResolver(t,e,i=[\"\"],s){const{resolver:n}=bn(this._resolverCache,t,i);return o(e)?$e(n,e,void 0,s):n}}function bn(t,e,i){let s=t.get(e);s||(s=new Map,t.set(e,s));const n=i.join();let o=s.get(n);if(!o){o={resolver:je(e,i),subPrefixes:i.filter((t=>!t.toLowerCase().includes(\"hover\")))},s.set(n,o)}return o}const _n=t=>o(t)&&Object.getOwnPropertyNames(t).some((e=>S(t[e])));const yn=[\"top\",\"bottom\",\"left\",\"right\",\"chartArea\"];function vn(t,e){return\"top\"===t||\"bottom\"===t||-1===yn.indexOf(t)&&\"x\"===e}function Mn(t,e){return function(i,s){return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}}function wn(t){const e=t.chart,i=e.options.animation;e.notifyPlugins(\"afterRender\"),d(i&&i.onComplete,[t],e)}function kn(t){const e=t.chart,i=e.options.animation;d(i&&i.onProgress,[t],e)}function Sn(t){return fe()&&\"string\"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const Pn={},Dn=t=>{const e=Sn(t);return Object.values(Pn).filter((t=>t.canvas===e)).pop()};function Cn(t,e,i){const s=Object.keys(t);for(const n of s){const s=+n;if(s>=e){const o=t[n];delete t[n],(i>0||s>e)&&(t[s+i]=o)}}}function On(t,e,i){return t.options.clip?t[i]:e[i]}class An{static defaults=ue;static instances=Pn;static overrides=re;static registry=en;static version=\"4.4.8\";static getChart=Dn;static register(...t){en.add(...t),Tn()}static unregister(...t){en.remove(...t),Tn()}constructor(t,e){const s=this.config=new xn(e),n=Sn(t),o=Dn(n);if(o)throw new Error(\"Canvas is already in use. Chart with ID '\"+o.id+\"' must be destroyed before the canvas with ID '\"+o.canvas.id+\"' can be reused.\");const a=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||ks(n)),this.platform.updateConfig(s);const r=this.platform.acquireContext(n,a.aspectRatio),l=r&&r.canvas,h=l&&l.height,c=l&&l.width;this.id=i(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new sn,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=dt((t=>this.update(t)),a.resizeDelay||0),this._dataChanges=[],Pn[this.id]=this,r&&l?(bt.listen(this,\"complete\",wn),bt.listen(this,\"progress\",kn),this._initialize(),this.attached&&this.update()):console.error(\"Failed to create chart: can't acquire context from the given item\")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=this;return s(t)?e&&o?o:n?i/n:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return en}_initialize(){return this.notifyPlugins(\"beforeInit\"),this.options.responsive?this.resize():ke(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins(\"afterInit\"),this}clear(){return Te(this.canvas,this.ctx),this}stop(){return bt.stop(this),this}resize(t,e){bt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,s=this.canvas,n=i.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,t,e,n),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),r=this.width?\"resize\":\"attach\";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ke(this,a,!0)&&(this.notifyPlugins(\"resize\",{size:o}),d(i.onResize,[this,o],this),this.attached&&this._doResize(r)&&this.render())}ensureScalesHaveIDs(){u(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,s=Object.keys(i).reduce(((t,e)=>(t[e]=!1,t)),{});let n=[];e&&(n=n.concat(Object.keys(e).map((t=>{const i=e[t],s=ln(t,i),n=\"r\"===s,o=\"x\"===s;return{options:i,dposition:n?\"chartArea\":o?\"bottom\":\"left\",dtype:n?\"radialLinear\":o?\"category\":\"linear\"}})))),u(n,(e=>{const n=e.options,o=n.id,a=ln(o,n),r=l(n.type,e.dtype);void 0!==n.position&&vn(n.position,a)===vn(e.dposition)||(n.position=e.dposition),s[o]=!0;let h=null;if(o in i&&i[o].type===r)h=i[o];else{h=new(en.getScale(r))({id:o,type:r,ctx:this.ctx,chart:this}),i[h.id]=h}h.init(n,t)})),u(s,((t,e)=>{t||delete i[e]})),u(i,(t=>{as.configure(this,t,t.options),as.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort(((t,e)=>t.index-e.index)),i>e){for(let t=e;t<i;++t)this._destroyDatasetMeta(t);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Mn(\"order\",\"index\"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,i)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(i)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,s;for(this._removeUnreferencedMetasets(),i=0,s=e.length;i<s;i++){const s=e[i];let n=this.getDatasetMeta(i);const o=s.type||this.config.type;if(n.type&&n.type!==o&&(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||an(o,this.options),n.order=s.order||0,n.index=i,n.label=\"\"+s.label,n.visible=this.isDatasetVisible(i),n.controller)n.controller.updateIndex(i),n.controller.linkScales();else{const e=en.getController(o),{datasetElementType:s,dataElementType:a}=ue.datasets[o];Object.assign(e,{dataElementType:en.getElement(a),datasetElementType:s&&en.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}}return this._updateMetasets(),t}_resetElements(){u(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins(\"reset\")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins(\"beforeUpdate\",{mode:t,cancelable:!0}))return;const n=this.buildOrUpdateControllers();this.notifyPlugins(\"beforeElementsUpdate\");let o=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t),i=!s&&-1===n.indexOf(e);e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||u(n,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins(\"afterUpdate\",{mode:t}),this._layers.sort(Mn(\"z\",\"_idx\"));const{_active:a,_lastEvent:r}=this;r?this._eventHandler(r,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){u(this.scales,(t=>{as.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);P(e,i)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:s,count:n}of e){Cn(t,s,\"_removeElements\"===i?-n:n)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+\",\"+t.splice(1).join(\",\")))),s=i(0);for(let t=1;t<e;t++)if(!P(s,i(t)))return;return Array.from(s).map((t=>t.split(\",\"))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins(\"beforeLayout\",{cancelable:!0}))return;as.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],u(this.boxes,(t=>{i&&\"chartArea\"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins(\"afterLayout\")}_updateDatasets(t){if(!1!==this.notifyPlugins(\"beforeDatasetsUpdate\",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,S(t)?t({datasetIndex:e}):t);this.notifyPlugins(\"afterDatasetsUpdate\",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),s={meta:i,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetUpdate\",s)&&(i.controller._update(e),s.cancelable=!1,this.notifyPlugins(\"afterDatasetUpdate\",s))}render(){!1!==this.notifyPlugins(\"beforeRender\",{cancelable:!0})&&(bt.has(this)?this.attached&&!bt.running(this)&&bt.start(this):(this.draw(),wn({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(t,e)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins(\"beforeDraw\",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins(\"afterDraw\")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let s,n;for(s=0,n=e.length;s<n;++s){const n=e[s];t&&!n.visible||i.push(n)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins(\"beforeDatasetsDraw\",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins(\"afterDatasetsDraw\")}_drawDataset(t){const e=this.ctx,i=t._clip,s=!i.disabled,n=function(t,e){const{xScale:i,yScale:s}=t;return i&&s?{left:On(i,e,\"left\"),right:On(i,e,\"right\"),top:On(s,e,\"top\"),bottom:On(s,e,\"bottom\")}:e}(t,this.chartArea),o={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetDraw\",o)&&(s&&Ie(e,{left:!1===i.left?0:n.left-i.left,right:!1===i.right?this.width:n.right+i.right,top:!1===i.top?0:n.top-i.top,bottom:!1===i.bottom?this.height:n.bottom+i.bottom}),t.controller.draw(),s&&ze(e),o.cancelable=!1,this.notifyPlugins(\"afterDatasetDraw\",o))}isPointInArea(t){return Re(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,i,s){const n=Xi.modes[e];return\"function\"==typeof n?n(this,t,i,s):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let s=i.filter((t=>t&&t._dataset===e)).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}getContext(){return this.$context||(this.$context=Ci(null,{chart:this,type:\"chart\"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return\"boolean\"==typeof i.hidden?!i.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const s=i?\"show\":\"hide\",n=this.getDatasetMeta(t),o=n.controller._resolveAnimations(void 0,s);k(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((e=>e.datasetIndex===t?s:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),bt.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins(\"beforeDestroy\");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Te(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Pn[this.id],this.notifyPlugins(\"afterDestroy\")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(t,e,i)=>{t.offsetX=e,t.offsetY=i,this._eventHandler(t)};u(this.options.events,(t=>i(t,s)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(i,s)=>{t[i]&&(e.removeEventListener(this,i,s),delete t[i])},n=(t,e)=>{this.canvas&&this.resize(t,e)};let o;const a=()=>{s(\"attach\",a),this.attached=!0,this.resize(),i(\"resize\",n),i(\"detach\",o)};o=()=>{this.attached=!1,s(\"resize\",n),this._stop(),this._resize(0,0),i(\"attach\",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){u(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},u(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const s=i?\"set\":\"remove\";let n,o,a,r;for(\"dataset\"===e&&(n=this.getDatasetMeta(t[0].datasetIndex),n.controller[\"_\"+s+\"DatasetHoverStyle\"]()),a=0,r=t.length;a<r;++a){o=t[a];const e=o&&this.getDatasetMeta(o.datasetIndex).controller;e&&e[s+\"HoverStyle\"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map((({datasetIndex:t,index:e})=>{const i=this.getDatasetMeta(t);if(!i)throw new Error(\"No dataset found at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}}));!f(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,i){const s=this.options.hover,n=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),o=n(e,t),a=i?t:n(t,e);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},s=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins(\"beforeEvent\",i,s))return;const n=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins(\"afterEvent\",i,s),(n||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:s=[],options:n}=this,o=e,a=this._getActiveElements(t,s,i,o),r=D(t),l=function(t,e,i,s){return i&&\"mouseout\"!==t.type?s?e:t:null}(t,this._lastEvent,i,r);i&&(this._lastEvent=null,d(n.onHover,[t,a,this],this),r&&d(n.onClick,[t,a,this],this));const h=!f(a,s);return(h||e)&&(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}_getActiveElements(t,e,i,s){if(\"mouseout\"===t.type)return[];if(!i)return e;const n=this.options.hover;return this.getElementsAtEventForMode(t,n.mode,n,s)}}function Tn(){return u(An.instances,(t=>t._plugins.invalidate()))}function Ln(){throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\")}class En{static override(t){Object.assign(En.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Ln()}parse(){return Ln()}format(){return Ln()}add(){return Ln()}diff(){return Ln()}startOf(){return Ln()}endOf(){return Ln()}}var Rn={_date:En};function In(t){const e=t.iScale,i=function(t,e){if(!t._cache.$bar){const i=t.getMatchingVisibleMetas(e);let s=[];for(let e=0,n=i.length;e<n;e++)s=s.concat(i[e].controller.getAllParsedValues(t));t._cache.$bar=lt(s.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let s,n,o,a,r=e._length;const l=()=>{32767!==o&&-32768!==o&&(k(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,n=i.length;s<n;++s)o=e.getPixelForValue(i[s]),l();for(a=void 0,s=0,n=e.ticks.length;s<n;++s)o=e.getPixelForTick(s),l();return r}function zn(t,e,i,s){return n(t)?function(t,e,i,s){const n=i.parse(t[0],s),o=i.parse(t[1],s),a=Math.min(n,o),r=Math.max(n,o);let l=a,h=r;Math.abs(a)>Math.abs(r)&&(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}(t,e,i,s):e[i.axis]=i.parse(t,s),e}function Fn(t,e,i,s){const n=t.iScale,o=t.vScale,a=n.getLabels(),r=n===o,l=[];let h,c,d,u;for(h=i,c=i+s;h<c;++h)u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(zn(u,d,o,h));return l}function Vn(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function Bn(t,e,i,s){let n=e.borderSkipped;const o={};if(!n)return void(t.borderSkipped=o);if(!0===n)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:a,end:r,reverse:l,top:h,bottom:c}=function(t){let e,i,s,n,o;return t.horizontal?(e=t.base>t.x,i=\"left\",s=\"right\"):(e=t.base<t.y,i=\"bottom\",s=\"top\"),e?(n=\"end\",o=\"start\"):(n=\"start\",o=\"end\"),{start:i,end:s,reverse:e,top:n,bottom:o}}(t);\"middle\"===n&&i&&(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[Wn(c,a,r,l)]=!0,n=h)),o[Wn(n,a,r,l)]=!0,t.borderSkipped=o}function Wn(t,e,i,s){var n,o,a;return s?(a=i,t=Nn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Nn(t,e,i),t}function Nn(t,e,i){return\"start\"===t?e:\"end\"===t?i:t}function Hn(t,{inflateAmount:e},i){t.inflateAmount=\"auto\"===e?1===i?.33:0:e}class jn extends Ns{static id=\"doughnut\";static defaults={datasetElementType:!1,dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:\"number\",properties:[\"circumference\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"startAngle\",\"x\",\"y\",\"offset\",\"borderWidth\",\"spacing\"]}},cutout:\"50%\",rotation:0,circumference:360,radius:\"100%\",spacing:0,indexAxis:\"r\"};static descriptors={_scriptable:t=>\"spacing\"!==t,_indexable:t=>\"spacing\"!==t&&!t.startsWith(\"borderDash\")&&!t.startsWith(\"hoverBorderDash\")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const i=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=i;else{let n,a,r=t=>+i[t];if(o(i[t])){const{key:t=\"value\"}=this._parsing;r=e=>+M(i[e],t)}for(n=t,a=t+e;n<a;++n)s._parsed[n]=r(n)}}_getRotation(){return $(this.options.rotation-90)}_getCircumference(){return $(this.options.circumference)}_getRotationExtents(){let t=O,e=-O;for(let i=0;i<this.chart.data.datasets.length;++i)if(this.chart.isDatasetVisible(i)&&this.chart.getDatasetMeta(i).type===this._type){const s=this.chart.getDatasetMeta(i).controller,n=s._getRotation(),o=s._getCircumference();t=Math.min(t,n),e=Math.max(e,n+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:i}=e,s=this._cachedMeta,n=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,a=Math.max((Math.min(i.width,i.height)-o)/2,0),r=Math.min(h(this.options.cutout,a),1),l=this._getRingWeight(this.index),{circumference:d,rotation:u}=this._getRotationExtents(),{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=function(t,e,i){let s=1,n=1,o=0,a=0;if(e<O){const r=t,l=r+e,h=Math.cos(r),c=Math.sin(r),d=Math.cos(l),u=Math.sin(l),f=(t,e,s)=>Z(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),g=(t,e,s)=>Z(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),p=f(0,h,d),m=f(E,c,u),x=g(C,h,d),b=g(C+E,c,u);s=(p-x)/2,n=(m-b)/2,o=-(p+x)/2,a=-(m+b)/2}return{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}(u,d,r),x=(i.width-o)/f,b=(i.height-o)/g,_=Math.max(Math.min(x,b)/2,0),y=c(this.options.radius,_),v=(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(n,0,n.length,t)}_circumference(t,e){const i=this.options,s=this._cachedMeta,n=this._getCircumference();return e&&i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.chartArea,r=o.options.animation,l=(a.left+a.right)/2,h=(a.top+a.bottom)/2,c=n&&r.animateScale,d=c?0:this.innerRadius,u=c?0:this.outerRadius,{sharedOptions:f,includeOptions:g}=this._getSharedOptions(e,s);let p,m=this._getRotation();for(p=0;p<e;++p)m+=this._circumference(p,n);for(p=e;p<e+i;++p){const e=this._circumference(p,n),i=t[p],o={x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};g&&(o.options=f||this.resolveDataElementOptions(p,i.active?\"active\":s)),m+=e,this.updateElement(i,p,o,s)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let i,s=0;for(i=0;i<e.length;i++){const n=t._parsed[i];null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?O*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t],i.options.locale);return{label:s[t]||\"\",value:n}}getMaxBorderWidth(t){let e=0;const i=this.chart;let s,n,o,a,r;if(!t)for(s=0,n=i.data.datasets.length;s<n;++s)if(i.isDatasetVisible(s)){o=i.getDatasetMeta(s),t=o.data,a=o.controller;break}if(!t)return 0;for(s=0,n=t.length;s<n;++s)r=a.resolveDataElementOptions(s),\"inner\"!==r.borderAlign&&(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let i=0,s=t.length;i<s;++i){const t=this.resolveDataElementOptions(i);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e}_getRingWeight(t){return Math.max(l(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class $n extends Ns{static id=\"polarArea\";static defaults={dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"]}},indexAxis:\"r\",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}},scales:{r:{type:\"radialLinear\",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t].r,i.options.locale);return{label:s[t]||\"\",value:n}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,i)=>{const s=this.getParsed(i).r;!isNaN(s)&&this.chart.getDataVisibility(i)&&(s<e.min&&(e.min=s),s>e.max&&(e.max=s))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,i=t.options,s=Math.min(e.right-e.left,e.bottom-e.top),n=Math.max(s/2,0),o=(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.options.animation,r=this._cachedMeta.rScale,l=r.xCenter,h=r.yCenter,c=r.getIndexAngle(0)-.5*C;let d,u=c;const f=360/this.countVisibleElements();for(d=0;d<e;++d)u+=this._computeAngle(d,s,f);for(d=e;d<e+i;d++){const e=t[d];let i=u,g=u+this._computeAngle(d,s,f),p=o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;u=g,n&&(a.animateScale&&(p=0),a.animateRotate&&(i=g=c));const m={x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?\"active\":s)};this.updateElement(e,d,m,s)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&e++})),e}_computeAngle(t,e,i){return this.chart.getDataVisibility(t)?$(this.resolveDataElementOptions(t,e).angle||i):0}}var Yn=Object.freeze({__proto__:null,BarController:class extends Ns{static id=\"bar\";static defaults={datasetElementType:!1,dataElementType:\"bar\",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"base\",\"width\",\"height\"]}}};static overrides={scales:{_index_:{type:\"category\",offset:!0,grid:{offset:!0}},_value_:{type:\"linear\",beginAtZero:!0}}};parsePrimitiveData(t,e,i,s){return Fn(t,e,i,s)}parseArrayData(t,e,i,s){return Fn(t,e,i,s)}parseObjectData(t,e,i,s){const{iScale:n,vScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=\"x\"===n.axis?a:r,h=\"x\"===o.axis?a:r,c=[];let d,u,f,g;for(d=i,u=i+s;d<u;++d)g=e[d],f={},f[n.axis]=n.parse(M(g,l),d),c.push(zn(M(g,h),f,o,d));return c}updateRangeFromParsed(t,e,i,s){super.updateRangeFromParsed(t,e,i,s);const n=i._custom;n&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:i,vScale:s}=e,n=this.getParsed(t),o=n._custom,a=Vn(o)?\"[\"+o.start+\", \"+o.end+\"]\":\"\"+s.getLabelForValue(n[s.axis]);return{label:\"\"+i.getLabelForValue(n[i.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{index:a,_cachedMeta:{vScale:r}}=this,l=r.getBasePixel(),h=r.isHorizontal(),c=this._getRuler(),{sharedOptions:d,includeOptions:u}=this._getSharedOptions(e,n);for(let f=e;f<e+i;f++){const e=this.getParsed(f),i=o||s(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),g=this._calculateBarIndexPixels(f,c),p=(e._stacks||{})[r.axis],m={horizontal:h,base:i.base,enableBorderRadius:!p||Vn(e._custom)||a===p._top||a===p._bottom,x:h?i.head:g.center,y:h?g.center:i.head,height:h?g.size:Math.abs(i.size),width:h?Math.abs(i.size):g.size};u&&(m.options=d||this.resolveDataElementOptions(f,t[f].active?\"active\":n));const x=m.options||t[f].options;Bn(m,x,p,a),Hn(m,x,c.ratio),this.updateElement(t[f],f,m,n)}}_getStacks(t,e){const{iScale:i}=this._cachedMeta,n=i.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),o=i.options.stacked,a=[],r=this._cachedMeta.controller.getParsed(e),l=r&&r[i.axis],h=t=>{const e=t._parsed.find((t=>t[i.axis]===l)),n=e&&e[t.vScale.axis];if(s(n)||isNaN(n))return!0};for(const i of n)if((void 0===e||!h(i))&&((!1===o||-1===a.indexOf(i.stack)||void 0===o&&void 0===i.stack)&&a.push(i.stack),i.index===t))break;return a.length||a.push(void 0),a}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,i){const s=this._getStacks(t,i),n=void 0!==e?s.indexOf(e):-1;return-1===n?s.length-1:n}_getRuler(){const t=this.options,e=this._cachedMeta,i=e.iScale,s=[];let n,o;for(n=0,o=e.data.length;n<o;++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));const a=t.barThickness;return{min:a||In(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=this,r=o||0,l=this.getParsed(t),h=l._custom,c=Vn(h);let d,u,f=l[e.axis],g=0,p=i?this.applyStack(e,l,i):f;p!==f&&(g=p-f,p=f),c&&(f=h.barStart,p=h.barEnd-h.barStart,0!==f&&F(f)!==F(h.barEnd)&&(g=0),g+=f);const m=s(o)||c?g:o;let x=e.getPixelForValue(m);if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(g+p):x,u=d-x,Math.abs(u)<a){u=function(t,e,i){return 0!==t?F(t):(e.isHorizontal()?1:-1)*(e.min>=i?1:-1)}(u,e,r)*a,f===r&&(x-=u/2);const t=e.getPixelForDecimal(0),s=e.getPixelForDecimal(1),o=Math.min(t,s),h=Math.max(t,s);x=Math.max(Math.min(x,h),o),d=x+u,i&&!c&&(l._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(x))}if(x===e.getPixelForValue(r)){const t=F(u)*e.getLineWidthForValue(r)/2;x+=t,u-=t}return{size:u,base:x,head:d,center:d+u/2}}_calculateBarIndexPixels(t,e){const i=e.scale,n=this.options,o=n.skipNull,a=l(n.maxBarThickness,1/0);let r,h;if(e.grouped){const i=o?this._getStackCount(t):e.stackCount,l=\"flex\"===n.barThickness?function(t,e,i,s){const n=e.pixels,o=n[t];let a=t>0?n[t-1]:null,r=t<n.length-1?n[t+1]:null;const l=i.categoryPercentage;null===a&&(a=o-(null===r?e.end-e.start:r-o)),null===r&&(r=o+o-a);const h=o-(o-Math.min(a,r))/2*l;return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}(t,e,n,i):function(t,e,i,n){const o=i.barThickness;let a,r;return s(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}(t,e,n,i),c=this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);r=l.start+l.chunk*c+l.chunk/2,h=Math.min(a,l.chunk*l.ratio)}else r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);return{base:r-h/2,head:r+h/2,center:r,size:h}}draw(){const t=this._cachedMeta,e=t.vScale,i=t.data,s=i.length;let n=0;for(;n<s;++n)null===this.getParsed(n)[e.axis]||i[n].hidden||i[n].draw(this._ctx)}},BubbleController:class extends Ns{static id=\"bubble\";static defaults={datasetElementType:!1,dataElementType:\"point\",animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"borderWidth\",\"radius\"]}}};static overrides={scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,i,s){const n=super.parsePrimitiveData(t,e,i,s);for(let t=0;t<n.length;t++)n[t]._custom=this.resolveDataElementOptions(t+i).radius;return n}parseArrayData(t,e,i,s){const n=super.parseArrayData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s[2],this.resolveDataElementOptions(t+i).radius)}return n}parseObjectData(t,e,i,s){const n=super.parseObjectData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s&&s.r&&+s.r,this.resolveDataElementOptions(t+i).radius)}return n}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let i=t.length-1;i>=0;--i)e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y),l=o._custom;return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+(l?\", \"+l:\"\")+\")\"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,i,s){const n=\"reset\"===s,{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:r,includeOptions:l}=this._getSharedOptions(e,s),h=o.axis,c=a.axis;for(let d=e;d<e+i;d++){const e=t[d],i=!n&&this.getParsed(d),u={},f=u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),g=u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);u.skip=isNaN(f)||isNaN(g),l&&(u.options=r||this.resolveDataElementOptions(d,e.active?\"active\":s),n&&(u.options.radius=0)),this.updateElement(e,d,u,s)}}resolveDataElementOptions(t,e){const i=this.getParsed(t);let s=super.resolveDataElementOptions(t,e);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const n=s.radius;return\"active\"!==e&&(s.radius=0),s.radius+=l(i&&i._custom,n),s}},DoughnutController:jn,LineController:class extends Ns{static id=\"line\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:\"category\"},_value_:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:i,data:s=[],_dataset:n}=e,o=this.chart._animationsDisabled;let{start:a,count:r}=pt(e,s,o);this._drawStart=a,this._drawCount=r,mt(e)&&(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,{sharedOptions:c,includeOptions:d}=this._getSharedOptions(e,n),u=a.axis,f=r.axis,{spanGaps:g,segment:p}=this.options,m=N(g)?g:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||o||\"none\"===n,b=e+i,_=t.length;let y=e>0&&this.getParsed(e-1);for(let i=0;i<_;++i){const g=t[i],_=x?g:{};if(i<e||i>=b){_.skip=!0;continue}const v=this.getParsed(i),M=s(v[f]),w=_[u]=a.getPixelForValue(v[u],i),k=_[f]=o||M?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,v,l):v[f],i);_.skip=isNaN(w)||isNaN(k)||M,_.stop=i>0&&Math.abs(v[u]-y[u])>m,p&&(_.parsed=v,_.raw=h.data[i]),d&&(_.options=c||this.resolveDataElementOptions(i,g.active?\"active\":n)),x||this.updateElement(g,i,_,n),y=v}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,i=e.options&&e.options.borderWidth||0,s=t.data||[];if(!s.length)return i;const n=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(i,n,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}},PieController:class extends jn{static id=\"pie\";static defaults={cutout:0,rotation:0,circumference:360,radius:\"100%\"}},PolarAreaController:$n,RadarController:class extends Ns{static id=\"radar\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",indexAxis:\"r\",showLine:!0,elements:{line:{fill:\"start\"}}};static overrides={aspectRatio:1,scales:{r:{type:\"radialLinear\"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,i=this.getParsed(t);return{label:e.getLabels()[t],value:\"\"+e.getLabelForValue(i[e.axis])}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta,i=e.dataset,s=e.data||[],n=e.iScale.getLabels();if(i.points=s,\"resize\"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const o={_loop:!0,_fullLoop:n.length===s.length,options:e};this.updateElement(i,void 0,o,t)}this.updateElements(s,0,s.length,t)}updateElements(t,e,i,s){const n=this._cachedMeta.rScale,o=\"reset\"===s;for(let a=e;a<e+i;a++){const e=t[a],i=this.resolveDataElementOptions(a,e.active?\"active\":s),r=n.getPointPositionForValue(a,this.getParsed(a).r),l=o?n.xCenter:r.x,h=o?n.yCenter:r.y,c={x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};this.updateElement(e,a,c,s)}}},ScatterController:class extends Ns{static id=\"scatter\";static defaults={datasetElementType:!1,dataElementType:\"point\",showLine:!1,fill:!1};static overrides={interaction:{mode:\"point\"},scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y);return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+\")\"}}update(t){const e=this._cachedMeta,{data:i=[]}=e,s=this.chart._animationsDisabled;let{start:n,count:o}=pt(e,i,s);if(this._drawStart=n,this._drawCount=o,mt(e)&&(n=0,o=i.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:n,_dataset:o}=e;n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;const a=this.resolveDatasetElementOptions(t);a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(i,n,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement(\"line\")),super.addElements()}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,c=this.resolveDataElementOptions(e,n),d=this.getSharedOptions(c),u=this.includeOptions(n,d),f=a.axis,g=r.axis,{spanGaps:p,segment:m}=this.options,x=N(p)?p:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||o||\"none\"===n;let _=e>0&&this.getParsed(e-1);for(let c=e;c<e+i;++c){const e=t[c],i=this.getParsed(c),p=b?e:{},y=s(i[g]),v=p[f]=a.getPixelForValue(i[f],c),M=p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,i,l):i[g],c);p.skip=isNaN(v)||isNaN(M)||y,p.stop=c>0&&Math.abs(i[f]-_[f])>x,m&&(p.parsed=i,p.raw=h.data[c]),u&&(p.options=d||this.resolveDataElementOptions(c,e.active?\"active\":n)),b||this.updateElement(e,c,p,n),_=i}this.updateSharedOptions(d,n,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let i=e.length-1;i>=0;--i)t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);return t>0&&t}const i=t.dataset,s=i.options&&i.options.borderWidth||0;if(!e.length)return s;const n=e[0].size(this.resolveDataElementOptions(0)),o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(s,n,o)/2}}});function Un(t,e,i,s){const n=vi(t.options.borderRadius,[\"outerStart\",\"outerEnd\",\"innerStart\",\"innerEnd\"]);const o=(i-e)/2,a=Math.min(o,s*e/2),r=t=>{const e=(i-Math.min(o,t))*s/2;return J(t,0,Math.min(o,e))};return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:J(n.innerStart,0,a),innerEnd:J(n.innerEnd,0,a)}}function Xn(t,e,i,s){return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}function qn(t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=e,d=Math.max(e.outerRadius+s+i-h,0),u=c>0?c+s+i+h:0;let f=0;const g=n-l;if(s){const t=((c>0?c-s:0)+(d>0?d-s:0))/2;f=(g-(0!==t?g*t/(t+s):g))/2}const p=(g-Math.max(.001,g*d-i/C)/d)/2,m=l+p+f,x=n-p-f,{outerStart:b,outerEnd:_,innerStart:y,innerEnd:v}=Un(e,u,d,x-m),M=d-b,w=d-_,k=m+b/M,S=x-_/w,P=u+y,D=u+v,O=m+y/P,A=x-v/D;if(t.beginPath(),o){const e=(k+S)/2;if(t.arc(a,r,d,k,e),t.arc(a,r,d,e,S),_>0){const e=Xn(w,S,a,r);t.arc(e.x,e.y,_,S,x+E)}const i=Xn(D,x,a,r);if(t.lineTo(i.x,i.y),v>0){const e=Xn(D,A,a,r);t.arc(e.x,e.y,v,x+E,A+Math.PI)}const s=(x-v/u+(m+y/u))/2;if(t.arc(a,r,u,x-v/u,s,!0),t.arc(a,r,u,s,m+y/u,!0),y>0){const e=Xn(P,O,a,r);t.arc(e.x,e.y,y,O+Math.PI,m-E)}const n=Xn(M,m,a,r);if(t.lineTo(n.x,n.y),b>0){const e=Xn(M,k,a,r);t.arc(e.x,e.y,b,m-E,k)}}else{t.moveTo(a,r);const e=Math.cos(k)*d+a,i=Math.sin(k)*d+r;t.lineTo(e,i);const s=Math.cos(S)*d+a,n=Math.sin(S)*d+r;t.lineTo(s,n)}t.closePath()}function Kn(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r,options:l}=e,{borderWidth:h,borderJoinStyle:c,borderDash:d,borderDashOffset:u}=l,f=\"inner\"===l.borderAlign;if(!h)return;t.setLineDash(d||[]),t.lineDashOffset=u,f?(t.lineWidth=2*h,t.lineJoin=c||\"round\"):(t.lineWidth=h,t.lineJoin=c||\"bevel\");let g=e.endAngle;if(o){qn(t,e,i,s,g,n);for(let e=0;e<o;++e)t.stroke();isNaN(r)||(g=a+(r%O||O))}f&&function(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=e;let h=n/r;t.beginPath(),t.arc(o,a,r,s-h,i+h),l>n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+E,s-E),t.closePath(),t.clip()}(t,e,g),o||(qn(t,e,i,s,g,n),t.stroke())}function Gn(t,e,i=e){t.lineCap=l(i.borderCapStyle,e.borderCapStyle),t.setLineDash(l(i.borderDash,e.borderDash)),t.lineDashOffset=l(i.borderDashOffset,e.borderDashOffset),t.lineJoin=l(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=l(i.borderWidth,e.borderWidth),t.strokeStyle=l(i.borderColor,e.borderColor)}function Zn(t,e,i){t.lineTo(i.x,i.y)}function Jn(t,e,i={}){const s=t.length,{start:n=0,end:o=s-1}=i,{start:a,end:r}=e,l=Math.max(n,a),h=Math.min(o,r),c=n<a&&o<a||n>r&&o>r;return{count:s,start:l,loop:e.loop,ilen:h<l&&!c?s+h-l:h-l}}function Qn(t,e,i,s){const{points:n,options:o}=e,{count:a,start:r,loop:l,ilen:h}=Jn(n,i,s),c=function(t){return t.stepped?Fe:t.tension||\"monotone\"===t.cubicInterpolationMode?Ve:Zn}(o);let d,u,f,{move:g=!0,reverse:p}=s||{};for(d=0;d<=h;++d)u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);return l&&(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}function to(t,e,i,s){const n=e.points,{count:o,start:a,ilen:r}=Jn(n,i,s),{move:l=!0,reverse:h}=s||{};let c,d,u,f,g,p,m=0,x=0;const b=t=>(a+(h?r-t:t))%o,_=()=>{f!==g&&(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))};for(l&&(d=n[b(0)],t.moveTo(d.x,d.y)),c=0;c<=r;++c){if(d=n[b(c)],d.skip)continue;const e=d.x,i=d.y,s=0|e;s===u?(i<f?f=i:i>g&&(g=i),m=(x*m+e)/++x):(_(),t.lineTo(e,i),u=s,x=0,f=g=i),p=i}_()}function eo(t){const e=t.options,i=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||\"monotone\"===e.cubicInterpolationMode||e.stepped||i)?to:Qn}const io=\"function\"==typeof Path2D;function so(t,e,i,s){io&&!e.options.segment?function(t,e,i,s){let n=e._path;n||(n=e._path=new Path2D,e.path(n,i,s)&&n.closePath()),Gn(t,e.options),t.stroke(n)}(t,e,i,s):function(t,e,i,s){const{segments:n,options:o}=e,a=eo(e);for(const r of n)Gn(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&&t.closePath(),t.stroke()}(t,e,i,s)}class no extends Hs{static id=\"line\";static defaults={borderCapStyle:\"butt\",borderDash:[],borderDashOffset:0,borderJoinStyle:\"miter\",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:\"default\",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t&&\"fill\"!==t};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const i=this.options;if((i.tension||\"monotone\"===i.cubicInterpolationMode)&&!i.stepped&&!this._pointsUpdated){const s=i.spanGaps?this._loop:this._fullLoop;hi(this._points,i,t,s,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=zi(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,i=t.length;return i&&e[t[i-1].end]}interpolate(t,e){const i=this.options,s=t[e],n=this.points,o=Ii(this,{property:e,start:s,end:s});if(!o.length)return;const a=[],r=function(t){return t.stepped?pi:t.tension||\"monotone\"===t.cubicInterpolationMode?mi:gi}(i);let l,h;for(l=0,h=o.length;l<h;++l){const{start:h,end:c}=o[l],d=n[h],u=n[c];if(d===u){a.push(d);continue}const f=r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);f[e]=t[e],a.push(f)}return 1===a.length?a[0]:a}pathSegment(t,e,i){return eo(this)(t,this,e,i)}path(t,e,i){const s=this.segments,n=eo(this);let o=this._loop;e=e||0,i=i||this.points.length-e;for(const a of s)o&=n(t,this,a,{start:e,end:e+i-1});return!!o}draw(t,e,i,s){const n=this.options||{};(this.points||[]).length&&n.borderWidth&&(t.save(),so(t,this,i,s),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function oo(t,e,i,s){const n=t.options,{[i]:o}=t.getProps([i],s);return Math.abs(e-o)<n.radius+n.hitRadius}function ao(t,e){const{x:i,y:s,base:n,width:o,height:a}=t.getProps([\"x\",\"y\",\"base\",\"width\",\"height\"],e);let r,l,h,c,d;return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}function ro(t,e,i,s){return t?0:J(e,i,s)}function lo(t){const e=ao(t),i=e.right-e.left,s=e.bottom-e.top,n=function(t,e,i){const s=t.options.borderWidth,n=t.borderSkipped,o=Mi(s);return{t:ro(n.top,o.top,0,i),r:ro(n.right,o.right,0,e),b:ro(n.bottom,o.bottom,0,i),l:ro(n.left,o.left,0,e)}}(t,i/2,s/2),a=function(t,e,i){const{enableBorderRadius:s}=t.getProps([\"enableBorderRadius\"]),n=t.options.borderRadius,a=wi(n),r=Math.min(e,i),l=t.borderSkipped,h=s||o(n);return{topLeft:ro(!h||l.top||l.left,a.topLeft,0,r),topRight:ro(!h||l.top||l.right,a.topRight,0,r),bottomLeft:ro(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:ro(!h||l.bottom||l.right,a.bottomRight,0,r)}}(t,i/2,s/2);return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,a.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(n.b,n.r))}}}}function ho(t,e,i,s){const n=null===e,o=null===i,a=t&&!(n&&o)&&ao(t,s);return a&&(n||tt(e,a.left,a.right))&&(o||tt(i,a.top,a.bottom))}function co(t,e){t.rect(e.x,e.y,e.w,e.h)}function uo(t,e,i={}){const s=t.x!==i.x?-e:0,n=t.y!==i.y?-e:0,o=(t.x+t.w!==i.x+i.w?e:0)-s,a=(t.y+t.h!==i.y+i.h?e:0)-n;return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}var fo=Object.freeze({__proto__:null,ArcElement:class extends Hs{static id=\"arc\";static defaults={borderAlign:\"center\",borderColor:\"#fff\",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:\"backgroundColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.getProps([\"x\",\"y\"],i),{angle:n,distance:o}=X(s,{x:t,y:e}),{startAngle:a,endAngle:r,innerRadius:h,outerRadius:c,circumference:d}=this.getProps([\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],i),u=(this.options.spacing+this.options.borderWidth)/2,f=l(d,r-a),g=Z(n,a,r)&&a!==r,p=f>=O||g,m=tt(o,h+u,c+u);return p&&m}getCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=this.getProps([\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"],t),{offset:r,spacing:l}=this.options,h=(s+n)/2,c=(o+a+l+r)/2;return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,s=(e.offset||0)/4,n=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin=\"inner\"===e.borderAlign?.33:0,this.fullCircles=i>O?Math.floor(i/O):0,0===i||this.innerRadius<0||this.outerRadius<0)return;t.save();const a=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(a)*s,Math.sin(a)*s);const r=s*(1-Math.sin(Math.min(C,i||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=e;let l=e.endAngle;if(o){qn(t,e,i,s,l,n);for(let e=0;e<o;++e)t.fill();isNaN(r)||(l=a+(r%O||O))}qn(t,e,i,s,l,n),t.fill()}(t,this,r,n,o),Kn(t,this,r,n,o),t.restore()}},BarElement:class extends Hs{static id=\"bar\";static defaults={borderSkipped:\"start\",borderWidth:0,borderRadius:0,inflateAmount:\"auto\",pointStyle:void 0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=this,{inner:n,outer:o}=lo(this),a=(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?He:co;var r;t.save(),o.w===n.w&&o.h===n.h||(t.beginPath(),a(t,uo(o,e,n)),t.clip(),a(t,uo(n,-e,o)),t.fillStyle=i,t.fill(\"evenodd\")),t.beginPath(),a(t,uo(n,e)),t.fillStyle=s,t.fill(),t.restore()}inRange(t,e,i){return ho(this,t,e,i)}inXRange(t,e){return ho(this,t,null,e)}inYRange(t,e){return ho(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=this.getProps([\"x\",\"y\",\"base\",\"horizontal\"],t);return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}getRange(t){return\"x\"===t?this.width/2:this.height/2}},LineElement:no,PointElement:class extends Hs{static id=\"point\";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:\"circle\",radius:3,rotation:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.options,{x:n,y:o}=this.getProps([\"x\",\"y\"],i);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(t,e){return oo(this,t,\"x\",e)}inYRange(t,e){return oo(this,t,\"y\",e)}getCenterPoint(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const i=this.options;this.skip||i.radius<.1||!Re(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Le(t,i,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}});function go(t,e,i,s){const n=t.indexOf(e);if(-1===n)return((t,e,i,s)=>(\"string\"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&&(i=null),i))(t,e,i,s);return n!==t.lastIndexOf(e)?i:n}function po(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}function mo(t,e,{horizontal:i,minRotation:s}){const n=$(s),o=(i?Math.sin(n):Math.cos(n))||.001,a=.75*e*(\"\"+t).length;return Math.min(e/o,a)}class xo extends Js{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return s(t)||(\"number\"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:s,max:n}=this;const o=t=>s=e?s:t,a=t=>n=i?n:t;if(t){const t=F(s),e=F(n);t<0&&e<0?a(0):t>0&&e>0&&o(0)}if(s===n){let e=0===n?1:Math.abs(.05*n);a(n+e),t||o(s-e)}this.min=s,this.max=n}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:i,stepSize:s}=t;return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&&(e=Math.min(i,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const n=function(t,e){const i=[],{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=t,f=o||1,g=c-1,{min:p,max:m}=e,x=!s(a),b=!s(r),_=!s(h),y=(m-p)/(d+1);let v,M,w,k,S=B((m-p)/g/f)*f;if(S<1e-14&&!x&&!b)return[{value:p},{value:m}];k=Math.ceil(m/S)-Math.floor(p/S),k>g&&(S=B(k*S/g/f)*f),s(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),\"ticks\"===n?(M=Math.floor(p/S)*S,w=Math.ceil(m/S)*S):(M=p,w=m),x&&b&&o&&H((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=x?a:M,w=b?r:w,k=h-1,S=(w-M)/k):(k=(w-M)/S,k=V(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));const P=Math.max(U(S),U(M));v=Math.pow(10,s(l)?P:l),M=Math.round(M*v)/v,w=Math.round(w*v)/v;let D=0;for(x&&(u&&M!==a?(i.push({value:a}),M<a&&D++,V(Math.round((M+D*S)*v)/v,a,mo(a,y,t))&&D++):M<a&&D++);D<k;++D){const t=Math.round((M+D*S)*v)/v;if(b&&t>r)break;i.push({value:t})}return b&&u&&w!==r?i.length&&V(i[i.length-1].value,r,mo(r,y,t))?i[i.length-1].value=r:i.push({value:r}):b&&w!==r||i.push({value:w}),i}({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return\"ticks\"===t.bounds&&j(n,this,\"value\"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const s=(i-e)/Math.max(t.length-1,1)/2;e-=s,i+=s}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return ne(t,this.chart.options.locale,this.options.ticks.format)}}class bo extends xo{static id=\"linear\";static defaults={ticks:{callback:ae.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?t:0,this.max=a(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=$(this.options.ticks.minRotation),s=(t?Math.sin(i):Math.cos(i))||.001,n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/s))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const _o=t=>Math.floor(z(t)),yo=(t,e)=>Math.pow(10,_o(t)+e);function vo(t){return 1===t/Math.pow(10,_o(t))}function Mo(t,e,i){const s=Math.pow(10,i),n=Math.floor(t/s);return Math.ceil(e/s)-n}function wo(t,{min:e,max:i}){e=r(t.min,e);const s=[],n=_o(e);let o=function(t,e){let i=_o(e-t);for(;Mo(t,e,i)>10;)i++;for(;Mo(t,e,i)<10;)i--;return Math.min(i,_o(t))}(e,i),a=o<0?Math.pow(10,Math.abs(o)):1;const l=Math.pow(10,o),h=n>o?Math.pow(10,n):0,c=Math.round((e-h)*a)/a,d=Math.floor((e-h)/l/10)*l*10;let u=Math.floor((c-d)/Math.pow(10,o)),f=r(t.min,Math.round((h+d+u*Math.pow(10,o))*a)/a);for(;f<i;)s.push({value:f,major:vo(f),significand:u}),u>=10?u=u<15?15:20:u++,u>=20&&(o++,u=2,a=o>=0?1:a),f=Math.round((h+d+u*Math.pow(10,o))*a)/a;const g=r(t.max,f);return s.push({value:g,major:vo(g),significand:u}),s}class ko extends Js{static id=\"logarithmic\";static defaults={ticks:{callback:ae.formatters.logarithmic,major:{enabled:!0}}};constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=xo.prototype.parse.apply(this,[t,e]);if(0!==i)return a(i)&&i>0?i:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?Math.max(0,t):null,this.max=a(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!a(this._userMin)&&(this.min=t===yo(this.min,0)?yo(this.min,-1):yo(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,s=this.max;const n=e=>i=t?i:e,o=t=>s=e?s:t;i===s&&(i<=0?(n(1),o(10)):(n(yo(i,-1)),o(yo(s,1)))),i<=0&&n(yo(s,-1)),s<=0&&o(yo(i,1)),this.min=i,this.max=s}buildTicks(){const t=this.options,e=wo({min:this._userMin,max:this._userMax},this);return\"ticks\"===t.bounds&&j(e,this,\"value\"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?\"0\":ne(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=z(t),this._valueRange=z(this.max)-z(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(z(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function So(t){const e=t.ticks;if(e.display&&t.display){const t=ki(e.backdropPadding);return l(e.font&&e.font.size,ue.font.size)+t.height}return 0}function Po(t,e,i,s,n){return t===s||t===n?{start:e-i/2,end:e+i/2}:t<s||t>n?{start:e-i,end:e}:{start:e,end:e+i}}function Do(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},i=Object.assign({},e),s=[],o=[],a=t._pointLabels.length,r=t.options.pointLabels,l=r.centerPointLabels?C/a:0;for(let u=0;u<a;u++){const a=r.setContext(t.getPointLabelContext(u));o[u]=a.padding;const f=t.getPointPosition(u,t.drawingArea+o[u],l),g=Si(a.font),p=(h=t.ctx,c=g,d=n(d=t._pointLabels[u])?d:[d],{w:Oe(h,c.string,d),h:d.length*c.lineHeight});s[u]=p;const m=G(t.getIndexAngle(u)+l),x=Math.round(Y(m));Co(i,e,m,Po(x,f.x,p.w,0,180),Po(x,f.y,p.h,90,270))}var h,c,d;t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=function(t,e,i){const s=[],n=t._pointLabels.length,o=t.options,{centerPointLabels:a,display:r}=o.pointLabels,l={extra:So(o)/2,additionalAngle:a?C/n:0};let h;for(let o=0;o<n;o++){l.padding=i[o],l.size=e[o];const n=Oo(t,o,l);s.push(n),\"auto\"===r&&(n.visible=Ao(n,h),n.visible&&(h=n))}return s}(t,s,o)}function Co(t,e,i,s,n){const o=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));let r=0,l=0;s.start<e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end>e.r&&(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start<e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end>e.b&&(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}function Oo(t,e,i){const s=t.drawingArea,{extra:n,additionalAngle:o,padding:a,size:r}=i,l=t.getPointPosition(e,s+n+a,o),h=Math.round(Y(G(l.angle+E))),c=function(t,e,i){90===i||270===i?t-=e/2:(i>270||i<90)&&(t-=e);return t}(l.y,r.h,h),d=function(t){if(0===t||180===t)return\"center\";if(t<180)return\"left\";return\"right\"}(h),u=function(t,e,i){\"right\"===i?t-=e:\"center\"===i&&(t-=e/2);return t}(l.x,r.w,d);return{visible:!0,x:l.x,y:c,textAlign:d,left:u,top:c,right:u+r.w,bottom:c+r.h}}function Ao(t,e){if(!e)return!0;const{left:i,top:s,right:n,bottom:o}=t;return!(Re({x:i,y:s},e)||Re({x:i,y:o},e)||Re({x:n,y:s},e)||Re({x:n,y:o},e))}function To(t,e,i){const{left:n,top:o,right:a,bottom:r}=i,{backdropColor:l}=e;if(!s(l)){const i=wi(e.borderRadius),s=ki(e.backdropPadding);t.fillStyle=l;const h=n-s.left,c=o-s.top,d=a-n+s.width,u=r-o+s.height;Object.values(i).some((t=>0!==t))?(t.beginPath(),He(t,{x:h,y:c,w:d,h:u,radius:i}),t.fill()):t.fillRect(h,c,d,u)}}function Lo(t,e,i,s){const{ctx:n}=t;if(i)n.arc(t.xCenter,t.yCenter,e,0,O);else{let i=t.getPointPosition(0,e);n.moveTo(i.x,i.y);for(let o=1;o<s;o++)i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}}class Eo extends xo{static id=\"radialLinear\";static defaults={display:!0,animate:!0,position:\"chartArea\",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ae.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}};static defaultRoutes={\"angleLines.color\":\"borderColor\",\"pointLabels.color\":\"color\",\"ticks.color\":\"color\"};static descriptors={angleLines:{_fallback:\"grid\"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=ki(So(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=a(t)&&!isNaN(t)?t:0,this.max=a(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/So(this.options))}generateTickLabels(t){xo.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const i=d(this.options.pointLabels.callback,[t,e],this);return i||0===i?i:\"\"})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?Do(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,s){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}getIndexAngle(t){return G(t*(O/(this._pointLabels.length||1))+$(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(s(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(s(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return function(t,e,i){return Ci(t,{label:i,index:e,type:\"pointLabel\"})}(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const s=this.getIndexAngle(t)-E+i;return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=this._pointLabelItems[t];return{left:e,top:i,right:s,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),Lo(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:s,border:n}=e,o=this._pointLabels.length;let a,r,l;if(e.pointLabels.display&&function(t,e){const{ctx:i,options:{pointLabels:s}}=t;for(let n=e-1;n>=0;n--){const e=t._pointLabelItems[n];if(!e.visible)continue;const o=s.setContext(t.getPointLabelContext(n));To(i,o,e);const a=Si(o.font),{x:r,y:l,textAlign:h}=e;Ne(i,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:\"middle\"})}}(this,o),s.display&&this.ticks.forEach(((t,e)=>{if(0!==e||0===e&&this.min<0){r=this.getDistanceFromCenterForValue(t.value);const i=this.getContext(e),a=s.setContext(i),l=n.setContext(i);!function(t,e,i,s,n){const o=t.ctx,a=e.circular,{color:r,lineWidth:l}=e;!a&&!s||!r||!l||i<0||(o.save(),o.strokeStyle=r,o.lineWidth=l,o.setLineDash(n.dash||[]),o.lineDashOffset=n.dashOffset,o.beginPath(),Lo(t,i,a,s),o.closePath(),o.stroke(),o.restore())}(this,a,r,o,l)}})),i.display){for(t.save(),a=o-1;a>=0;a--){const s=i.setContext(this.getPointLabelContext(a)),{color:n,lineWidth:o}=s;o&&n&&(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(s.borderDash),t.lineDashOffset=s.borderDashOffset,r=this.getDistanceFromCenterForValue(e.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const s=this.getIndexAngle(0);let n,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign=\"center\",t.textBaseline=\"middle\",this.ticks.forEach(((s,a)=>{if(0===a&&this.min>=0&&!e.reverse)return;const r=i.setContext(this.getContext(a)),l=Si(r.font);if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;const e=ki(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}Ne(t,s.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})})),t.restore()}drawTitle(){}}const Ro={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Io=Object.keys(Ro);function zo(t,e){return t-e}function Fo(t,e){if(s(e))return null;const i=t._adapter,{parser:n,round:o,isoWeekday:r}=t._parseOpts;let l=e;return\"function\"==typeof n&&(l=n(l)),a(l)||(l=\"string\"==typeof n?i.parse(l,n):i.parse(l)),null===l?null:(o&&(l=\"week\"!==o||!N(r)&&!0!==r?i.startOf(l,o):i.startOf(l,\"isoWeek\",r)),+l)}function Vo(t,e,i,s){const n=Io.length;for(let o=Io.indexOf(t);o<n-1;++o){const t=Ro[Io[o]],n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((i-e)/(n*t.size))<=s)return Io[o]}return Io[n-1]}function Bo(t,e,i){if(i){if(i.length){const{lo:s,hi:n}=et(i,e);t[i[s]>=e?i[s]:i[n]]=!0}}else t[e]=!0}function Wo(t,e,i){const s=[],n={},o=e.length;let a,r;for(a=0;a<o;++a)r=e[a],n[r]=a,s.push({value:r,major:!1});return 0!==o&&i?function(t,e,i,s){const n=t._adapter,o=+n.startOf(e[0].value,s),a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,s))l=i[r],l>=0&&(e[l].major=!0);return e}(t,s,n,i):s}class No extends Js{static id=\"time\";static defaults={bounds:\"data\",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:\"millisecond\",displayFormats:{}},ticks:{source:\"auto\",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit=\"day\",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const i=t.time||(t.time={}),s=this._adapter=new Rn._date(t.adapters.date);s.init(e),b(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:Fo(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,i=t.time.unit||\"day\";let{min:s,max:n,minDefined:o,maxDefined:r}=this.getUserBounds();function l(t){o||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}o&&r||(l(this._getLabelBounds()),\"ticks\"===t.bounds&&\"labels\"===t.ticks.source||l(this.getMinMax(!1))),s=a(s)&&!isNaN(s)?s:+e.startOf(Date.now(),i),n=a(n)&&!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],i=t[t.length-1]),{min:e,max:i}}buildTicks(){const t=this.options,e=t.time,i=t.ticks,s=\"labels\"===i.source?this.getLabelTimestamps():this._generate();\"ticks\"===t.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const n=this.min,o=nt(s,n,this.max);return this._unit=e.unit||(i.autoSkip?Vo(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):function(t,e,i,s,n){for(let o=Io.length-1;o>=Io.indexOf(i);o--){const i=Io[o];if(Ro[i].common&&t._adapter.diff(n,s,i)>=e-1)return i}return Io[i?Io.indexOf(i):0]}(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&&\"year\"!==this._unit?function(t){for(let e=Io.indexOf(t)+1,i=Io.length;e<i;++e)if(Ro[Io[e]].common)return Io[e]}(this._unit):void 0,this.initOffsets(s),t.reverse&&o.reverse(),Wo(this,o,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,i,s=0,n=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;s=J(s,0,o),n=J(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}_generate(){const t=this._adapter,e=this.min,i=this.max,s=this.options,n=s.time,o=n.unit||Vo(n.minUnit,e,i,this._getLabelCapacity(e)),a=l(s.ticks.stepSize,1),r=\"week\"===o&&n.isoWeekday,h=N(r)||!0===r,c={};let d,u,f=e;if(h&&(f=+t.startOf(f,\"isoWeek\",r)),f=+t.startOf(f,h?\"day\":o),t.diff(i,e,o)>1e5*a)throw new Error(e+\" and \"+i+\" are too far apart with stepSize of \"+a+\" \"+o);const g=\"data\"===s.ticks.source&&this.getDataTimestamps();for(d=f,u=0;d<i;d=+t.add(d,a,o),u++)Bo(c,d,g);return d!==i&&\"ticks\"!==s.bounds&&1!==u||Bo(c,d,g),Object.keys(c).sort(zo).map((t=>+t))}getLabelForValue(t){const e=this._adapter,i=this.options.time;return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}format(t,e){const i=this.options.time.displayFormats,s=this._unit,n=e||i[s];return this._adapter.format(t,n)}_tickFormatFunction(t,e,i,s){const n=this.options,o=n.ticks.callback;if(o)return d(o,[t,e,i],this);const a=n.time.displayFormats,r=this._unit,l=this._majorUnit,h=r&&a[r],c=l&&a[l],u=i[e],f=l&&c&&u&&u.major;return this._adapter.format(t,s||(f?c:h))}generateTickLabels(t){let e,i,s;for(e=0,i=t.length;e<i;++e)s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,i=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+i)*e.factor)}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+i*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,i=this.ctx.measureText(t).width,s=$(this.isHorizontal()?e.maxRotation:e.minRotation),n=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:i*n+a*o,h:i*o+a*n}}_getLabelCapacity(t){const e=this.options.time,i=e.displayFormats,s=i[e.unit]||i.millisecond,n=this._tickFormatFunction(t,0,Wo(this,[t],this._majorUnit),s),o=this._getLabelSize(n),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t,e,i=this._cache.data||[];if(i.length)return i;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,e=s.length;t<e;++t)i=i.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(i)}getLabelTimestamps(){const t=this._cache.labels||[];let e,i;if(t.length)return t;const s=this.getLabels();for(e=0,i=s.length;e<i;++e)t.push(Fo(this,s[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return lt(t.sort(zo))}}function Ho(t,e,i){let s,n,o,a,r=0,l=t.length-1;i?(e>=t[r].pos&&e<=t[l].pos&&({lo:r,hi:l}=it(t,\"pos\",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e>=t[r].time&&e<=t[l].time&&({lo:r,hi:l}=it(t,\"time\",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));const h=n-s;return h?o+(a-o)*(e-s)/h:o}var jo=Object.freeze({__proto__:null,CategoryScale:class extends Js{static id=\"category\";static defaults={ticks:{callback:po}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:i,label:s}of e)t[i]===s&&t.splice(i,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(s(t))return null;const i=this.getLabels();return((t,e)=>null===t?null:J(Math.round(t),0,e))(e=isFinite(e)&&i[e]===t?e:go(i,t,l(e,t),this._addedLabels),i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:s}=this.getMinMax(!0);\"ticks\"===this.options.bounds&&(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,s=[];let n=this.getLabels();n=0===t&&e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let i=t;i<=e;i++)s.push({value:i});return s}getLabelForValue(t){return po.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return\"number\"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}},LinearScale:bo,LogarithmicScale:ko,RadialLinearScale:Eo,TimeScale:No,TimeSeriesScale:class extends No{static id=\"timeseries\";static defaults=No.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Ho(e,this.min),this._tableRange=Ho(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,s=[],n=[];let o,a,r,l,h;for(o=0,a=t.length;o<a;++o)l=t[o],l>=e&&l<=i&&s.push(l);if(s.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=s.length;o<a;++o)h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&&n.push({time:l,pos:o/(a-1)});return n}_generate(){const t=this.min,e=this.max;let i=super.getDataTimestamps();return i.includes(t)&&i.length||i.splice(0,0,t),i.includes(e)&&1!==i.length||i.push(e),i.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return t=e.length&&i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(Ho(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return Ho(this._table,i*this._tableRange+this._minPos,!0)}}});const $o=[\"rgb(54, 162, 235)\",\"rgb(255, 99, 132)\",\"rgb(255, 159, 64)\",\"rgb(255, 205, 86)\",\"rgb(75, 192, 192)\",\"rgb(153, 102, 255)\",\"rgb(201, 203, 207)\"],Yo=$o.map((t=>t.replace(\"rgb(\",\"rgba(\").replace(\")\",\", 0.5)\")));function Uo(t){return $o[t%$o.length]}function Xo(t){return Yo[t%Yo.length]}function qo(t){let e=0;return(i,s)=>{const n=t.getDatasetMeta(s).controller;n instanceof jn?e=function(t,e){return t.backgroundColor=t.data.map((()=>Uo(e++))),e}(i,e):n instanceof $n?e=function(t,e){return t.backgroundColor=t.data.map((()=>Xo(e++))),e}(i,e):n&&(e=function(t,e){return t.borderColor=Uo(e),t.backgroundColor=Xo(e),++e}(i,e))}}function Ko(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return!0;return!1}var Go={id:\"colors\",defaults:{enabled:!0,forceOverride:!1},beforeLayout(t,e,i){if(!i.enabled)return;const{data:{datasets:s},options:n}=t.config,{elements:o}=n,a=Ko(s)||(r=n)&&(r.borderColor||r.backgroundColor)||o&&Ko(o)||\"rgba(0,0,0,0.1)\"!==ue.borderColor||\"rgba(0,0,0,0.1)\"!==ue.backgroundColor;var r;if(!i.forceOverride&&a)return;const l=qo(t);s.forEach(l)}};function Zo(t){if(t._decimated){const e=t._data;delete t._decimated,delete t._data,Object.defineProperty(t,\"data\",{configurable:!0,enumerable:!0,writable:!0,value:e})}}function Jo(t){t.data.datasets.forEach((t=>{Zo(t)}))}var Qo={id:\"decimation\",defaults:{algorithm:\"min-max\",enabled:!1},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled)return void Jo(t);const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e,l=t.getDatasetMeta(o),h=a||e.data;if(\"y\"===Pi([r,t.options.indexAxis]))return;if(!l.controller.supportsDecimation)return;const c=t.scales[l.xAxisID];if(\"linear\"!==c.type&&\"time\"!==c.type)return;if(t.options.parsing)return;let{start:d,count:u}=function(t,e){const i=e.length;let s,n=0;const{iScale:o}=t,{min:a,max:r,minDefined:l,maxDefined:h}=o.getUserBounds();return l&&(n=J(it(e,o.axis,a).lo,0,i-1)),s=h?J(it(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}(l,h);if(u<=(i.threshold||4*n))return void Zo(e);let f;switch(s(a)&&(e._data=h,delete e.data,Object.defineProperty(e,\"data\",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(t){this._data=t}})),i.algorithm){case\"lttb\":f=function(t,e,i,s,n){const o=n.samples||s;if(o>=i)return t.slice(e,e+i);const a=[],r=(i-2)/(o-2);let l=0;const h=e+i-1;let c,d,u,f,g,p=e;for(a[l++]=t[p],c=0;c<o-2;c++){let s,n=0,o=0;const h=Math.floor((c+1)*r)+1+e,m=Math.min(Math.floor((c+2)*r)+1,i)+e,x=m-h;for(s=h;s<m;s++)n+=t[s].x,o+=t[s].y;n/=x,o/=x;const b=Math.floor(c*r)+1+e,_=Math.min(Math.floor((c+1)*r)+1,i)+e,{x:y,y:v}=t[p];for(u=f=-1,s=b;s<_;s++)f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f>u&&(u=f,d=t[s],g=s);a[l++]=d,p=g}return a[l++]=t[h],a}(h,d,u,n,i);break;case\"min-max\":f=function(t,e,i,n){let o,a,r,l,h,c,d,u,f,g,p=0,m=0;const x=[],b=e+i-1,_=t[e].x,y=t[b].x-_;for(o=e;o<e+i;++o){a=t[o],r=(a.x-_)/y*n,l=a.y;const e=0|r;if(e===h)l<f?(f=l,c=o):l>g&&(g=l,d=o),p=(m*p+a.x)/++m;else{const i=o-1;if(!s(c)&&!s(d)){const e=Math.min(c,d),s=Math.max(c,d);e!==u&&e!==i&&x.push({...t[e],x:p}),s!==u&&s!==i&&x.push({...t[s],x:p})}o>0&&i!==u&&x.push(t[i]),x.push(a),h=e,m=0,f=g=l,c=d=u=o}}return x}(h,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){Jo(t)}};function ta(t,e,i,s){if(s)return;let n=e[t],o=i[t];return\"angle\"===t&&(n=G(n),o=G(o)),{property:t,start:n,end:o}}function ea(t,e,i){for(;e>t;e--){const t=i[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function ia(t,e,i,s){return t&&e?s(t[i],e[i]):t?t[i]:e?e[i]:0}function sa(t,e){let i=[],s=!1;return n(t)?(s=!0,i=t):i=function(t,e){const{x:i=null,y:s=null}=t||{},n=e.points,o=[];return e.segments.forEach((({start:t,end:e})=>{e=ea(t,e,n);const a=n[t],r=n[e];null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&&(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))})),o}(t,e),i.length?new no({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}function na(t){return t&&!1!==t.fill}function oa(t,e,i){let s=t[e].fill;const n=[e];let o;if(!i)return s;for(;!1!==s&&-1===n.indexOf(s);){if(!a(s))return s;if(o=t[s],!o)return!1;if(o.visible)return s;n.push(s),s=o.fill}return!1}function aa(t,e,i){const s=function(t){const e=t.options,i=e.fill;let s=l(i&&i.target,i);void 0===s&&(s=!!e.backgroundColor);if(!1===s||null===s)return!1;if(!0===s)return\"origin\";return s}(t);if(o(s))return!isNaN(s.value)&&s;let n=parseFloat(s);return a(n)&&Math.floor(n)===n?function(t,e,i,s){\"-\"!==t&&\"+\"!==t||(i=e+i);if(i===e||i<0||i>=s)return!1;return i}(s[0],e,n,i):[\"origin\",\"start\",\"end\",\"stack\",\"shape\"].indexOf(s)>=0&&s}function ra(t,e,i){const s=[];for(let n=0;n<i.length;n++){const o=i[n],{first:a,last:r,point:l}=la(o,e,\"x\");if(!(!l||a&&r))if(a)s.unshift(l);else if(t.push(l),!r)break}t.push(...s)}function la(t,e,i){const s=t.interpolate(e,i);if(!s)return{};const n=s[i],o=t.segments,a=t.points;let r=!1,l=!1;for(let t=0;t<o.length;t++){const e=o[t],s=a[e.start][i],h=a[e.end][i];if(tt(n,s,h)){r=n===s,l=n===h;break}}return{first:r,last:l,point:s}}class ha{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,i){const{x:s,y:n,radius:o}=this;return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}interpolate(t){const{x:e,y:i,radius:s}=this,n=t.angle;return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}}function ca(t){const{chart:e,fill:i,line:s}=t;if(a(i))return function(t,e){const i=t.getDatasetMeta(e),s=i&&t.isDatasetVisible(e);return s?i.dataset:null}(e,i);if(\"stack\"===i)return function(t){const{scale:e,index:i,line:s}=t,n=[],o=s.segments,a=s.points,r=function(t,e){const i=[],s=t.getMatchingVisibleMetas(\"line\");for(let t=0;t<s.length;t++){const n=s[t];if(n.index===e)break;n.hidden||i.unshift(n.dataset)}return i}(e,i);r.push(sa({x:null,y:e.bottom},s));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)ra(n,a[t],r)}return new no({points:n,options:{}})}(t);if(\"shape\"===i)return!0;const n=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:i}=t,s=e.options,n=e.getLabels().length,a=s.reverse?e.max:e.min,r=function(t,e,i){let s;return s=\"start\"===t?i:\"end\"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue(),s}(i,e,a),l=[];if(s.grid.circular){const t=e.getPointPositionForValue(0,a);return new ha({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}for(let t=0;t<n;++t)l.push(e.getPointPositionForValue(t,r));return l}(t);return function(t){const{scale:e={},fill:i}=t,s=function(t,e){let i=null;return\"start\"===t?i=e.bottom:\"end\"===t?i=e.top:o(t)?i=e.getPixelForValue(t.value):e.getBasePixel&&(i=e.getBasePixel()),i}(i,e);if(a(s)){const t=e.isHorizontal();return{x:t?s:null,y:t?null:s}}return null}(t)}(t);return n instanceof ha?n:sa(n,s)}function da(t,e,i){const s=ca(e),{line:n,scale:o,axis:a}=e,r=n.options,l=r.fill,h=r.backgroundColor,{above:c=h,below:d=h}=l||{};s&&n.points.length&&(Ie(t,i),function(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r}=e,l=i._loop?\"angle\":e.axis;t.save(),\"x\"===l&&o!==n&&(ua(t,s,a.top),fa(t,{line:i,target:s,color:n,scale:r,property:l}),t.restore(),t.save(),ua(t,s,a.bottom));fa(t,{line:i,target:s,color:o,scale:r,property:l}),t.restore()}(t,{line:n,target:s,above:c,below:d,area:i,scale:o,axis:a}),ze(t))}function ua(t,e,i){const{segments:s,points:n}=e;let o=!0,a=!1;t.beginPath();for(const r of s){const{start:s,end:l}=r,h=n[s],c=n[ea(s,l,n)];o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}t.lineTo(e.first().x,i),t.closePath(),t.clip()}function fa(t,e){const{line:i,target:s,property:n,color:o,scale:a}=e,r=function(t,e,i){const s=t.segments,n=t.points,o=e.points,a=[];for(const t of s){let{start:s,end:r}=t;r=ea(s,r,n);const l=ta(i,n[s],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[s],end:n[r]});continue}const h=Ii(e,l);for(const e of h){const s=ta(i,o[e.start],o[e.end],e.loop),r=Ri(t,n,s);for(const t of r)a.push({source:t,target:e,start:{[i]:ia(l,s,\"start\",Math.max)},end:{[i]:ia(l,s,\"end\",Math.min)}})}}return a}(i,s,n);for(const{source:e,target:l,start:h,end:c}of r){const{style:{backgroundColor:r=o}={}}=e,d=!0!==s;t.save(),t.fillStyle=r,ga(t,a,d&&ta(n,h,c)),t.beginPath();const u=!!i.pathSegment(t,e);let f;if(d){u?t.closePath():pa(t,s,c,n);const e=!!s.pathSegment(t,l,{move:u,reverse:!0});f=u&&e,f||pa(t,s,h,n)}t.closePath(),t.fill(f?\"evenodd\":\"nonzero\"),t.restore()}}function ga(t,e,i){const{top:s,bottom:n}=e.chart.chartArea,{property:o,start:a,end:r}=i||{};\"x\"===o&&(t.beginPath(),t.rect(a,s,r-a,n-s),t.clip())}function pa(t,e,i,s){const n=e.interpolate(i,s);n&&t.lineTo(n.x,n.y)}var ma={id:\"filler\",afterDatasetsUpdate(t,e,i){const s=(t.data.datasets||[]).length,n=[];let o,a,r,l;for(a=0;a<s;++a)o=t.getDatasetMeta(a),r=o.dataset,l=null,r&&r.options&&r instanceof no&&(l={visible:t.isDatasetVisible(a),index:a,fill:aa(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);for(a=0;a<s;++a)l=n[a],l&&!1!==l.fill&&(l.fill=oa(n,a,i.propagate))},beforeDraw(t,e,i){const s=\"beforeDraw\"===i.drawTime,n=t.getSortedVisibleDatasetMetas(),o=t.chartArea;for(let e=n.length-1;e>=0;--e){const i=n[e].$filler;i&&(i.line.updateControlPoints(o,i.axis),s&&i.fill&&da(t.ctx,i,o))}},beforeDatasetsDraw(t,e,i){if(\"beforeDatasetsDraw\"!==i.drawTime)return;const s=t.getSortedVisibleDatasetMetas();for(let e=s.length-1;e>=0;--e){const i=s[e].$filler;na(i)&&da(t.ctx,i,t.chartArea)}},beforeDatasetDraw(t,e,i){const s=e.meta.$filler;na(s)&&\"beforeDatasetDraw\"===i.drawTime&&da(t.ctx,s,t.chartArea)},defaults:{propagate:!0,drawTime:\"beforeDatasetDraw\"}};const xa=(t,e)=>{let{boxHeight:i=e,boxWidth:s=e}=t;return t.usePointStyle&&(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}};class ba extends Hs{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=d(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,i)=>t.sort(e,i,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const i=t.labels,s=Si(i.font),n=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:r}=xa(i,n);let l,h;e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,s,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.lineWidths=[0],h=s+a;let c=t;n.textAlign=\"left\",n.textBaseline=\"middle\";let d=-1,u=-h;return this.legendItems.forEach(((t,f)=>{const g=i+e/2+n.measureText(t.text).width;(0===f||l[l.length-1]+g+2*a>o)&&(c+=h,l[l.length-(f>0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a})),c}_fitCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.columnSizes=[],h=o-t;let c=a,d=0,u=0,f=0,g=0;return this.legendItems.forEach(((t,o)=>{const{itemWidth:p,itemHeight:m}=function(t,e,i,s,n){const o=function(t,e,i,s){let n=t.text;n&&\"string\"!=typeof n&&(n=n.reduce(((t,e)=>t.length>e.length?t:e)));return e+i.size/2+s.measureText(n).width}(s,t,e,i),a=function(t,e,i){let s=t;\"string\"!=typeof e.text&&(s=_a(e,i));return s}(n,s,e.lineHeight);return{itemWidth:o,itemHeight:a}}(i,e,n,t,s);o>0&&u+m+2*a>h&&(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:m},d=Math.max(d,p),u+=m+a})),c+=d,l.push({width:d,height:u}),c}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=this,o=Oi(n,this.left,this.width);if(this.isHorizontal()){let n=0,a=ft(i,this.left+s,this.right-this.lineWidths[n]);for(const r of e)n!==r.row&&(n=r.row,a=ft(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}else{let n=0,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height);for(const r of e)r.col!==n&&(n=r.col,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}}isHorizontal(){return\"top\"===this.options.position||\"bottom\"===this.options.position}draw(){if(this.options.display){const t=this.ctx;Ie(t,this),this._draw(),ze(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=this,{align:n,labels:o}=t,a=ue.color,r=Oi(t.rtl,this.left,this.width),h=Si(o.font),{padding:c}=o,d=h.size,u=d/2;let f;this.drawTitle(),s.textAlign=r.textAlign(\"left\"),s.textBaseline=\"middle\",s.lineWidth=.5,s.font=h.string;const{boxWidth:g,boxHeight:p,itemHeight:m}=xa(o,d),x=this.isHorizontal(),b=this._computeTitleHeight();f=x?{x:ft(n,this.left+c,this.right-i[0]),y:this.top+c+b,line:0}:{x:this.left+c,y:ft(n,this.top+b+c,this.bottom-e[0].height),line:0},Ai(this.ctx,t.textDirection);const _=m+c;this.legendItems.forEach(((y,v)=>{s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;const M=s.measureText(y.text).width,w=r.textAlign(y.textAlign||(y.textAlign=o.textAlign)),k=g+u+M;let S=f.x,P=f.y;r.setWidth(this.width),x?v>0&&S+k+c>this.right&&(P=f.y+=_,f.line++,S=f.x=ft(n,this.left+c,this.right-i[f.line])):v>0&&P+_>this.bottom&&(S=f.x=S+e[f.line].width+c,f.line++,P=f.y=ft(n,this.top+b+c,this.bottom-e[f.line].height));if(function(t,e,i){if(isNaN(g)||g<=0||isNaN(p)||p<0)return;s.save();const n=l(i.lineWidth,1);if(s.fillStyle=l(i.fillStyle,a),s.lineCap=l(i.lineCap,\"butt\"),s.lineDashOffset=l(i.lineDashOffset,0),s.lineJoin=l(i.lineJoin,\"miter\"),s.lineWidth=n,s.strokeStyle=l(i.strokeStyle,a),s.setLineDash(l(i.lineDash,[])),o.usePointStyle){const a={radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},l=r.xPlus(t,g/2);Ee(s,a,l,e+u,o.pointStyleWidth&&g)}else{const o=e+Math.max((d-p)/2,0),a=r.leftForLtr(t,g),l=wi(i.borderRadius);s.beginPath(),Object.values(l).some((t=>0!==t))?He(s,{x:a,y:o,w:g,h:p,radius:l}):s.rect(a,o,g,p),s.fill(),0!==n&&s.stroke()}s.restore()}(r.x(S),P,y),S=gt(w,S+g+u,x?S+k:this.right,t.rtl),function(t,e,i){Ne(s,i.text,t,e+m/2,h,{strikethrough:i.hidden,textAlign:r.textAlign(i.textAlign)})}(r.x(S),P,y),x)f.x+=k+c;else if(\"string\"!=typeof y.text){const t=h.lineHeight;f.y+=_a(y,t)+c}else f.y+=_})),Ti(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=Si(e.font),s=ki(e.padding);if(!e.display)return;const n=Oi(t.rtl,this.left,this.width),o=this.ctx,a=e.position,r=i.size/2,l=s.top+r;let h,c=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+l,c=ft(t.align,c,this.right-d);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);h=l+ft(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=ft(a,c,c+d);o.textAlign=n.textAlign(ut(a)),o.textBaseline=\"middle\",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ne(o,e.text,u,h,i)}_computeTitleHeight(){const t=this.options.title,e=Si(t.font),i=ki(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,s,n;if(tt(t,this.left,this.right)&&tt(e,this.top,this.bottom))for(n=this.legendHitBoxes,i=0;i<n.length;++i)if(s=n[i],tt(t,s.left,s.left+s.width)&&tt(e,s.top,s.top+s.height))return this.legendItems[i];return null}handleEvent(t){const e=this.options;if(!function(t,e){if((\"mousemove\"===t||\"mouseout\"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&(\"click\"===t||\"mouseup\"===t))return!0;return!1}(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if(\"mousemove\"===t.type||\"mouseout\"===t.type){const o=this._hoveredItem,a=(n=i,null!==(s=o)&&null!==n&&s.datasetIndex===n.datasetIndex&&s.index===n.index);o&&!a&&d(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&&!a&&d(e.onHover,[t,i,this],this)}else i&&d(e.onClick,[t,i,this],this);var s,n}}function _a(t,e){return e*(t.text?t.text.length:0)}var ya={id:\"legend\",_element:ba,start(t,e,i){const s=t.legend=new ba({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s)},stop(t){as.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,i){const s=t.legend;as.configure(t,s,i),s.options=i},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:\"top\",align:\"center\",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,i){const s=e.datasetIndex,n=i.chart;n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(i?0:void 0),h=ki(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&&(r||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:\"center\",text:\"\"}},descriptors:{_scriptable:t=>!t.startsWith(\"on\"),labels:{_scriptable:t=>![\"generateLabels\",\"filter\",\"sort\"].includes(t)}}};class va extends Hs{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const s=n(i.text)?i.text.length:1;this._padding=ki(i.padding);const o=s*Si(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=o:this.width=o}isHorizontal(){const t=this.options.position;return\"top\"===t||\"bottom\"===t}_drawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=this,a=o.align;let r,l,h,c=0;return this.isHorizontal()?(l=ft(a,i,n),h=e+t,r=n-i):(\"left\"===o.position?(l=i+t,h=ft(a,s,e),c=-.5*C):(l=n-t,h=ft(a,e,s),c=.5*C),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=Si(e.font),s=i.lineHeight/2+this._padding.top,{titleX:n,titleY:o,maxWidth:a,rotation:r}=this._drawArgs(s);Ne(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:ut(e.align),textBaseline:\"middle\",translation:[n,o]})}}var Ma={id:\"title\",_element:va,start(t,e,i){!function(t,e){const i=new va({ctx:t.ctx,options:e,chart:t});as.configure(t,i,e),as.addBox(t,i),t.titleBlock=i}(t,i)},stop(t){const e=t.titleBlock;as.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,i){const s=t.titleBlock;as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"bold\"},fullSize:!0,padding:10,position:\"top\",text:\"\",weight:2e3},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const wa=new WeakMap;var ka={id:\"subtitle\",start(t,e,i){const s=new va({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s),wa.set(t,s)},stop(t){as.removeBox(t,wa.get(t)),wa.delete(t)},beforeUpdate(t,e,i){const s=wa.get(t);as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"normal\"},fullSize:!0,padding:0,position:\"top\",text:\"\",weight:1500},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const Sa={average(t){if(!t.length)return!1;let e,i,s=new Set,n=0,o=0;for(e=0,i=t.length;e<i;++e){const i=t[e].element;if(i&&i.hasValue()){const t=i.tooltipPosition();s.add(t.x),n+=t.y,++o}}if(0===o||0===s.size)return!1;return{x:[...s].reduce(((t,e)=>t+e))/s.size,y:n/o}},nearest(t,e){if(!t.length)return!1;let i,s,n,o=e.x,a=e.y,r=Number.POSITIVE_INFINITY;for(i=0,s=t.length;i<s;++i){const s=t[i].element;if(s&&s.hasValue()){const t=q(e,s.getCenterPoint());t<r&&(r=t,n=s)}}if(n){const t=n.tooltipPosition();o=t.x,a=t.y}return{x:o,y:a}}};function Pa(t,e){return e&&(n(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Da(t){return(\"string\"==typeof t||t instanceof String)&&t.indexOf(\"\\n\")>-1?t.split(\"\\n\"):t}function Ca(t,e){const{element:i,datasetIndex:s,index:n}=e,o=t.getDatasetMeta(s).controller,{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}function Oa(t,e){const i=t.chart.ctx,{body:s,footer:n,title:o}=t,{boxWidth:a,boxHeight:r}=e,l=Si(e.bodyFont),h=Si(e.titleFont),c=Si(e.footerFont),d=o.length,f=n.length,g=s.length,p=ki(e.padding);let m=p.height,x=0,b=s.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(b+=t.beforeBody.length+t.afterBody.length,d&&(m+=d*h.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),b){m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(b-g)*l.lineHeight+(b-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);let _=0;const y=function(t){x=Math.max(x,i.measureText(t).width+_)};return i.save(),i.font=h.string,u(t.title,y),i.font=l.string,u(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,u(s,(t=>{u(t.before,y),u(t.lines,y),u(t.after,y)})),_=0,i.font=c.string,u(t.footer,y),i.restore(),x+=p.width,{width:x,height:m}}function Aa(t,e,i,s){const{x:n,width:o}=i,{width:a,chartArea:{left:r,right:l}}=t;let h=\"center\";return\"center\"===s?h=n<=(r+l)/2?\"left\":\"right\":n<=o/2?h=\"left\":n>=a-o/2&&(h=\"right\"),function(t,e,i,s){const{x:n,width:o}=s,a=i.caretSize+i.caretPadding;return\"left\"===t&&n+o+a>e.width||\"right\"===t&&n-o-a<0||void 0}(h,t,e,i)&&(h=\"center\"),h}function Ta(t,e,i){const s=i.yAlign||e.yAlign||function(t,e){const{y:i,height:s}=e;return i<s/2?\"top\":i>t.height-s/2?\"bottom\":\"center\"}(t,i);return{xAlign:i.xAlign||e.xAlign||Aa(t,e,i,s),yAlign:s}}function La(t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=t,{xAlign:r,yAlign:l}=i,h=n+o,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(a);let g=function(t,e){let{x:i,width:s}=t;return\"right\"===e?i-=s:\"center\"===e&&(i-=s/2),i}(e,r);const p=function(t,e,i){let{y:s,height:n}=t;return\"top\"===e?s+=i:s-=\"bottom\"===e?n+i:n/2,s}(e,l,h);return\"center\"===l?\"left\"===r?g+=h:\"right\"===r&&(g-=h):\"left\"===r?g-=Math.max(c,u)+n:\"right\"===r&&(g+=Math.max(d,f)+n),{x:J(g,0,s.width-e.width),y:J(p,0,s.height-e.height)}}function Ea(t,e,i){const s=ki(i.padding);return\"center\"===e?t.x+t.width/2:\"right\"===e?t.x+t.width-s.right:t.x+s.left}function Ra(t){return Pa([],Da(t))}function Ia(t,e){const i=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return i?t.override(i):t}const za={beforeTitle:e,title(t){if(t.length>0){const e=t[0],i=e.chart.data.labels,s=i?i.length:0;if(this&&this.options&&\"dataset\"===this.options.mode)return e.dataset.label||\"\";if(e.label)return e.label;if(s>0&&e.dataIndex<s)return i[e.dataIndex]}return\"\"},afterTitle:e,beforeBody:e,beforeLabel:e,label(t){if(this&&this.options&&\"dataset\"===this.options.mode)return t.label+\": \"+t.formattedValue||t.formattedValue;let e=t.dataset.label||\"\";e&&(e+=\": \");const i=t.formattedValue;return s(i)||(e+=i),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:e,afterBody:e,beforeFooter:e,footer:e,afterFooter:e};function Fa(t,e,i,s){const n=t[e].call(i,s);return void 0===n?za[e].call(i,s):n}class Va extends Hs{static positioners=Sa;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,i=this.options.setContext(this.getContext()),s=i.enabled&&e.options.animation&&i.animations,n=new Os(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(n)),n}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ci(t,{tooltip:e,tooltipItems:i,type:\"tooltip\"})));var t,e,i}getTitle(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeTitle\",this,t),n=Fa(i,\"title\",this,t),o=Fa(i,\"afterTitle\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}getBeforeBody(t,e){return Ra(Fa(e.callbacks,\"beforeBody\",this,t))}getBody(t,e){const{callbacks:i}=e,s=[];return u(t,(t=>{const e={before:[],lines:[],after:[]},n=Ia(i,t);Pa(e.before,Da(Fa(n,\"beforeLabel\",this,t))),Pa(e.lines,Fa(n,\"label\",this,t)),Pa(e.after,Da(Fa(n,\"afterLabel\",this,t))),s.push(e)})),s}getAfterBody(t,e){return Ra(Fa(e.callbacks,\"afterBody\",this,t))}getFooter(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeFooter\",this,t),n=Fa(i,\"footer\",this,t),o=Fa(i,\"afterFooter\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}_createItems(t){const e=this._active,i=this.chart.data,s=[],n=[],o=[];let a,r,l=[];for(a=0,r=e.length;a<r;++a)l.push(Ca(this.chart,e[a]));return t.filter&&(l=l.filter(((e,s,n)=>t.filter(e,s,n,i)))),t.itemSort&&(l=l.sort(((e,s)=>t.itemSort(e,s,i)))),u(l,(e=>{const i=Ia(t.callbacks,e);s.push(Fa(i,\"labelColor\",this,e)),n.push(Fa(i,\"labelPointStyle\",this,e)),o.push(Fa(i,\"labelTextColor\",this,e))})),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}update(t,e){const i=this.options.setContext(this.getContext()),s=this._active;let n,o=[];if(s.length){const t=Sa[i.position].call(this,s,this._eventPosition);o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);const e=this._size=Oa(this,i),a=Object.assign({},t,e),r=Ta(this.chart,i,a),l=La(i,a,r,this.chart);this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(n={opacity:0});this._tooltipItems=o,this.$context=void 0,n&&this._resolveAnimations().update(this,n),t&&i.external&&i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,i,s){const n=this.getCaretPosition(t,i,s);e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=this,{caretSize:o,cornerRadius:a}=i,{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=wi(a),{x:d,y:u}=t,{width:f,height:g}=e;let p,m,x,b,_,y;return\"center\"===n?(_=u+g/2,\"left\"===s?(p=d,m=p-o,b=_+o,y=_-o):(p=d+f,m=p+o,b=_-o,y=_+o),x=p):(m=\"left\"===s?d+Math.max(r,h)+o:\"right\"===s?d+f-Math.max(l,c)-o:this.caretX,\"top\"===n?(b=u,_=b-o,p=m-o,x=m+o):(b=u+g,_=b+o,p=m+o,x=m-o),y=b),{x1:p,x2:m,x3:x,y1:b,y2:_,y3:y}}drawTitle(t,e,i){const s=this.title,n=s.length;let o,a,r;if(n){const l=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline=\"middle\",o=Si(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r<n;++r)e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&&(t.y+=i.titleMarginBottom-a)}}_drawColorBox(t,e,i,s,n){const a=this.labelColors[i],r=this.labelPointStyles[i],{boxHeight:l,boxWidth:h}=n,c=Si(n.bodyFont),d=Ea(this,\"left\",n),u=s.x(d),f=l<c.lineHeight?(c.lineHeight-l)/2:0,g=e.y+f;if(n.usePointStyle){const e={radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},i=s.leftForLtr(u,h)+h/2,o=g+l/2;t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,Le(t,e,i,o),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Le(t,e,i,o)}else{t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const e=s.leftForLtr(u,h),i=s.leftForLtr(s.xPlus(u,1),h-2),r=wi(a.borderRadius);Object.values(r).some((t=>0!==t))?(t.beginPath(),t.fillStyle=n.multiKeyBackground,He(t,{x:e,y:g,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),He(t,{x:i,y:g+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,g,h,l),t.strokeRect(e,g,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,g+1,h-2,l-2))}t.fillStyle=this.labelTextColors[i]}drawBody(t,e,i){const{body:s}=this,{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=i,c=Si(i.bodyFont);let d=c.lineHeight,f=0;const g=Oi(i.rtl,this.x,this.width),p=function(i){e.fillText(i,g.x(t.x+f),t.y+d/2),t.y+=d+n},m=g.textAlign(o);let x,b,_,y,v,M,w;for(e.textAlign=o,e.textBaseline=\"middle\",e.font=c.string,t.x=Ea(this,m,i),e.fillStyle=i.bodyColor,u(this.beforeBody,p),f=a&&\"right\"!==m?\"center\"===o?l/2+h:l+2+h:0,y=0,M=s.length;y<M;++y){for(x=s[y],b=this.labelTextColors[y],e.fillStyle=b,u(x.before,p),_=x.lines,a&&_.length&&(this._drawColorBox(e,t,y,g,i),d=Math.max(c.lineHeight,r)),v=0,w=_.length;v<w;++v)p(_[v]),d=c.lineHeight;u(x.after,p)}f=0,d=c.lineHeight,u(this.afterBody,p),t.y-=n}drawFooter(t,e,i){const s=this.footer,n=s.length;let o,a;if(n){const r=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline=\"middle\",o=Si(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a<n;++a)e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}}drawBackground(t,e,i,s){const{xAlign:n,yAlign:o}=this,{x:a,y:r}=t,{width:l,height:h}=i,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(s.cornerRadius);e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),\"top\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),\"center\"===o&&\"right\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),\"bottom\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),\"center\"===o&&\"left\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,i=this.$animations,s=i&&i.x,n=i&&i.y;if(s||n){const i=Sa[t.position].call(this,this._active,this._eventPosition);if(!i)return;const o=this._size=Oa(this,t),a=Object.assign({},i,this._size),r=Ta(e,t,a),l=La(t,a,r,e);s._to===l.x&&n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let i=this.opacity;if(!i)return;this._updateAnimationTarget(e);const s={width:this.width,height:this.height},n={x:this.x,y:this.y};i=Math.abs(i)<.001?0:i;const o=ki(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),Ai(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),Ti(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const i=this._active,s=t.map((({datasetIndex:t,index:e})=>{const i=this.chart.getDatasetMeta(t);if(!i)throw new Error(\"Cannot find a dataset at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}})),n=!f(i,s),o=this._positionChanged(s,e);(n||o)&&(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,i=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,n=this._active||[],o=this._getActiveElements(t,n,e,i),a=this._positionChanged(o,t),r=e||!f(o,n)||a;return r&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}_getActiveElements(t,e,i,s){const n=this.options;if(\"mouseout\"===t.type)return[];if(!s)return e.filter((t=>this.chart.data.datasets[t.datasetIndex]&&void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));const o=this.chart.getElementsAtEventForMode(t,n.mode,n,i);return n.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:i,caretY:s,options:n}=this,o=Sa[n.position].call(this,t,e);return!1!==o&&(i!==o.x||s!==o.y)}}var Ba={id:\"tooltip\",_element:Va,positioners:Sa,afterInit(t,e,i){i&&(t.tooltip=new Va({chart:t,options:i}))},beforeUpdate(t,e,i){t.tooltip&&t.tooltip.initialize(i)},reset(t,e,i){t.tooltip&&t.tooltip.initialize(i)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const i={tooltip:e};if(!1===t.notifyPlugins(\"beforeTooltipDraw\",{...i,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins(\"afterTooltipDraw\",i)}},afterEvent(t,e){if(t.tooltip){const i=e.replay;t.tooltip.handleEvent(e.event,i,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:\"average\",backgroundColor:\"rgba(0,0,0,0.8)\",titleColor:\"#fff\",titleFont:{weight:\"bold\"},titleSpacing:2,titleMarginBottom:6,titleAlign:\"left\",bodyColor:\"#fff\",bodySpacing:2,bodyFont:{},bodyAlign:\"left\",footerColor:\"#fff\",footerSpacing:2,footerMarginTop:6,footerFont:{weight:\"bold\"},footerAlign:\"left\",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:\"#fff\",displayColors:!0,boxPadding:0,borderColor:\"rgba(0,0,0,0)\",borderWidth:0,animation:{duration:400,easing:\"easeOutQuart\"},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"width\",\"height\",\"caretX\",\"caretY\"]},opacity:{easing:\"linear\",duration:200}},callbacks:za},defaultRoutes:{bodyFont:\"font\",footerFont:\"font\",titleFont:\"font\"},descriptors:{_scriptable:t=>\"filter\"!==t&&\"itemSort\"!==t&&\"external\"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:\"animation\"}},additionalOptionScopes:[\"interaction\"]};return An.register(Yn,jo,fo,t),An.helpers={...Wi},An._adapters=Rn,An.Animation=Cs,An.Animations=Os,An.animator=bt,An.controllers=en.controllers.items,An.DatasetController=Ns,An.Element=Hs,An.elements=fo,An.Interaction=Xi,An.layouts=as,An.platforms=Ss,An.Scale=Js,An.Ticks=ae,Object.assign(An,Yn,jo,fo,t,Ss),An.Chart=An,\"undefined\"!=typeof window&&(window.Chart=An),An}));\n//# sourceMappingURL=chart.umd.js.map\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */\nfunction isNonPrimitive(n: unknown) {\n  return typeof n === 'symbol' || (typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n));\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\nimport {isNullOrUndef} from './helpers.core.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, vScale, _parsed} = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n      if (spanGaps) {\n        const distanceToDefinedLo = (_parsed\n          .slice(0, start + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n      if (spanGaps) {\n        const distanceToDefinedHi = (_parsed\n          .slice(end - 1)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type PrivateChart from '../core/core.controller.js';\nimport type {Chart, ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart | PrivateChart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart | PrivateChart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  (chart as PrivateChart).height = Math.floor(chart.height);\n  (chart as PrivateChart).width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    (chart as PrivateChart).currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  if (!ctx && !canvas) {\n    return;\n  }\n\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea, isNullOrUndef} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {vScale} = controller._cachedMeta;\n        const {_parsed} = metaset;\n\n        const distanceToDefinedLo = (_parsed\n          .slice(0, result.lo + 1)\n          .reverse()\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n\n        const distanceToDefinedHi = (_parsed\n          .slice(result.hi)\n          .findIndex(\n            point => !isNullOrUndef(point[vScale.axis])));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n\n  if (!found && !options.all) {\n    return 0;\n  }\n\n  return value;\n}\n\nfunction convertObjectDataToArray(data, meta) {\n  const {iScale, vScale} = meta;\n  const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n  const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta, chartArea) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      // Unset pending resize request now to avoid possible recursion within _resize\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the event inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<TimeUnit | 'datetime', string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: string): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: string): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number | boolean): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options?: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<TimeUnit | 'datetime', string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase as {\n    new (options?: AnyObject): DateAdapter;\n    override<T extends AnyObject = AnyObject>(\n      members: Partial<Omit<DateAdapter<T>, 'options'>>\n    ): void;\n  }\n};\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find(item => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, ) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0 || (index === 0 && this.min < 0)) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if ((index === 0 && this.min >= 0) && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","import {DoughnutController, PolarAreaController, defaults} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nfunction containsDefaultColorsDefenitions() {\n  return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    const containsColorDefenition = (\n      containsColorsDefinitions(datasets) ||\n      containsColorsDefinition(chartOptions) ||\n      (elements && containsColorsDefinitions(elements)) ||\n      containsDefaultColorsDefenitions());\n\n    if (!options.forceOverride && containsColorDefenition) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of an segment -> need to add another point before this,\n      // from next line below.\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of an segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let xSet = new Set();\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    // No visible items where found, return false so we don't have to divide by 0 which reduces in NaN\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n/**\n * @namespace Chart\n */\nimport Chart from './core/core.controller.js';\n\nimport * as helpers from './helpers/index.js';\nimport _adapters from './core/core.adapters.js';\nimport Animation from './core/core.animation.js';\nimport animator from './core/core.animator.js';\nimport Animations from './core/core.animations.js';\nimport * as controllers from './controllers/index.js';\nimport DatasetController from './core/core.datasetController.js';\nimport Element from './core/core.element.js';\nimport * as elements from './elements/index.js';\nimport Interaction from './core/core.interaction.js';\nimport layouts from './core/core.layouts.js';\nimport * as platforms from './platform/index.js';\nimport * as plugins from './plugins/index.js';\nimport registry from './core/core.registry.js';\nimport Scale from './core/core.scale.js';\nimport * as scales from './scales/index.js';\nimport Ticks from './core/core.ticks.js';\n\n// Register built-ins\nChart.register(controllers, scales, elements, plugins);\n\nChart.helpers = {...helpers};\nChart._adapters = _adapters;\nChart.Animation = Animation;\nChart.Animations = Animations;\nChart.animator = animator;\nChart.controllers = registry.controllers.items;\nChart.DatasetController = DatasetController;\nChart.Element = Element;\nChart.elements = elements;\nChart.Interaction = Interaction;\nChart.layouts = layouts;\nChart.platforms = platforms;\nChart.Scale = Scale;\nChart.Ticks = Ticks;\n\n// Compatibility with ESM extensions\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\nChart.Chart = Chart;\n\nif (typeof window !== 'undefined') {\n  window.Chart = Chart;\n}\n\nexport default Chart;\n\n"],"names":["t","e","Ht","Object","freeze","__proto__","Colors","Go","Decimation","Qo","Filler","ma","Legend","ya","SubTitle","ka","Title","Ma","Tooltip","Ba","i","s","n","Array","isArray","prototype","toString","call","slice","o","a","Number","isFinite","r","l","h","endsWith","parseFloat","c","d","apply","u","length","keys","f","datasetIndex","index","g","map","create","p","indexOf","m","x","merger","b","_","hasOwnProperty","y","v","split","push","M","w","charAt","toUpperCase","k","S","P","size","has","D","type","C","Math","PI","O","A","T","POSITIVE_INFINITY","L","E","R","I","z","log10","F","sign","V","abs","B","round","pow","floor","W","sqrt","sort","pop","N","Symbol","toPrimitive","isNaN","H","j","min","max","$","Y","U","X","atan2","angle","distance","q","K","G","Z","J","Q","tt","et","lo","hi","it","st","nt","ot","at","_chartjs","listeners","defineProperty","configurable","enumerable","value","forEach","rt","splice","lt","Set","from","ht","window","requestAnimationFrame","ct","dt","clearTimeout","setTimeout","ut","ft","gt","pt","_sorted","iScale","vScale","_parsed","dataset","options","spanGaps","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","reverse","findIndex","start","count","mt","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","assign","bt","constructor","_request","_charts","Map","_running","_lastDate","_notify","duration","chart","initial","numSteps","currentStep","_refresh","_update","Date","now","running","items","_active","_total","tick","draw","_getAnims","get","complete","progress","set","listen","add","reduce","_duration","stop","cancel","remove","delete","_t","yt","vt","Mt","wt","kt","St","Pt","Dt","Ct","Ot","Tt","Lt","Et","Rt","It","zt","Vt","Wt","Nt","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","$t","Yt","Ut","Xt","qt","Kt","Zt","jt","replace","parseInt","transparent","toLowerCase","exec","Bt","_rgb","_valid","valid","rgb","rgbString","hexString","hslString","mix","interpolate","clone","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","Jt","Qt","te","ee","ie","se","ne","JSON","stringify","Intl","NumberFormat","format","oe","values","numeric","locale","notation","minimumFractionDigits","maximumFractionDigits","ticks","logarithmic","includes","significand","ae","formatters","re","le","he","ce","ue","animation","backgroundColor","borderColor","color","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","defineProperties","writable","_scriptable","startsWith","_indexable","_fallback","delay","easing","fn","loop","to","colors","properties","numbers","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","callback","minor","major","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","fe","document","ge","parentNode","host","pe","me","ownerDocument","defaultView","getComputedStyle","xe","getPropertyValue","be","_e","height","ye","shadowRoot","ve","canvas","currentDevicePixelRatio","boxSizing","box","touches","offsetX","offsetY","target","getBoundingClientRect","clientX","clientY","Me","we","maxWidth","maxHeight","clientWidth","clientHeight","ke","ctx","setTransform","Se","passive","addEventListener","removeEventListener","Pe","match","De","Ce","measureText","Oe","data","garbageCollect","save","restore","Ae","Te","getContext","resetTransform","clearRect","Le","Ee","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","Re","Ie","ze","Fe","Ve","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Ne","strokeWidth","strokeColor","string","translation","fillStyle","textAlign","textBaseline","backdrop","We","fillRect","strokeStyle","strokeText","fillText","Be","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","He","topLeft","bottomLeft","bottomRight","topRight","je","ti","Proxy","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","deleteProperty","_keys","qe","Ue","Je","getOwnPropertyDescriptor","Reflect","getPrototypeOf","ei","ownKeys","_storage","$e","_proxy","_context","_subProxy","_stack","_descriptors","Ye","setContext","isScriptable","Error","join","filter","isIndexable","allKeys","scriptable","indexable","_allKeys","Ge","Ze","ii","key","_parsing","parse","si","EPSILON","ni","skip","oi","ai","previous","next","ri","li","cubicInterpolationMode","tension","capBezierPoints","ci","di","ui","fi","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","gi","pi","mi","xi","bi","_i","yi","vi","Mi","wi","ki","Si","console","warn","Pi","cacheable","Di","Ci","Oi","setWidth","xPlus","leftForLtr","Ai","getPropertyPriority","setProperty","prevTextDirection","Ti","Li","between","compare","normalize","Ei","end","Ri","property","Ii","segments","points","zi","_loop","Fi","_fullLoop","_chart","Vi","_datasetIndex","Bi","p0","p1","p0DataIndex","p1DataIndex","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Wi","HALF_PI","INFINITY","PITAU","QUARTER_PI","RAD_PER_DEG","TAU","TWO_THIRDS_PI","_addGrace","_alignPixel","_alignStartEnd","_angleBetween","_angleDiff","_arrayUnique","_attachContext","_bezierCurveTo","_bezierInterpolation","_boundSegment","_boundSegments","_capitalize","_computeSegments","_createResolver","_decimalPlaces","_deprecated","_elementsEqual","_factorize","_filterBetween","_getParentNode","_getStartAndCountOfVisiblePoints","_int16Range","_isBetween","_isClickEvent","_isDomSupported","_isPointInArea","_limitValue","_longestText","_lookup","_lookupByKey","_measureText","_merger","_mergerIf","_normalizeAngle","_parseObjectDataRadialScale","_pointInLine","_readValueToProps","_rlookupByKey","_scaleRangesChanged","_setMinAndMaxByKey","_splitKey","_steppedInterpolation","_steppedLineTo","_textX","_toLeftRightCenter","_updateBezierControlPoints","addRoundedRectPath","almostEquals","almostWhole","clearCanvas","clipArea","createContext","debounce","defined","distanceBetweenPoints","drawPoint","drawPointLegend","each","easingEffects","finiteOrDefault","fontString","formatNumber","getAngleFromPoint","getHoverColor","getMaximumSize","getRelativePosition","getRtlAdapter","getStyle","isFunction","isNullOrUndef","isNumber","isObject","isPatternOrGradient","listenArrayEvents","merge","mergeIf","niceNum","noop","overrideTextDirection","readUsedSize","renderText","requestAnimFrame","resolve","resolveObjectKey","restoreTextDirection","retinaScale","setsEqual","splineCurve","splineCurveMonotone","supportsEventListenerOptions","throttled","toDegrees","toDimension","toFont","toFontString","toLineHeight","toPadding","toPercentage","toRadians","toTRBL","toTRBLCorners","uid","unclipArea","unlistenArrayEvents","valueOrDefault","Hi","getSortedVisibleDatasetMetas","Ni","controller","_cachedMeta","_reversePixels","_sharedOptions","getRange","ji","isPointInArea","chartArea","inRange","element","Yi","$i","getCenterPoint","startAngle","endAngle","getProps","Ui","Xi","evaluateInteractionItems","modes","getDatasetMeta","point","nearest","qi","Ki","pos","Gi","Zi","Qi","ts","ss","update","is","maxPadding","horizontal","same","other","es","stack","getPadding","outerWidth","outerHeight","fullSize","ns","os","placed","stackWeight","as","addBox","boxes","position","_layers","removeBox","configure","layout","isHorizontal","leftAndTop","concat","rightAndBottom","vertical","beforeLayout","availableWidth","availableHeight","vBoxMaxWidth","hBoxMaxHeight","Ji","rs","acquireContext","releaseContext","isAttached","updateConfig","ls","hs","cs","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","ds","us","gs","contains","ps","MutationObserver","addedNodes","removedNodes","observe","childList","subtree","ms","xs","bs","_s","ys","ResizeObserver","contentRect","vs","disconnect","Ms","native","ws","getAttribute","removeAttribute","setAttribute","$proxies","attach","detach","isConnected","ks","OffscreenCanvas","Ss","BasePlatform","BasicPlatform","DomPlatform","_detectPlatform","Ps","Ds","boolean","number","Cs","_fn","_easing","_start","_target","_prop","_from","_to","_promises","wait","Promise","res","rej","Os","_properties","getOwnPropertyNames","_animateOptions","$shared","$animations","_createAnimations","all","then","As","Ts","_getSortedDatasetMetas","Ls","Es","stacked","Is","getMatchingVisibleMetas","zs","_stacks","id","Rs","_top","_bottom","_visualValues","Fs","shift","Vs","Bs","Ws","Ns","defaults","datasetElementType","dataElementType","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","_getOtherScale","reset","_destroy","_dataCheck","isExtensible","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","xAxisKey","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","hidden","NEGATIVE_INFINITY","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","parsed","raw","_resolveElementOptions","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_insertElements","_removeElements","updateElements","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","Hs","defaultRoutes","tooltipPosition","hasValue","$s","ceil","Ys","Us","Xs","Ks","Gs","Js","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_length","_maxLength","_longestTextCache","_startPixel","_endPixel","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","getTicks","labels","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","js","_tickSize","maxTicksLimit","enabled","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","first","last","_calculatePadding","_handleMargins","getPixelForTick","isFullSize","_computeLabelSizes","_resolveTickFontOptions","gc","widths","heights","getValueForPixel","getPixelForDecimal","getDecimalForPixel","getBasePixel","getBaseValue","_computeGridLineItems","tickBorderDash","tickBorderDashOffset","qs","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_getXAxisLabelAlignment","_getYAxisLabelAlignment","textOffset","_computeLabelArea","drawBackground","getLineWidthForValue","drawGrid","setLineDash","lineDashOffset","drawBorder","drawLabels","drawTitle","titleX","titleY","_maxDigits","Qs","scope","isForType","isPrototypeOf","register","descriptors","overrides","unregister","en","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","_getRegistryForType","_exec","sn","_init","notify","_createDescriptors","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","on","local","pluginScopeKeys","some","an","rn","ln","hn","dn","cn","error","un","gn","pn","mn","xn","_config","_scopeCache","_resolverCache","clearCache","clear","additionalOptionScopes","_cachedScopes","chartOptionScopes","resolver","subPrefixes","bn","_n","yn","vn","Mn","wn","onComplete","kn","onProgress","Sn","getElementById","Pn","Dn","On","An","instances","registry","version","getChart","Tn","aspectRatio","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","order","isDatasetVisible","_resetElements","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","method","_getUniformDataChanges","Cn","_idx","_updateDataset","meta","_drawDatasets","_drawDataset","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","updateHoverStyle","getActiveElements","setActiveElements","event","replay","inChartArea","_handleEvent","changed","_getActiveElements","Ln","En","formats","diff","startOf","endOf","Rn","_date","zn","_custom","barStart","barEnd","Fn","Vn","Wn","Nn","jn","animateRotate","animateScale","cutout","circumference","spacing","legend","generateLabels","fontColor","innerRadius","outerRadius","_getRotation","_getCircumference","_getRotationExtents","getMaxBorderWidth","getMaxOffset","_getRingWeight","ratioX","ratioY","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","borderAlign","hoverBorderWidth","hoverOffset","$n","angleLines","circular","pointLabels","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","Yn","BarController","categoryPercentage","barPercentage","grouped","_index_","_value_","_getRuler","base","head","_calculateBarValuePixels","_calculateBarIndexPixels","enableBorderRadius","center","Bn","borderSkipped","Hn","inflateAmount","ratio","_getStacks","find","_getStackCount","_getStackIndex","barThickness","In","$bar","pixels","stackCount","minBarLength","skipNull","maxBarThickness","chunk","BubbleController","DoughnutController","LineController","_decimated","segment","animated","updateControlPoints","PieController","PolarAreaController","RadarController","line","getPointPositionForValue","ScatterController","Xn","qn","pixelMargin","outerStart","outerEnd","innerStart","innerEnd","Un","borderRadius","Gn","lineCap","lineJoin","Zn","Jn","ilen","Qn","stepped","move","eo","io","Path2D","no","_path","_points","_segments","_pointsUpdated","pathSegment","path","oo","hitRadius","ao","ro","ho","co","uo","fo","ArcElement","fullCircles","Kn","BarElement","inner","outer","inXRange","inYRange","LineElement","PointElement","hoverRadius","po","mo","xo","_startValue","_endValue","_valueRange","handleTickRangeOptions","getTickLimit","stepSize","computeTickLimit","step","precision","maxTicks","maxDigits","includeBounds","bo","_o","yo","vo","Mo","ko","_zero","wo","So","Po","Lo","getPointPosition","Eo","animate","centerPointLabels","drawingArea","_pointLabels","_pointLabelItems","_padding","Do","getPointLabelContext","Co","setCenterPoint","extra","additionalAngle","Oo","Ao","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","To","Ro","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","Io","zo","Fo","_adapter","parser","isoWeekday","_parseOpts","Vo","MAX_SAFE_INTEGER","Bo","Wo","No","adapters","time","unit","minUnit","displayFormats","_unit","_majorUnit","_offsets","_normalized","date","normalized","_getLabelBounds","getLabelTimestamps","_generate","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","Ho","jo","CategoryScale","_addedLabels","go","unshift","lastIndexOf","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","$o","Yo","Uo","Xo","Ko","forceOverride","Zo","Jo","algorithm","beforeElementsUpdate","threshold","samples","ta","ea","ia","sa","na","ha","da","ca","ra","la","above","below","area","ua","fa","ga","pa","afterDatasetsUpdate","aa","$filler","oa","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","xa","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","ba","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_computeTitleHeight","_fitRows","_fitCols","row","itemWidth","_a","col","adjustHitBoxes","rtl","_draw","textDirection","lineDash","SQRT2","_getLegendItemAt","handleEvent","onLeave","_element","afterEvent","useBorderRadius","va","_drawArgs","titleBlock","wa","WeakMap","Sa","average","Pa","Da","String","Oa","body","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","Ta","yAlign","xAlign","Aa","caretSize","caretPadding","La","cornerRadius","Ea","Ia","tooltip","callbacks","za","beforeTitle","afterTitle","beforeLabel","formattedValue","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","Fa","Va","positioners","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","_createItems","Ca","itemSort","external","drawCaret","getCaretPosition","x3","y3","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","drawFooter","footerAlign","footerColor","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_positionChanged","_ignoreReplayEvents","afterInit","afterDraw","helpers","_adapters","Animation","Animations","animator","DatasetController","Element","Interaction","layouts","platforms","Scale","Ticks","Chart","exports","module","define","amd","globalThis","self","isNumberFinite","defaultValue","dimension","args","thisArg","loopable","len","a0","a1","v0","v1","klen","isValidKey","tval","sval","sources","current","keyResolvers","parts","tmp","part","obj","_getKeyResolver","str","item","epsilon","range","roundedRange","niceRange","fraction","result","isNonPrimitive","rounded","array","degrees","radians","isFiniteNumber","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","pt1","pt2","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","table","cmp","mid","arrayEvents","listener","this","object","stub","argsToUse","ticking","timeout","animationsDisabled","pointCount","distanceToDefinedLo","distanceToDefinedHi","newRanges","Animator","undefined","anims","remaining","charts","cb","acc","cur","lim","p2b","n2b","b2n","n2p","map$1","hex","h1","h2","eq","isShort","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","p2","hwb2rgb","hsv2rgb","names$1","names","nameParse","unpacked","tkeys","ok","nk","unpack","RGB_RE","modHSL","proto","fromObject","input","functionParse","rgbParse","Color","ret","c1","c2","w2","w1","rgb1","rgb2","val","deg","intlCache","num","cacheKey","formatter","getNumberFormat","tickValue","delta","maxTick","calculateDelta","logDelta","numDecimal","remain","getScope","node","root","Defaults","_appliers","context","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","appliers","domNode","parent","parseMaxStyle","styleValue","parentProperty","valueInPixels","el","positions","getPositionedStyle","styles","suffix","useOffsetPos","borderBox","paddings","borders","getCanvasPosition","xOffset","yOffset","round1","bbWidth","bbHeight","margins","containerSize","container","containerStyle","containerBorder","containerPadding","getContainerSize","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","passiveSupported","matches","longest","textWidth","arrayOfThings","cache","jlen","thing","nestedThing","gcLen","pixel","halfWidth","xOffsetW","yOffsetW","rad","margin","flip","midpoint","decorateText","opts","metrics","yDecoration","drawBackdrop","oldColor","setRenderOpts","scopes","prefixes","rootScopes","fallback","getTarget","finalRootScopes","_resolve","prop","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getKeysFromAllScopes","storage","subProxy","descriptorDefaults","receiver","getValue","_resolveScriptable","arr","_resolveArray","_resolveWithContext","resolveFallback","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","getPoint","getValueAxis","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fb","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","controlPoints","prev","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","cp1","cp2","LINE_HEIGHT","FONT_STYLE","numberOrZero","props","objProps","read","inputs","info","minmax","change","keepZero","parentContext","rectX","getRightToLeftAdapter","_itemWidth","direction","original","propertyFn","normalizeSegment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","sub","segmentOptions","findStartAndEnd","splitByStyles","solidSegments","chartContext","baseStyle","readStyle","prevStyle","addStyle","dir","styleChanged","doSplitByStyles","replacer","pixelSize","fontStyle","fontFamily","binarySearch","metaset","lookupMethod","handler","metasets","getIntersectItems","useFinalPosition","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","params","stacks","wrap","buildStacks","getCombinedMax","updateMaxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","visibleVerticalBoxCount","updatePos","handleMaxPadding","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","createAttachObserver","observer","entries","trigger","entry","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","listenDevicePixelRatioChanges","releaseObserver","unlistenDevicePixelRatioChanges","createProxyAndListen","fromNativeEvent","addListener","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","proxies","interpolators","c0","helpersColor","cfg","currentValue","elapsed","promises","resolved","animationOptions","animatedProps","option","newOptions","resolveTargetOptions","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","dsIndex","singleMode","otherValue","found","isStacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","positive","updateStacks","iAxis","vAxis","indexScale","valueScale","getStackKey","getFirstScaleId","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","static","chooseId","xid","yid","rid","iid","vid","scaleID","iAxisKey","vAxisKey","adata","convertObjectDataToArray","resetNewElements","stackChanged","oldStacked","scopeKeys","sorted","isNotInOrderComparedToPrev","singleScale","parsedValue","canStack","otherScale","createStack","otherMin","otherMax","_skip","toClip","defaultClip","createDataContext","createDatasetContext","elementType","sharing","transition","firstOpts","previouslySharedOptions","arg1","arg2","numMeta","numData","removed","newCount","final","tickOpts","determinedMaxTicks","maxScale","maxChart","determineMaxTicks","ticksLimit","majorIndices","getMajorIndices","numMajorIndices","newTicks","skipMajors","evenMajorSpacing","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","edge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","reverseAlign","super","metas","samplingEnabled","startPixel","endPixel","reversePixels","numTicks","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetLeft","offsetRight","caches","tickFont","nestedLabel","widestLabelSize","highestLabelSize","valueAt","idx","decimal","createTickContext","optionTicks","rot","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","positionAxisID","limit","optsAtIndex","optsAtIndexBorder","lineColor","tickAndPadding","hTickAndPadding","lineCount","halfCount","tickTextAlign","labelPadding","drawLine","lastLineWidth","renderTextOptions","titleArgs","tz","gz","bz","axisID","fontSize","TypedRegistry","parentScope","isIChartComponent","itemDefaults","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","Registry","typedRegistry","arg","reg","itemReg","component","camelMethod","PluginService","hook","descriptor","callCallback","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","initConfig","datasetType","mainScope","resetCache","keyLists","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","moveNumericKeys","intKey","getSizeForArea","field","invalidatePlugins","userConfig","initialCanvas","existingChart","newSize","newRatio","axisOptions","scaleOpts","updated","isRadial","scaleType","hasUpdated","newControllers","ControllerClass","animsDisabled","existingEvents","newEvents","changes","datasetCount","makeSet","changeSet","noArea","layers","useClip","getDatasetArea","_add","_remove","detached","activeElements","lastActive","pluginId","hoverOptions","deactivated","activated","eventFilter","isClick","lastEvent","determineLastEvent","abstract","DateAdapterBase","members","computeMinSampleSize","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderProps","parseEdge","orig","v2","startEnd","setInflateAmount","legendItem","getter","arcs","maxSize","chartWeight","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","animationOpts","centerX","centerY","metaData","ringWeightOffset","datasetStartAngle","defaultAngle","bars","ruler","vpixels","ipixels","currentParsed","iScaleValue","baseValue","actualBase","floating","barSign","halfGrid","Infinity","percent","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","pointPosition","parseBorderRadius","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","rThetaToXY","theta","pathArc","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","angleMargin","clipArc","setStyle","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","lineMethod","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","strokePathWithCache","segmentMethod","strokePathDirect","_interpolate","_getInterpolationMethod","interpolated","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","addRectPath","mouseX","mouseY","findOrAddLabel","addedLabels","addIfString","_getLabelForValue","relativeLabelSize","minSpacing","LinearScaleBase","setMin","setMax","minSign","maxSign","generationOptions","dataRange","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks","log10Floor","changeExponent","isMajor","tickVal","rangeExp","rangeStep","minExp","exp","startExp","lastTick","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","plFont","textSize","updateLimits","itemOpts","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","labelCount","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","UNITS","sorter","adapter","determineUnitForAutoTicks","capacity","interval","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","_applyBounds","timeOpts","determineUnitForFormatting","determineMajorUnit","weekday","hasWeekday","fmt","minorFormat","majorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","added","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","plugin_colors","_args","chartOptions","containsColorDefenition","colorizer","cleanDecimatedDataset","cleanDecimatedData","plugin_decimation","xAxis","getStartAndCountOfVisiblePointsSimplified","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","getBoxSize","labelOpts","labelFont","hitboxes","totalHeight","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","rtlHelper","hitbox","defaultColor","halfFontSize","cursor","drawOptions","yBoxTop","xBoxLeft","drawLegendBox","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","hoveredItem","sameItem","plugin_legend","fontOpts","plugin_title","createTitle","plugin_subtitle","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","createTooltipItem","getTooltipSize","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","widthPadding","maxLineWidth","determineXAlign","chartWidth","caret","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","tooltipItem","invokeCallbackWithFallback","bodyItems","scoped","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","colorX","rtlColorX","yOffSet","colorY","outerX","innerX","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","hasTooltipContent","positionChanged","plugin_tooltip"],"version":3,"file":"walkthrough.4026550d.js.map"}